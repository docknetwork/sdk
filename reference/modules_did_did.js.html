<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: modules/did/did.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: modules/did/did.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { encodeAddress } from '@polkadot/util-crypto';
import { u8aToString, hexToU8a, u8aToHex } from '@polkadot/util';
import { BTreeSet } from '@polkadot/types';
import b58 from 'bs58';
import {
  getHexIdentifierFromDID,
  DockDIDQualifier,
  NoDIDError,
  validateDockDIDHexIdentifier,
  NoOnchainDIDError,
  NoOffchainDIDError,
  createDidSig,
} from '../../utils/did';
import { getSignatureFromKeyringPair, getStateChange } from '../../utils/misc';

import OffChainDidDocRef from './offchain-did-doc-ref';
import {
  PublicKeyEd25519,
  PublicKeySecp256k1,
  PublicKeySr25519,
  PublicKeyX25519,
  DidKey,
  VerificationRelationship,
} from '../../public-keys';
import { ServiceEndpointType } from './service-endpoint';
import WithParamsAndPublicKeys from '../WithParamsAndPublicKeys';

export const ATTESTS_IRI = 'https://rdf.dock.io/alpha/2021#attestsDocumentContents';

const valuePropOrIdentity = (val) => val.value || val;

/** Class to create, update and destroy DIDs */
class DIDModule {
  /**
   * Creates a new instance of DIDModule and sets the api
   * @constructor
   * @param {object} api - PolkadotJS API Reference
   */
  constructor(api, signAndSend) {
    this.api = api;
    this.module = api.tx.didModule;
    this.signAndSend = signAndSend;
  }

  /**
   * Creates transaction to create a new off-chain DID
   * @param did -
   * @param {OffChainDidDocRef} didDocRef - Off chain reference for the DID
   * @returns {*}
   */
  createNewOffchainTx(did, didDocRef) {
    const hexId = getHexIdentifierFromDID(did);
    return this.module.newOffchain(hexId, didDocRef);
  }

  /**
   * Create a new off-chain DID
   * @param did
   * @param didDocRef - Off chain reference for the DID
   * @param waitForFinalization
   * @param params
   * @returns {Promise&lt;*>}
   */
  async newOffchain(did, didDocRef, waitForFinalization = true, params = {}) {
    return this.signAndSend(
      this.createNewOffchainTx(did, didDocRef),
      waitForFinalization,
      params,
    );
  }

  /**
   * Create a transaction to update the DID Doc reference of the off chain DID
   * @param did
   * @param didDocRef - new reference
   * @returns {*}
   */
  createSetOffchainDidRefTx(did, didDocRef) {
    const hexId = getHexIdentifierFromDID(did);
    return this.module.setOffchainDidDocRef(hexId, didDocRef);
  }

  /**
   * Update the DID Doc reference of the off chain DID
   * @param did
   * @param didDocRef
   * @param waitForFinalization
   * @param params
   * @returns {Promise&lt;*>}
   */
  async setOffchainDidRef(
    did,
    didDocRef,
    waitForFinalization = true,
    params = {},
  ) {
    return this.signAndSend(
      this.createSetOffchainDidRefTx(did, didDocRef),
      waitForFinalization,
      params,
    );
  }

  /**
   * Create transaction to remove off chain DID
   * @param did
   * @returns {Promise&lt;*>}
   */
  createRemoveOffchainDidTx(did) {
    const hexId = getHexIdentifierFromDID(did);
    return this.module.removeOffchainDid(hexId);
  }

  /**
   * Remove off-chain DID
   * @param did
   * @param waitForFinalization
   * @param params
   * @returns {Promise&lt;*>}
   */
  async removeOffchainDid(did, waitForFinalization = true, params = {}) {
    return this.signAndSend(
      this.createRemoveOffchainDidTx(did),
      waitForFinalization,
      params,
    );
  }

  /**
   * Creates transaction to create a new DID on the Dock chain.
   * @param {string} did - The new DID. Can be a full DID or hex identifier
   * @param {DidKey[]} didKeys - Array of `DidKey`s as expected by the Substrate node
   * @param {array} controllers - Array of `Did`s as expected by the Substrate node
   * @return {object} The extrinsic to sign and send.
   */
  createNewOnchainTx(did, didKeys, controllers) {
    const cnts = new BTreeSet();
    if (controllers !== undefined) {
      controllers.forEach((c) => {
        cnts.add(getHexIdentifierFromDID(c));
      });
    }
    const hexId = getHexIdentifierFromDID(did);
    return this.module.newOnchain(
      hexId,
      didKeys.map((d) => d.toJSON()),
      cnts,
    );
  }

  /**
   * Creates a new DID on the Dock chain.
   * @param {string} did - The new DID. Can be a full DID or hex identifier
   * @param {DidKey[]} didKeys - Array of `DidKey`s as expected by the Substrate node
   * @param {array} controllers - Array of `Did`s as expected by the Substrate node.
   * @param waitForFinalization
   * @param params
   * @return {Promise&lt;object>} Promise to the pending transaction
   */
  async new(
    did,
    didKeys,
    controllers,
    waitForFinalization = true,
    params = {},
  ) {
    return this.signAndSend(
      this.createNewOnchainTx(did, didKeys, controllers),
      waitForFinalization,
      params,
    );
  }

  /**
   * Create transaction to add keys to an on-chain DID.
   * @param {DidKey[]} didKeys - Array of `DidKey`s as expected by the Substrate node
   * @param targetDid - The DID to which keys are being added
   * @param signerDid - The DID that is adding the keys by signing the payload because it controls `targetDid`
   * @param keyPair - Signer's keypair
   * @param keyId - The key id used by the signer. This will be used by the verifier (node) to fetch the public key for verification
   * @param nonce - The nonce to be used for sending this transaction. If not provided then an appropriate nonce will be
   * fetched from chain before creating the transaction
   * @returns {Promise&lt;*>}
   */
  async createAddKeysTx(
    didKeys,
    targetDid,
    signerDid,
    keyPair,
    keyId,
    nonce = undefined,
  ) {
    const targetHexDid = getHexIdentifierFromDID(targetDid);
    const signerHexDid = getHexIdentifierFromDID(signerDid);
    const [addKeys, signature] = await this.createSignedAddKeys(
      didKeys,
      targetHexDid,
      signerHexDid,
      keyPair,
      keyId,
      nonce,
    );
    return this.module.addKeys(addKeys, signature);
  }

  /**
   * Add keys to an on-chain DID
   * @param {DidKey[]} didKeys - Array of `DidKey`s as expected by the Substrate node
   * @param targetDid - The DID to which keys are being added
   * @param signerDid - The DID that is adding the keys by signing the payload because it controls `targetDid`
   * @param keyPair - Signer's keypair
   * @param keyId - The key id used by the signer. This will be used by the verifier (node) to fetch the public key for verification
   * @param nonce - The nonce to be used for sending this transaction. If not provided then an appropriate nonce will be
   * fetched from chain before creating the transaction
   * @param waitForFinalization
   * @param params
   * @returns {Promise&lt;*>}
   */
  async addKeys(
    didKeys,
    targetDid,
    signerDid,
    keyPair,
    keyId,
    nonce = undefined,
    waitForFinalization = true,
    params = {},
  ) {
    return this.signAndSend(
      await this.createAddKeysTx(
        didKeys,
        targetDid,
        signerDid,
        keyPair,
        keyId,
        nonce,
      ),
      waitForFinalization,
      params,
    );
  }

  /**
   *  Create transaction to add controllers to an on-chain DID.
   * @param controllers - The DIDs that will control the `targetDid`
   * @param targetDid - The DID to which keys are being added
   * @param signerDid - The DID that is adding the controllers by signing the payload because it controls `targetDid`
   * @param keyPair - Signer's keypair
   * @param keyId - The key id used by the signer. This will be used by the verifier (node) to fetch the public key for verification
   * @param nonce - The nonce to be used for sending this transaction. If not provided then an appropriate nonce will be
   * fetched from chain before creating the transaction
   * @returns {Promise&lt;*>}
   */
  async createAddControllersTx(
    controllers,
    targetDid,
    signerDid,
    keyPair,
    keyId,
    nonce = undefined,
  ) {
    const targetHexDid = getHexIdentifierFromDID(targetDid);
    const signerHexDid = getHexIdentifierFromDID(signerDid);
    const [addControllers, signature] = await this.createSignedAddControllers(
      controllers,
      targetHexDid,
      signerHexDid,
      keyPair,
      keyId,
      nonce,
    );
    return this.module.addControllers(addControllers, signature);
  }

  /**
   * Add controllers to an on-chain DID.
   * @param controllers - The DIDs that will control the `targetDid`
   * @param targetDid - The DID to which controllers are being added
   * @param signerDid - The DID that is adding the controllers by signing the payload because it controls `targetDid`
   * @param keyPair - Signer's keypair
   * @param keyId - The key id used by the signer. This will be used by the verifier (node) to fetch the public key for verification
   * @param nonce - The nonce to be used for sending this transaction. If not provided then an appropriate nonce will be
   * fetched from chain before creating the transaction
   * @param waitForFinalization
   * @param params
   * @returns {Promise&lt;*>}
   */
  async addControllers(
    controllers,
    targetDid,
    signerDid,
    keyPair,
    keyId,
    nonce = undefined,
    waitForFinalization = true,
    params = {},
  ) {
    const tx = await this.createAddControllersTx(
      controllers,
      targetDid,
      signerDid,
      keyPair,
      keyId,
      nonce,
    );
    return this.signAndSend(tx, waitForFinalization, params);
  }

  /**
   * Create a transaction to add a new service endpoint
   * @param endpointId - The id of the service endpoint. Each endpoint has a unique id.
   * @param {ServiceEndpointType} endpointType - The type of the endpoint.
   * @param {Array} origins - An array of one of URIs encoded as hex.
   * @param targetDid - The DID to which service endpoint is being added
   * @param signerDid - The DID that is adding the service endpoint by signing the payload because it controls `targetDid`
   * @param keyPair - Signer's keypair
   * @param keyId - The key id used by the signer. This will be used by the verifier (node) to fetch the public key for verification
   * @param nonce - The nonce to be used for sending this transaction. If not provided then an appropriate nonce will be
   * fetched from chain before creating the transaction
   * @returns {Promise&lt;*>}
   */
  async createAddServiceEndpointTx(
    endpointId,
    endpointType,
    origins,
    targetDid,
    signerDid,
    keyPair,
    keyId,
    nonce = undefined,
  ) {
    const targetHexDid = getHexIdentifierFromDID(targetDid);
    const signerHexDid = getHexIdentifierFromDID(signerDid);
    const [addServiceEndpoint, signature] = await this.createSignedAddServiceEndpoint(
      endpointId,
      endpointType,
      origins,
      targetHexDid,
      signerHexDid,
      keyPair,
      keyId,
      nonce,
    );
    return this.module.addServiceEndpoint(addServiceEndpoint, signature);
  }

  /**
   * Add a new service endpoint
   * @param endpointId - The id of the service endpoint. Each endpoint has a unique id.
   * @param {ServiceEndpointType} endpointType - The type of the endpoint.
   * @param {Array} origins - An array of one of URIs encoded as hex.
   * @param targetDid - The DID to which service endpoint is being added
   * @param signerDid - The DID that is adding the service endpoint by signing the payload because it controls `targetDid`
   * @param keyPair - Signer's keypair
   * @param keyId - The key id used by the signer. This will be used by the verifier (node) to fetch the public key for verification
   * @param nonce - The nonce to be used for sending this transaction. If not provided then an appropriate nonce will be
   * fetched from chain before creating the transaction
   * @param waitForFinalization
   * @param params
   * @returns {Promise&lt;*>}
   */
  async addServiceEndpoint(
    endpointId,
    endpointType,
    origins,
    targetDid,
    signerDid,
    keyPair,
    keyId,
    nonce = undefined,
    waitForFinalization = true,
    params = {},
  ) {
    const tx = await this.createAddServiceEndpointTx(
      endpointId,
      endpointType,
      origins,
      targetDid,
      signerDid,
      keyPair,
      keyId,
      nonce,
    );
    return this.signAndSend(tx, waitForFinalization, params);
  }

  /**
   * Create transaction to remove keys
   * @param keyIds - Key indices to remove
   * @param targetDid - The DID from which keys are being removed
   * @param signerDid - The DID that is removing the keys by signing the payload because it controls `targetDid`
   * @param keyPair - Signer's keypair
   * @param keyId - The key id used by the signer. This will be used by the verifier (node) to fetch the public key for verification
   * @param nonce - The nonce to be used for sending this transaction. If not provided then an appropriate nonce will be
   * fetched from chain before creating the transaction
   * @returns {Promise&lt;*>}
   */
  async createRemoveKeysTx(
    keyIds,
    targetDid,
    signerDid,
    keyPair,
    keyId,
    nonce = undefined,
  ) {
    const targetHexDid = getHexIdentifierFromDID(targetDid);
    const signerHexDid = getHexIdentifierFromDID(signerDid);
    const [removeKeys, signature] = await this.createSignedRemoveKeys(
      keyIds,
      targetHexDid,
      signerHexDid,
      keyPair,
      keyId,
      nonce,
    );
    return this.module.removeKeys(removeKeys, signature);
  }

  /**
   * Remove keys from a DID
   * @param keyIds - Key indices to remove
   * @param targetDid - The DID from which keys are being removed
   * @param signerDid - The DID that is removing the keys by signing the payload because it controls `targetDid`
   * @param keyPair - Signer's keypair
   * @param keyId - The key id used by the signer. This will be used by the verifier (node) to fetch the public key for verification
   * @param nonce - The nonce to be used for sending this transaction. If not provided then an appropriate nonce will be
   * fetched from chain before creating the transaction
   * @param waitForFinalization
   * @param params
   * @returns {Promise&lt;*>}
   */
  async removeKeys(
    keyIds,
    targetDid,
    signerDid,
    keyPair,
    keyId,
    nonce = undefined,
    waitForFinalization = true,
    params = {},
  ) {
    const tx = await this.createRemoveKeysTx(
      keyIds,
      targetDid,
      signerDid,
      keyPair,
      keyId,
      nonce,
    );
    return this.signAndSend(tx, waitForFinalization, params);
  }

  /**
   * Create transaction to remove controllers from a DID
   * @param controllers - Controller DIDs to remove.
   * @param targetDid - The DID from which controllers are being removed
   * @param signerDid - The DID that is removing the controllers by signing the payload because it controls `targetDid`
   * @param keyPair - Signer's keypair
   * @param keyId - The key id used by the signer. This will be used by the verifier (node) to fetch the public key for verification
   * @param nonce - The nonce to be used for sending this transaction. If not provided then an appropriate nonce will be
   * fetched from chain before creating the transaction
   * @returns {Promise&lt;*>}
   */
  async removeControllersTx(
    controllers,
    targetDid,
    signerDid,
    keyPair,
    keyId,
    nonce = undefined,
  ) {
    const targetHexDid = getHexIdentifierFromDID(targetDid);
    const signerHexDid = getHexIdentifierFromDID(signerDid);
    const [removeControllers, signature] = await this.createSignedRemoveControllers(
      controllers,
      targetHexDid,
      signerHexDid,
      keyPair,
      keyId,
      nonce,
    );
    return this.module.removeControllers(removeControllers, signature);
  }

  /**
   * Remove controllers from a DID
   * @param controllers - Controller DIDs to remove.
   * @param targetDid - The DID from which controllers are being removed
   * @param signerDid - The DID that is removing the controllers by signing the payload because it controls `targetDid`
   * @param keyPair - Signer's keypair
   * @param keyId - The key id used by the signer. This will be used by the verifier (node) to fetch the public key for verification
   * @param nonce - The nonce to be used for sending this transaction. If not provided then an appropriate nonce will be
   * fetched from chain before creating the transaction
   * @param waitForFinalization
   * @param params
   * @returns {Promise&lt;*>}
   */
  async removeControllers(
    controllers,
    targetDid,
    signerDid,
    keyPair,
    keyId,
    nonce = undefined,
    waitForFinalization = true,
    params = {},
  ) {
    const tx = await this.removeControllersTx(
      controllers,
      targetDid,
      signerDid,
      keyPair,
      keyId,
      nonce,
    );
    return this.signAndSend(tx, waitForFinalization, params);
  }

  /**
   * Create transaction to remove a service endpoint from a DID
   * @param endpointId - The endpoint to remove
   * @param targetDid - The DID from which endpoint is being removed
   * @param signerDid - The DID that is removing the endpoint by signing the payload because it controls `targetDid`
   * @param keyPair - Signer's keypair
   * @param keyId - The key id used by the signer. This will be used by the verifier (node) to fetch the public key for verification
   * @param nonce - The nonce to be used for sending this transaction. If not provided then an appropriate nonce will be
   * fetched from chain before creating the transaction
   * @returns {Promise&lt;*>}
   */
  async createRemoveServiceEndpointTx(
    endpointId,
    targetDid,
    signerDid,
    keyPair,
    keyId,
    nonce = undefined,
  ) {
    const targetHexDid = getHexIdentifierFromDID(targetDid);
    const signerHexDid = getHexIdentifierFromDID(signerDid);
    const [removeServiceEndpoint, signature] = await this.createSignedRemoveServiceEndpoint(
      endpointId,
      targetHexDid,
      signerHexDid,
      keyPair,
      keyId,
      nonce,
    );
    return this.module.removeServiceEndpoint(removeServiceEndpoint, signature);
  }

  /**
   * Remove a service endpoint from a DID
   * @param endpointId - The endpoint to remove
   * @param targetDid - The DID from which endpoint is being removed
   * @param signerDid - The DID that is removing the endpoint by signing the payload because it controls `targetDid`
   * @param keyPair - Signer's keypair
   * @param keyId - The key id used by the signer. This will be used by the verifier (node) to fetch the public key for verification
   * @param nonce - The nonce to be used for sending this transaction. If not provided then an appropriate nonce will be
   * fetched from chain before creating the transaction
   * @param waitForFinalization
   * @param params
   * @returns {Promise&lt;*>}
   */
  async removeServiceEndpoint(
    endpointId,
    targetDid,
    signerDid,
    keyPair,
    keyId,
    nonce = undefined,
    waitForFinalization = true,
    params = {},
  ) {
    const tx = await this.createRemoveServiceEndpointTx(
      endpointId,
      targetDid,
      signerDid,
      keyPair,
      keyId,
      nonce,
    );
    return this.signAndSend(tx, waitForFinalization, params);
  }

  /**
   * Create a transaction to remove an on-chain DID
   * @param targetDid - The DID being removed
   * @param signerDid - The DID that is removing `targetDid` by signing the payload because it controls `targetDid`
   * @param keyPair - Signer's keypair
   * @param keyId - The key id used by the signer. This will be used by the verifier (node) to fetch the public key for verification
   * @param nonce - The nonce to be used for sending this transaction. If not provided then an appropriate nonce will be
   * fetched from chain before creating the transaction
   * @return {Promise&lt;object>} The extrinsic to sign and send.
   */
  async createRemoveTx(
    targetDid,
    signerDid,
    keyPair,
    keyId,
    nonce = undefined,
  ) {
    const hexDid = getHexIdentifierFromDID(targetDid);
    const signerHexDid = getHexIdentifierFromDID(signerDid);
    const [didRemoval, signature] = await this.createSignedDidRemoval(
      hexDid,
      signerHexDid,
      keyPair,
      keyId,
      nonce,
    );
    return this.module.removeOnchainDid(didRemoval, signature);
  }

  /**
   * Removes an on-chain DID.
   * @param targetDid - The DID being removed
   * @param signerDid - The DID that is removing `targetDid` by signing the payload because it controls `targetDid`
   * @param keyPair - Signer's keypair
   * @param keyId - The key id used by the signer. This will be used by the verifier (node) to fetch the public key for verification
   * @param nonce - The nonce to be used for sending this transaction. If not provided then an appropriate nonce will be
   * fetched from chain before creating the transaction
   * @param waitForFinalization
   * @param params
   * @return {Promise&lt;object>} Promise to the pending transaction
   */
  async remove(
    targetDid,
    signerDid,
    keyPair,
    keyId,
    nonce = undefined,
    waitForFinalization = true,
    params = {},
  ) {
    const tx = await this.createRemoveTx(
      targetDid,
      signerDid,
      keyPair,
      keyId,
      nonce,
    );
    return this.signAndSend(tx, waitForFinalization, params);
  }

  /**
   *
   * @param priority
   * @param iri
   * @param did
   * @param keyPair
   * @param keyId
   * @param nonce
   * @returns {Promise&lt;SubmittableExtrinsic&lt;ApiType>>}
   */
  async createSetClaimTx(
    priority,
    iri,
    did,
    keyPair,
    keyId,
    nonce = undefined,
  ) {
    const hexDid = getHexIdentifierFromDID(did);
    const [setAttestation, signature] = await this.createSignedAttestation(
      priority,
      iri,
      hexDid,
      keyPair,
      keyId,
      nonce,
    );
    return this.api.tx.attest.setClaim(setAttestation, signature);
  }

  /**
   * Creates an attestation claim on chain for a specific DID
   * @param priority
   * @param iri
   * @param did
   * @param keyPair
   * @param keyId
   * @param nonce
   * @param waitForFinalization
   * @param params
   */
  async setClaim(
    priority,
    iri,
    did,
    keyPair,
    keyId,
    nonce = undefined,
    waitForFinalization = true,
    params = {},
  ) {
    const attestTx = await this.createSetClaimTx(
      priority,
      iri,
      did,
      keyPair,
      keyId,
      nonce,
    );
    return this.signAndSend(attestTx, waitForFinalization, params);
  }

  /**
   * Create the fully qualified DID like "did:dock:..."
   * @param {string} did - DID
   * @return {string} The DID identifier.
   */
  getFullyQualifiedDID(did) {
    return `${DockDIDQualifier}${did}`;
  }

  /**
   * Fetches the DIDs attestations IRI from the chain
   * @param {string} hexId - DID in hex format
   * @return {Promise&lt;string | null>} The DID's attestation, if any
   */
  async getAttests(hexId) {
    const attests = await this.api.query.attest.attestations(hexId);
    return attests.iri.isSome
      ? u8aToString(hexToU8a(attests.iri.toString()))
      : null;
  }

  /**
   * Gets a DID from the Dock chain and create a DID document according to W3C spec.
   * Throws NoDID if the DID does not exist on chain.
   * @param {string} did - The DID can be passed as fully qualified DID like `did:dock:&lt;SS58 string>` or
   * a 32 byte hex string
   * @return {Promise&lt;object>} The DID document.
   */
  // eslint-disable-next-line sonarjs/cognitive-complexity
  async getDocument(did, { getOffchainSigKeys = true } = {}) {
    const hexId = getHexIdentifierFromDID(did);
    let didDetails = await this.getOnchainDidDetail(hexId);
    didDetails = didDetails.data || didDetails;

    // Get DIDs attestations
    const attests = await this.getAttests(hexId);

    // If given DID was in hex, encode to SS58 and then construct fully qualified DID else the DID was already fully qualified
    const id = (did === hexId) ? this.getFullyQualifiedDID(encodeAddress(hexId)) : did;

    // Get controllers
    const controllers = [];
    if (didDetails.activeControllers > 0) {
      const cnts = await this.api.query.didModule.didControllers.entries(hexId);
      cnts.forEach(([key, value]) => {
        if (value.isSome) {
          const [controlled, controller] = key.toHuman();
          if (controlled !== hexId) {
            throw new Error(`Controlled DID ${controlled[0]} was found to be different than queried DID ${hexId}`);
          }
          controllers.push(controller);
        }
      });
    }

    // Get service endpoints
    const serviceEndpoints = [];
    const sps = await this.api.query.didModule.didServiceEndpoints.entries(hexId);
    sps.forEach(([key, value]) => {
      if (value.isSome) {
        const sp = value.unwrap();
        // eslint-disable-next-line no-underscore-dangle
        const [d, spId] = key.args;
        // eslint-disable-next-line no-underscore-dangle
        const d_ = u8aToHex(d);
        if (d_ !== hexId) {
          throw new Error(`DID ${d_} was found to be different than queried DID ${hexId}`);
        }
        serviceEndpoints.push([spId, sp]);
      }
    });

    // Get keys and categorize them by verification relationship type
    const keys = [];
    const assertion = [];
    const authn = [];
    const capInv = [];
    const keyAgr = [];
    if (didDetails.lastKeyId > 0) {
      const dks = await this.api.query.didModule.didKeys.entries(hexId);
      dks.forEach(([key, value]) => {
        if (value.isSome) {
          const dk = value.unwrap();
          // eslint-disable-next-line no-underscore-dangle
          const [d, i] = key.args;
          // eslint-disable-next-line no-underscore-dangle
          const d_ = u8aToHex(d);
          if (d_ !== hexId) {
            throw new Error(`DID ${d_} was found to be different than queried DID ${hexId}`);
          }
          const index = i.toNumber();
          const pk = dk.publicKey;
          let publicKeyRaw;
          let typ;
          if (pk.isSr25519) {
            typ = 'Sr25519VerificationKey2020';
            publicKeyRaw = valuePropOrIdentity(pk.asSr25519);
          } else if (pk.isEd25519) {
            typ = 'Ed25519VerificationKey2018';
            publicKeyRaw = valuePropOrIdentity(pk.asEd25519);
          } else if (pk.isSecp256k1) {
            typ = 'EcdsaSecp256k1VerificationKey2019';
            publicKeyRaw = valuePropOrIdentity(pk.asSecp256k1);
          } else if (pk.isX25519) {
            typ = 'X25519KeyAgreementKey2019';
            publicKeyRaw = valuePropOrIdentity(pk.asX25519);
          } else {
            throw new Error(`Cannot parse public key ${pk}`);
          }
          keys.push([index, typ, publicKeyRaw]);
          const vr = new VerificationRelationship(dk.verRels.toNumber());
          if (vr.isAuthentication(vr)) {
            authn.push(index);
          }
          if (vr.isAssertion(vr)) {
            assertion.push(index);
          }
          if (vr.isCapabilityInvocation(vr)) {
            capInv.push(index);
          }
          if (vr.isKeyAgreement(vr)) {
            keyAgr.push(index);
          }
        }
      });
    }

    if (getOffchainSigKeys === true) {
      const { lastKeyId } = didDetails;

      // If any keys should be fetched
      if (lastKeyId > keys.length) {
        // key id can be anything from 1 to `lastKeyId`
        const possibleKeyIds = new Set();
        for (let i = 1; i &lt;= lastKeyId; i++) {
          possibleKeyIds.add(i);
        }
        // Remove key ids already seen as non-BBS+
        for (const [i] of keys) {
          possibleKeyIds.delete(i);
        }

        // Query all BBS+ keys in a single RPC call to the node.
        const queryKeys = [];
        for (const k of possibleKeyIds) {
          queryKeys.push([hexId, k]);
        }
        if (this.api.query.offchainSignatures != null) {
          const resp = await this.api.query.offchainSignatures.publicKeys.multi(queryKeys);
          let currentIter = 0;
          for (let r of resp) {
            // The gaps in `keyId` might correspond to removed keys
            if (r.isSome) {
              let rawKey; let
                keyType;
              r = r.unwrap();

              if (r.isBbs) {
                keyType = 'Bls12381BBSVerificationKeyDock2023';
                rawKey = r.asBbs;
              } else if (r.isBbsPlus) {
                keyType = 'Bls12381G2VerificationKeyDock2022';
                rawKey = r.asBbsPlus;
              } else if (r.isPs) {
                keyType = 'Bls12381PSVerificationKeyDock2023';
                rawKey = r.asPs;
              }
              // Don't care about signature params for now
              const pkObj = WithParamsAndPublicKeys.createPublicKeyObjFromChainResponse(rawKey);
              if (pkObj.curveType !== 'Bls12381') {
                throw new Error(`Curve type should have been Bls12381 but was ${pkObj.curveType}`);
              }
              const keyIndex = queryKeys[currentIter][1];
              keys.push([keyIndex, keyType, hexToU8a(pkObj.bytes)]);
              assertion.push(keyIndex);
            }
            currentIter++;
          }
        } else {
          const resp = await this.api.query.bbsPlus.bbsPlusKeys.multi(queryKeys);
          let currentIter = 0;
          for (const r of resp) {
            // The gaps in `keyId` might correspond to removed keys
            if (r.isSome) {
              const keyType = 'Bls12381G2VerificationKeyDock2022';
              const rawKey = r.unwrap();

              // Don't care about signature params for now
              const pkObj = WithParamsAndPublicKeys.createPublicKeyObjFromChainResponse(rawKey);
              if (pkObj.curveType !== 'Bls12381') {
                throw new Error(`Curve type should have been Bls12381 but was ${pkObj.curveType}`);
              }
              const keyIndex = queryKeys[currentIter][1];
              keys.push([keyIndex, keyType, hexToU8a(pkObj.bytes)]);
              assertion.push(keyIndex);
            }
            currentIter++;
          }
        }
      }
    }

    keys.sort((a, b) => a[0] - b[0]);
    assertion.sort();
    authn.sort();
    capInv.sort();
    keyAgr.sort();

    const verificationMethod = keys.map(([index, typ, publicKeyRaw]) => ({
      id: `${id}#keys-${index}`,
      type: typ,
      controller: id,
      publicKeyBase58: b58.encode(publicKeyRaw),
    }));
    const assertionMethod = assertion.map((i) => `${id}#keys-${i}`);
    const authentication = authn.map((i) => `${id}#keys-${i}`);
    const capabilityInvocation = capInv.map((i) => `${id}#keys-${i}`);
    const keyAgreement = keyAgr.map((i) => `${id}#keys-${i}`);

    // Construct document
    const document = {
      '@context': ['https://www.w3.org/ns/did/v1'],
      id,
      controller: [...controllers].map((c) => this.getFullyQualifiedDID(encodeAddress(c))),
      publicKey: verificationMethod,
    };

    if (authentication.length > 0) {
      document.authentication = authentication;
    }
    if (assertionMethod.length > 0) {
      document.assertionMethod = assertionMethod;
    }
    if (keyAgreement.length > 0) {
      document.keyAgreement = keyAgreement;
    }
    if (capabilityInvocation.length > 0) {
      document.capabilityInvocation = capabilityInvocation;
    }

    if (serviceEndpoints.length > 0) {
      const decoder = new TextDecoder();
      document.service = serviceEndpoints.map(([spId, sp]) => {
        const spType = sp.types.toNumber();
        if (spType !== 1) {
          throw new Error(
            `Only "LinkedDomains" supported as service endpoint type for now but found ${spType}`,
          );
        }
        return {
          id: decoder.decode(spId),
          type: 'LinkedDomains',
          serviceEndpoint: sp.origins.map((o) => decoder.decode(o)),
        };
      });
    }

    // Assign attestations
    if (attests) {
      document[ATTESTS_IRI] = attests;
    }

    return document;
  }

  /**
   * Gets the DID detail of an on chain DID
   * the chain and return them. It will throw NoDID if the DID does not exist on
   * chain.
   * @param {string} didIdentifier - DID identifier as hex. Not accepting full DID intentionally for efficiency as these
   * methods are used internally
   * @return {Promise&lt;object>}
   */
  async getOnchainDidDetail(didIdentifier) {
    validateDockDIDHexIdentifier(didIdentifier);
    let resp = await this.api.query.didModule.dids(didIdentifier);
    if (resp.isNone) {
      throw new NoDIDError(`did:dock:${didIdentifier}`);
    }

    resp = resp.unwrap();
    if (resp.isOffChain) {
      throw new NoOnchainDIDError(`did:dock:${didIdentifier}`);
    }
    const didDetail = resp.asOnChain;
    const data = didDetail.data || didDetail;
    return {
      nonce: didDetail.nonce.toNumber(),
      lastKeyId: data.lastKeyId.toNumber(),
      activeControllerKeys: data.activeControllerKeys.toNumber(),
      activeControllers: data.activeControllers.toNumber(),
    };
  }

  /**
   * Gets the DID detail of an on chain DID
   * @param didIdentifier
   * @returns {Promise&lt;{accountId: HexString}>}
   */
  async getOffchainDidDetail(didIdentifier) {
    validateDockDIDHexIdentifier(didIdentifier);
    let resp = await this.api.query.didModule.dids(didIdentifier);
    if (resp.isNone) {
      throw new NoDIDError(`did:dock:${didIdentifier}`);
    }
    resp = resp.unwrap();
    if (resp.isOnChain) {
      throw new NoOffchainDIDError(`did:dock:${didIdentifier}`);
    }
    resp = resp.asOffChain;
    const detail = { accountId: u8aToHex(resp.accountId) };

    if (resp.docRef.isCid) {
      detail.docRef = OffChainDidDocRef.cid(u8aToHex(resp.docRef.asCid));
    } else if (resp.docRef.isUrl) {
      detail.docRef = OffChainDidDocRef.url(u8aToHex(resp.docRef.asUrl));
    } else if (resp.docRef.isCustom) {
      detail.docRef = OffChainDidDocRef.custom(u8aToHex(resp.docRef.asCustom));
    } else {
      throw new Error(`Cannot parse DIDDoc ref ${resp.docRef}`);
    }
    return detail;
  }

  /**
   * Gets the current nonce for the DID. It will throw error if the DID does not exist on
   * chain or chain returns null response.
   * @param {string} didIdentifier - DID identifier as hex. Not accepting full DID intentionally for efficiency as these
   * methods are used internally
   * @return {Promise&lt;number>}
   */
  async getNonceForDID(didIdentifier) {
    return (await this.getOnchainDidDetail(didIdentifier)).nonce;
  }

  /**
   * Gets the nonce that should be used for sending the next transaction by this DID. Its 1 more than the current nonce.
   * @param didIdentifier
   * @returns {Promise&lt;*>}
   */
  async getNextNonceForDID(didIdentifier) {
    return (await this.getNonceForDID(didIdentifier)) + 1;
  }

  /**
   * Get the `DidKey` for the DID with given key index. Key indices start from 1 and can have holes
   * @param did
   * @param {number} keyIndex
   * @returns {Promise&lt;DidKey>}
   */
  async getDidKey(did, keyIndex) {
    const hexId = getHexIdentifierFromDID(did);
    let resp = await this.api.query.didModule.didKeys(hexId, keyIndex);
    if (resp.isNone) {
      throw new Error(`No key for found did ${did} and key index ${keyIndex}`);
    }
    resp = resp.unwrap();

    const pk = resp.publicKey;

    let publicKey;
    if (pk.isSr25519) {
      publicKey = new PublicKeySr25519(u8aToHex(valuePropOrIdentity(pk.asSr25519)));
    } else if (pk.isEd25519) {
      publicKey = new PublicKeyEd25519(u8aToHex(valuePropOrIdentity(pk.asEd25519)));
    } else if (pk.isSecp256k1) {
      publicKey = new PublicKeySecp256k1(u8aToHex(valuePropOrIdentity(pk.asSecp256k1)));
    } else if (pk.isX25519) {
      publicKey = new PublicKeyX25519(u8aToHex(valuePropOrIdentity(pk.asX25519)));
    } else {
      throw new Error(`Cannot parse public key ${pk}`);
    }
    return new DidKey(
      publicKey,
      new VerificationRelationship(resp.verRels.toNumber()),
    );
  }

  /**
   * Returns true if DID `controller` is a controller of DID `controlled`, false otherwise
   * @param controlled
   * @param controller
   * @returns {Promise&lt;boolean>}
   */
  async isController(controlled, controller) {
    const controlledHexId = getHexIdentifierFromDID(controlled);
    const controllerHexId = getHexIdentifierFromDID(controller);
    const resp = await this.api.query.didModule.didControllers(
      controlledHexId,
      controllerHexId,
    );
    return resp.isSome;
  }

  /**
   * Returns the service endpoint of the DID and known by `endpointId`
   * @param did
   * @param endpointId
   * @returns {Promise}
   */
  async getServiceEndpoint(did, endpointId) {
    const hexId = getHexIdentifierFromDID(did);
    let resp = await this.api.query.didModule.didServiceEndpoints(
      hexId,
      endpointId,
    );
    if (resp.isNone) {
      throw new Error(
        `No service endpoint found for did ${did} and with id ${endpointId}`,
      );
    }
    resp = resp.unwrap();
    return {
      type: new ServiceEndpointType(resp.types.toNumber()),
      origins: resp.origins.map((origin) => u8aToHex(origin)),
    };
  }

  async createSignedAddKeys(
    didKeys,
    hexDid,
    controllerHexDid,
    keyPair,
    keyId,
    nonce = undefined,
  ) {
    if (nonce === undefined) {
      // eslint-disable-next-line no-param-reassign
      nonce = await this.getNextNonceForDID(controllerHexDid);
    }

    const keys = didKeys.map((d) => d.toJSON());
    const addKeys = { did: hexDid, keys, nonce };
    const serializedAddKeys = this.getSerializedAddKeys(addKeys);
    const signature = getSignatureFromKeyringPair(keyPair, serializedAddKeys);
    const didSig = createDidSig(controllerHexDid, keyId, signature);
    return [addKeys, didSig];
  }

  async createSignedAddControllers(
    controllers,
    hexDid,
    controllerHexDid,
    keyPair,
    keyId,
    nonce = undefined,
  ) {
    if (nonce === undefined) {
      // eslint-disable-next-line no-param-reassign
      nonce = await this.getNextNonceForDID(controllerHexDid);
    }

    const cnts = new BTreeSet();
    controllers.forEach((c) => {
      cnts.add(getHexIdentifierFromDID(c));
    });
    const addControllers = { did: hexDid, controllers: cnts, nonce };
    const serializedAddControllers = this.getSerializedAddControllers(addControllers);
    const signature = getSignatureFromKeyringPair(
      keyPair,
      serializedAddControllers,
    );
    const didSig = createDidSig(controllerHexDid, keyId, signature);
    return [addControllers, didSig];
  }

  async createSignedAddServiceEndpoint(
    endpointId,
    endpointType,
    origins,
    hexDid,
    controllerHexDid,
    keyPair,
    keyId,
    nonce = undefined,
  ) {
    if (nonce === undefined) {
      // eslint-disable-next-line no-param-reassign
      nonce = await this.getNextNonceForDID(controllerHexDid);
    }

    const endpoint = { types: endpointType.value, origins };
    const addServiceEndpoint = {
      did: hexDid,
      id: endpointId,
      endpoint,
      nonce,
    };
    const serializedServiceEndpoint = this.getSerializedAddServiceEndpoint(addServiceEndpoint);
    const signature = getSignatureFromKeyringPair(
      keyPair,
      serializedServiceEndpoint,
    );
    const didSig = createDidSig(controllerHexDid, keyId, signature);
    return [addServiceEndpoint, didSig];
  }

  async createSignedRemoveKeys(
    keyIds,
    did,
    controllerDid,
    keyPair,
    keyId,
    nonce = undefined,
  ) {
    const hexDid = getHexIdentifierFromDID(did);
    const controllerHexDid = getHexIdentifierFromDID(controllerDid);

    if (nonce === undefined) {
      // eslint-disable-next-line no-param-reassign
      nonce = await this.getNextNonceForDID(controllerHexDid);
    }

    const keys = new BTreeSet();
    keyIds.forEach((k) => {
      keys.add(k);
    });
    const removeKeys = { did: hexDid, keys, nonce };
    const serializedRemoveKeys = this.getSerializedRemoveKeys(removeKeys);
    const signature = getSignatureFromKeyringPair(
      keyPair,
      serializedRemoveKeys,
    );
    const didSig = createDidSig(controllerHexDid, keyId, signature);
    return [removeKeys, didSig];
  }

  async createSignedRemoveControllers(
    controllers,
    did,
    controllerDid,
    keyPair,
    keyId,
    nonce = undefined,
  ) {
    const hexDid = getHexIdentifierFromDID(did);
    const controllerHexDid = getHexIdentifierFromDID(controllerDid);

    if (nonce === undefined) {
      // eslint-disable-next-line no-param-reassign
      nonce = await this.getNextNonceForDID(controllerHexDid);
    }

    const cnts = new BTreeSet();
    controllers.forEach((c) => {
      cnts.add(getHexIdentifierFromDID(c));
    });

    const removeControllers = { did: hexDid, controllers: cnts, nonce };
    const serializedRemoveControllers = this.getSerializedRemoveControllers(removeControllers);
    const signature = getSignatureFromKeyringPair(
      keyPair,
      serializedRemoveControllers,
    );
    const didSig = createDidSig(controllerHexDid, keyId, signature);
    return [removeControllers, didSig];
  }

  async createSignedRemoveServiceEndpoint(
    endpointId,
    hexDid,
    controllerHexDid,
    keyPair,
    keyId,
    nonce = undefined,
  ) {
    if (nonce === undefined) {
      // eslint-disable-next-line no-param-reassign
      nonce = await this.getNextNonceForDID(controllerHexDid);
    }

    const removeServiceEndpoint = { did: hexDid, id: endpointId, nonce };
    const serializedRemoveServiceEndpoint = this.getSerializedRemoveServiceEndpoint(removeServiceEndpoint);
    const signature = getSignatureFromKeyringPair(
      keyPair,
      serializedRemoveServiceEndpoint,
    );
    const didSig = createDidSig(controllerHexDid, keyId, signature);
    return [removeServiceEndpoint, didSig];
  }

  async createSignedDidRemoval(
    hexDid,
    controllerHexDid,
    keyPair,
    keyId,
    nonce = undefined,
  ) {
    if (nonce === undefined) {
      // eslint-disable-next-line no-param-reassign
      nonce = await this.getNextNonceForDID(controllerHexDid);
    }

    const removal = { did: hexDid, nonce };
    const serializedRemoval = this.getSerializedDidRemoval(removal);
    const signature = getSignatureFromKeyringPair(keyPair, serializedRemoval);
    const didSig = createDidSig(controllerHexDid, keyId, signature);
    return [removal, didSig];
  }

  async createSignedAttestation(
    priority,
    iri,
    hexDid,
    keyPair,
    keyId,
    nonce = undefined,
  ) {
    if (nonce === undefined) {
      // eslint-disable-next-line no-param-reassign
      nonce = await this.getNextNonceForDID(hexDid);
    }
    const setAttestation = {
      attest: {
        priority,
        iri,
      },
      nonce,
    };
    const serializedAttestation = this.getSerializedAttestation(setAttestation);
    const signature = getSignatureFromKeyringPair(
      keyPair,
      serializedAttestation,
    );
    const didSig = createDidSig(hexDid, keyId, signature);
    return [setAttestation, didSig];
  }

  /**
   * Serializes a `AddKeys` for signing.
   * @param {object} addKeys - `AddKeys` as expected by the Substrate node
   * @returns {Array} An array of Uint8
   */
  getSerializedAddKeys(addKeys) {
    return getStateChange(this.api, 'AddKeys', addKeys);
  }

  getSerializedAddControllers(addControllers) {
    return getStateChange(this.api, 'AddControllers', addControllers);
  }

  getSerializedAddServiceEndpoint(addServiceEndpoint) {
    return getStateChange(this.api, 'AddServiceEndpoint', addServiceEndpoint);
  }

  getSerializedRemoveKeys(removeKeys) {
    return getStateChange(this.api, 'RemoveKeys', removeKeys);
  }

  getSerializedRemoveControllers(removeControllers) {
    return getStateChange(this.api, 'RemoveControllers', removeControllers);
  }

  getSerializedRemoveServiceEndpoint(removeServiceEndpoint) {
    return getStateChange(
      this.api,
      'RemoveServiceEndpoint',
      removeServiceEndpoint,
    );
  }

  /**
   * Serializes a `DidRemoval` for signing.
   * @param {object} didRemoval - `DidRemoval` as expected by the Substrate node
   * @returns {Array} An array of Uint8
   */
  getSerializedDidRemoval(didRemoval) {
    return getStateChange(this.api, 'DidRemoval', didRemoval);
  }

  /**
   * Serializes an `Attestation` for signing.
   * @param {object} setAttestation - `SetAttestationClaim` as expected by the Substrate node
   * @returns {Array} An array of Uint8
   */
  getSerializedAttestation(setAttestation) {
    return getStateChange(this.api, 'SetAttestationClaim', setAttestation);
  }
}

export default DIDModule;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BlobModule.html">BlobModule</a></li><li><a href="DIDModule.html">DIDModule</a></li><li><a href="DockBlobResolver.html">DockBlobResolver</a></li><li><a href="DockDIDResolver.html">DockDIDResolver</a></li><li><a href="DockRevRegResolver.html">DockRevRegResolver</a></li><li><a href="DockStatusListResolver.html">DockStatusListResolver</a></li><li><a href="module.html#.exports">exports</a></li><li><a href="module.exports_module.exports.html">exports</a></li><li><a href="NoDIDError.html">NoDIDError</a></li><li><a href="NoOffchainDIDError.html">NoOffchainDIDError</a></li><li><a href="NoOnchainDIDError.html">NoOnchainDIDError</a></li><li><a href="Resolver.html">Resolver</a></li><li><a href="RevocationModule.html">RevocationModule</a></li><li><a href="setApi.html">setApi</a></li><li><a href="TokenMigration.html">TokenMigration</a></li><li><a href="VerifiableCredential.html">VerifiableCredential</a></li><li><a href="global.html#VerifiablePresentation">VerifiablePresentation</a></li></ul><h3>Global</h3><ul><li><a href="global.html#acceptCompositeClaims">acceptCompositeClaims</a></li><li><a href="global.html#accumulator">accumulator</a></li><li><a href="global.html#adaptKey">adaptKey</a></li><li><a href="global.html#addAttributeToReveal">addAttributeToReveal</a></li><li><a href="global.html#addCredentialToPresent">addCredentialToPresent</a></li><li><a href="global.html#addOwner">addOwner</a></li><li><a href="global.html#addParams">addParams</a></li><li><a href="global.html#addPositiveAccumulator">addPositiveAccumulator</a></li><li><a href="global.html#addPublicKey">addPublicKey</a></li><li><a href="global.html#addUniversalAccumulator">addUniversalAccumulator</a></li><li><a href="global.html#anchor">anchor</a></li><li><a href="global.html#asDockAddress">asDockAddress</a></li><li><a href="global.html#batchDocumentsInMerkleTree">batchDocumentsInMerkleTree</a></li><li><a href="global.html#bbs">bbs</a></li><li><a href="global.html#bbsPlus">bbsPlus</a></li><li><a href="global.html#blob">blob</a></li><li><a href="global.html#blobHexIdToQualified">blobHexIdToQualified</a></li><li><a href="global.html#buildCreateStatusListCredentialTx">buildCreateStatusListCredentialTx</a></li><li><a href="global.html#buildDockCredentialStatus">buildDockCredentialStatus</a></li><li><a href="global.html#buildRemoveStatusListCredentialTx">buildRemoveStatusListCredentialTx</a></li><li><a href="global.html#buildResolversMap">buildResolversMap</a></li><li><a href="global.html#buildUpdateStatusListCredentialTx">buildUpdateStatusListCredentialTx</a></li><li><a href="global.html#bytesToWrappedBytes">bytesToWrappedBytes</a></li><li><a href="global.html#cacheLast">cacheLast</a></li><li><a href="global.html#checkCredential">checkCredential</a></li><li><a href="global.html#checkCredentialJSONLD">checkCredentialJSONLD</a></li><li><a href="global.html#checkCredentialOptional">checkCredentialOptional</a></li><li><a href="global.html#checkCredentialRequired">checkCredentialRequired</a></li><li><a href="global.html#checkRevocationRegistryStatus">checkRevocationRegistryStatus</a></li><li><a href="global.html#claimgraphToStore">claimgraphToStore</a></li><li><a href="global.html#controllerIds">controllerIds</a></li><li><a href="global.html#convertToPresentation">convertToPresentation</a></li><li><a href="global.html#create">create</a></li><li><a href="global.html#createAddParamsTx">createAddParamsTx</a></li><li><a href="global.html#createAddPositiveAccumulatorTx">createAddPositiveAccumulatorTx</a></li><li><a href="global.html#createAddPublicKeyTx">createAddPublicKeyTx</a></li><li><a href="global.html#createAddUniversalAccumulatorTx">createAddUniversalAccumulatorTx</a></li><li><a href="global.html#createDidKey">createDidKey</a></li><li><a href="global.html#createDidSig">createDidSig</a></li><li><a href="global.html#createDidSignature">createDidSignature</a></li><li><a href="global.html#createNewDockBlobId">createNewDockBlobId</a></li><li><a href="global.html#createNewDockDID">createNewDockDID</a></li><li><a href="global.html#createParamsObjFromChainResponse">createParamsObjFromChainResponse</a></li><li><a href="global.html#createPresentation">createPresentation</a></li><li><a href="global.html#createPublicKeyObjFromChainResponse">createPublicKeyObjFromChainResponse</a></li><li><a href="global.html#createRandomRegistryId">createRandomRegistryId</a></li><li><a href="global.html#createRemovePublicKeyTx">createRemovePublicKeyTx</a></li><li><a href="global.html#createResolver">createResolver</a></li><li><a href="global.html#createSignedRemoveStatusListCredential">createSignedRemoveStatusListCredential</a></li><li><a href="global.html#createSignedUpdateStatusListCredential">createSignedUpdateStatusListCredential</a></li><li><a href="global.html#createStatusListCredential">createStatusListCredential</a></li><li><a href="global.html#createVerifyData">createVerifyData</a></li><li><a href="global.html#credsToEEClaimGraph">credsToEEClaimGraph</a></li><li><a href="global.html#credToEECG">credToEECG</a></li><li><a href="global.html#deploy">deploy</a></li><li><a href="global.html#deployTx">deployTx</a></li><li><a href="global.html#dereferenceFromIPFS">dereferenceFromIPFS</a></li><li><a href="global.html#did">did</a></li><li><a href="global.html#documentLoader">documentLoader</a></li><li><a href="global.html#encodeExtrinsicAsHash">encodeExtrinsicAsHash</a></li><li><a href="global.html#ensureArray">ensureArray</a></li><li><a href="global.html#ensureItemsAllowed">ensureItemsAllowed</a></li><li><a href="global.html#ensureObject">ensureObject</a></li><li><a href="global.html#ensureObjectWithId">ensureObjectWithId</a></li><li><a href="global.html#ensureObjectWithKey">ensureObjectWithKey</a></li><li><a href="global.html#ensureStatusListId">ensureStatusListId</a></li><li><a href="global.html#ensureString">ensureString</a></li><li><a href="global.html#ensureURI">ensureURI</a></li><li><a href="global.html#ensureValidDatetime">ensureValidDatetime</a></li><li><a href="global.html#expandJSONLD">expandJSONLD</a></li><li><a href="global.html#extractProof">extractProof</a></li><li><a href="global.html#fetchStatusList2021Credential">fetchStatusList2021Credential</a></li><li><a href="global.html#fmtIter">fmtIter</a></li><li><a href="global.html#from">from</a></li><li><a href="global.html#fromBytes">fromBytes</a></li><li><a href="global.html#fromHex">fromHex</a></li><li><a href="global.html#fromJsigProofValue">fromJsigProofValue</a></li><li><a href="global.html#fromJSON">fromJSON</a></li><li><a href="global.html#fromKeyringPair">fromKeyringPair</a></li><li><a href="global.html#fromPolkadotJSKeyringPair">fromPolkadotJSKeyringPair</a></li><li><a href="global.html#generate">generate</a></li><li><a href="global.html#generateEcdsaSecp256k1Keypair">generateEcdsaSecp256k1Keypair</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getAccount">getAccount</a></li><li><a href="global.html#getAccumulator">getAccumulator</a></li><li><a href="global.html#getAllEventsFromBlock">getAllEventsFromBlock</a></li><li><a href="global.html#getAllExtrinsicsFromBlock">getAllExtrinsicsFromBlock</a></li><li><a href="global.html#getAllParamsByDid">getAllParamsByDid</a></li><li><a href="global.html#getAllPublicKeysByDid">getAllPublicKeysByDid</a></li><li><a href="global.html#getAndValidateSchemaIfPresent">getAndValidateSchemaIfPresent</a></li><li><a href="global.html#getBytesForStateChange">getBytesForStateChange</a></li><li><a href="global.html#getCredentialStatus">getCredentialStatus</a></li><li><a href="global.html#getDockRevIdFromCredential">getDockRevIdFromCredential</a></li><li><a href="global.html#getHexIdentifier">getHexIdentifier</a></li><li><a href="global.html#getHexIdentifierFromBlobID">getHexIdentifierFromBlobID</a></li><li><a href="global.html#getHexIdentifierFromDID">getHexIdentifierFromDID</a></li><li><a href="global.html#getImplications">getImplications</a></li><li><a href="global.html#getJSONSchemaSpec">getJSONSchemaSpec</a></li><li><a href="global.html#getKeyDoc">getKeyDoc</a></li><li><a href="global.html#getKeyPairType">getKeyPairType</a></li><li><a href="global.html#getLastParamsWritten">getLastParamsWritten</a></li><li><a href="global.html#getNonce">getNonce</a></li><li><a href="global.html#getPublicKey">getPublicKey</a></li><li><a href="global.html#getPublicKeyFromKeyringPair">getPublicKeyFromKeyringPair</a></li><li><a href="global.html#getSerializedRemoveStatusListCredential">getSerializedRemoveStatusListCredential</a></li><li><a href="global.html#getSerializedUpdateStatusListCredential">getSerializedUpdateStatusListCredential</a></li><li><a href="global.html#getSignatureFromKeyringPair">getSignatureFromKeyringPair</a></li><li><a href="global.html#getSuiteFromKeyDoc">getSuiteFromKeyDoc</a></li><li><a href="global.html#getTransferExtrinsicsFromBlock">getTransferExtrinsicsFromBlock</a></li><li><a href="global.html#getUniqueElementsFromArray">getUniqueElementsFromArray</a></li><li><a href="global.html#getUpdatesFromBlock">getUpdatesFromBlock</a></li><li><a href="global.html#getVerificationMethod">getVerificationMethod</a></li><li><a href="global.html#hash">hash</a></li><li><a href="global.html#hasRegistryRevocationStatus">hasRegistryRevocationStatus</a></li><li><a href="global.html#HEX_ID_REG_EXP_PATTERN">HEX_ID_REG_EXP_PATTERN</a></li><li><a href="global.html#hexDIDToQualified">hexDIDToQualified</a></li><li><a href="global.html#isConnected">isConnected</a></li><li><a href="global.html#isHexWithGivenByteSize">isHexWithGivenByteSize</a></li><li><a href="global.html#isObject">isObject</a></li><li><a href="global.html#isRegistryRevocationStatus">isRegistryRevocationStatus</a></li><li><a href="global.html#isString">isString</a></li><li><a href="global.html#issueCredential">issueCredential</a></li><li><a href="global.html#isVerifiedCredential">isVerifiedCredential</a></li><li><a href="global.html#isVerifiedPresentation">isVerifiedPresentation</a></li><li><a href="global.html#matchingResolver">matchingResolver</a></li><li><a href="global.html#METHOD_REG_EXP_PATTERN">METHOD_REG_EXP_PATTERN</a></li><li><a href="global.html#normalizeToHex">normalizeToHex</a></li><li><a href="global.html#offchainSignatures">offchainSignatures</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#parseDid">parseDid</a></li><li><a href="global.html#parseEventAsAccumulatorUpdate">parseEventAsAccumulatorUpdate</a></li><li><a href="global.html#parseRDFDocument">parseRDFDocument</a></li><li><a href="global.html#parseRef">parseRef</a></li><li><a href="global.html#prepareAddParameters">prepareAddParameters</a></li><li><a href="global.html#prepareAddPublicKey">prepareAddPublicKey</a></li><li><a href="global.html#presentationToEEClaimGraph">presentationToEEClaimGraph</a></li><li><a href="global.html#proveCompositeClaims">proveCompositeClaims</a></li><li><a href="global.html#ps">ps</a></li><li><a href="global.html#queryNextLookup">queryNextLookup</a></li><li><a href="global.html#removeAccumulator">removeAccumulator</a></li><li><a href="global.html#removeAccumulatorTx">removeAccumulatorTx</a></li><li><a href="global.html#removeParams">removeParams</a></li><li><a href="global.html#removeParamsTx">removeParamsTx</a></li><li><a href="global.html#removePublicKey">removePublicKey</a></li><li><a href="global.html#removeStatusListCredential">removeStatusListCredential</a></li><li><a href="global.html#removeStatusListCredentialWithOneOfPolicy">removeStatusListCredentialWithOneOfPolicy</a></li><li><a href="global.html#resolve">resolve</a></li><li><a href="global.html#revocation">revocation</a></li><li><a href="global.html#revoked">revoked</a></li><li><a href="global.html#revokedBatch">revokedBatch</a></li><li><a href="global.html#send">send</a></li><li><a href="global.html#setAccount">setAccount</a></li><li><a href="global.html#setJSONSchema">setJSONSchema</a></li><li><a href="global.html#sign">sign</a></li><li><a href="global.html#signAddParams">signAddParams</a></li><li><a href="global.html#signAddPublicKey">signAddPublicKey</a></li><li><a href="global.html#signAndSend">signAndSend</a></li><li><a href="global.html#signer">signer</a></li><li><a href="global.html#signerFactory">signerFactory</a></li><li><a href="global.html#signExtrinsic">signExtrinsic</a></li><li><a href="global.html#signPrehashed">signPrehashed</a></li><li><a href="global.html#signPresentation">signPresentation</a></li><li><a href="global.html#signRemoveParams">signRemoveParams</a></li><li><a href="global.html#signRemovePublicKey">signRemovePublicKey</a></li><li><a href="global.html#statusListCredential">statusListCredential</a></li><li><a href="global.html#supports">supports</a></li><li><a href="global.html#toBlob">toBlob</a></li><li><a href="global.html#toBytes">toBytes</a></li><li><a href="global.html#toJSON">toJSON</a></li><li><a href="global.html#toJsonldjsNode">toJsonldjsNode</a></li><li><a href="global.html#toSubstrate">toSubstrate</a></li><li><a href="global.html#transferDock">transferDock</a></li><li><a href="global.html#transferMicroDock">transferMicroDock</a></li><li><a href="global.html#update">update</a></li><li><a href="global.html#updateAccumulator">updateAccumulator</a></li><li><a href="global.html#updateAccumulatorTx">updateAccumulatorTx</a></li><li><a href="global.html#updateStatusList">updateStatusList</a></li><li><a href="global.html#updateStatusListCredential">updateStatusListCredential</a></li><li><a href="global.html#updateStatusListCredentialWithOneOfPolicy">updateStatusListCredentialWithOneOfPolicy</a></li><li><a href="global.html#validate">validate</a></li><li><a href="global.html#validateAddress">validateAddress</a></li><li><a href="global.html#validateBlobIDHexIdentifier">validateBlobIDHexIdentifier</a></li><li><a href="global.html#validateByteSize">validateByteSize</a></li><li><a href="global.html#validateCredentialSchema">validateCredentialSchema</a></li><li><a href="global.html#validateDockDIDHexIdentifier">validateDockDIDHexIdentifier</a></li><li><a href="global.html#validateDockDIDSS58Identifier">validateDockDIDSS58Identifier</a></li><li><a href="global.html#validateSchema">validateSchema</a></li><li><a href="global.html#verifier">verifier</a></li><li><a href="global.html#verifierFactory">verifierFactory</a></li><li><a href="global.html#verifyCredential">verifyCredential</a></li><li><a href="global.html#verifyEcdsaSecp256k1Sig">verifyEcdsaSecp256k1Sig</a></li><li><a href="global.html#verifyEcdsaSecp256k1SigPrehashed">verifyEcdsaSecp256k1SigPrehashed</a></li><li><a href="global.html#verifyID">verifyID</a></li><li><a href="global.html#verifyMerkleProofOfDocument">verifyMerkleProofOfDocument</a></li><li><a href="global.html#verifyMerkleProofOfLeaf">verifyMerkleProofOfLeaf</a></li><li><a href="global.html#verifyPresentation">verifyPresentation</a></li><li><a href="global.html#verifySignature">verifySignature</a></li><li><a href="global.html#WILDCARD">WILDCARD</a></li><li><a href="global.html#withExtendedStaticProperties">withExtendedStaticProperties</a></li><li><a href="global.html#withInitializedDockAPI">withInitializedDockAPI</a></li><li><a href="global.html#writeToChain">writeToChain</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Thu Oct 12 2023 19:16:23 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
