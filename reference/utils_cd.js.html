<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/cd.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/cd.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Claim deduction from verifiable presentations.

import deepEqual from 'deep-equal';
import jsonld from 'jsonld';
import { validate, prove, infer } from 'rify';
import { assert } from '@polkadot/util';
import { expandedCredentialProperty } from './vc/constants';
import { fromJsonldjsCg, merge } from './claimgraph';
import {
  canonRules, canonProof, canonClaimGraph, decanonClaimGraph, decanonProof,
} from './canonicalize';
import { assertValidNode, assertType } from './common';

export const expandedLogicProperty = 'https://www.dock.io/rdf2020#logicV1';
export const expandedProofProperty = 'https://w3id.org/security#proof';
export const expandedIssuerProperty = 'https://www.w3.org/2018/credentials#issuer';

/**
 * Returns a list of all RDF statements proven by the presentation. DOES NOT VERIFY THE
 * PRESENTATION. Verification must be performed for the results of this function to be trustworthy.
 * The return value may contaim duplicate claims.
 *
 * This function throws an error if:
 * a provided proof is not applicable given the ruleset,
 * a provided proof makes unverified assumptions,
 * a provided proof is malformed.
 *
 * @param expandedPresentation - a VCDM presentation as expanded json-ld
 * @param rules - ordered list of axioms which will be accepted within proofs of composite claims
 * @returns {Promise&lt;Object[]>}
 */
export async function acceptCompositeClaims(expandedPresentation, rules) {
  assert(
    rules !== undefined,
    'An axiom list must be provided. Hint: rules may be "[]" to reject all.',
  );

  const cg = await presentationToEEClaimGraph(expandedPresentation);
  const proof = extractProof(expandedPresentation);
  const implied = getImplications(cg, proof, rules);

  // return (claimgraph U implied)
  return [...cg, ...implied];
}

/**
 * Convert a list of expanded credentials which have already been verified into an RDF claim graph.
 * The resulting claimgraph is in Explicit Ethos form.
 *
 * @param expandedCredentials - A list of expanded credentials, each is expected to be a separate
 *                              @graph.
 * @returns {Promise&lt;Object[]>}
 */
async function credsToEEClaimGraph(expandedCredentials) {
  const ees = await Promise.all(expandedCredentials.map(credToEECG));
  return merge(ees);
}

/**
 * Convert a single expanded credential which has already been verified into an RDF claim graph.
 *
 * @returns {Promise&lt;Object[]>}
 */
async function credToEECG(expandedCredential) {
  assert(
    expandedCredential['@graph'] !== undefined,
    'Expected each credential to expand to its own @graph',
  );
  const cred = { ...unwrapE(expandedCredential['@graph']) };

  // This line relies on the assumption that if the credential passed verification then the
  // issuer property was not forged.
  assert(cred[expandedIssuerProperty] !== undefined, 'encountered credential without an issuer');
  const issuer = cred[expandedIssuerProperty][0]['@id'];
  assertType(issuer, 'string');
  assert(!issuer.startsWith('_:'), 'issuer is assumed not to be a blank node');

  // remove the proof
  delete cred[expandedProofProperty];

  // convert to claimgraph
  const cg = fromJsonldjsCg(await jsonld.toRDF(cred));

  for (const claim of cg) {
    // Credentials containing a "@graph" declaration will cause an assertion error here.
    // And rightfully so. Here's why:
    // Each statement in a cred is passed to the reasoner as a quad with `issuer` as the graph.
    // It would be potentially incorrect to overwrite a non-default graph.
    // Leaving a non-default graph as-is would be unsafe.
    // While it would be valid to simply delete quads with non-default graphs, it would be confusing
    // to users if the content of their credential was swallowed without warning.
    assert(deepEqual(claim[3], { DefaultGraph: true }), 'subgraph found in credential');
    claim[3] = { Iri: issuer };
  }

  return cg;
}

/**
 * Returns a list of all RDF statements in the presentation. DOES NOT VERIFY THE
 * PRESENTATION. Verification must be performed for the results of this function to be trustworthy.
 *
 * @param expandedPresentation - a VCDM presentation as expanded json-ld
 * @returns {Promise&lt;Object[]>}
 */
export async function presentationToEEClaimGraph(expandedPresentation) {
  const ep = unwrapE(expandedPresentation);

  // get ordered list of all credentials
  const creds = jsonld.getValues(ep, expandedCredentialProperty);

  // convert them to a single claimgraph
  return await credsToEEClaimGraph(creds);
}

export class UnverifiedAssumption extends Error {
  constructor(unverifiedAssumption) {
    super('Proof relies on assumption that are not in the input.');
    this.unverifiedAssumption = unverifiedAssumption;
  }
}

/**
 * Extracts any included proofs of composite claims from a presentation.
 * The presentation must be in expanded form.
 * Returns the proofs, concatenated together.
 *
 * @param expandedPresentation - a VCDM presentation as expanded json-ld
 * @returns {Promise&lt;Object[]>}
 */
export function extractProof(expandedPresentation) {
  return jsonld.getValues(unwrapE(expandedPresentation), expandedLogicProperty)
    .map(fromJSONLiteral)
    .flat(1);
}

/**
 * Given a claimgraph of true assumptions, and the allowed logical rules, return the claims that are
 * proven true by proof. If the proof is not applicable given the ruleset, or makes unverified
 * assumptions, throw an error. The return value may contain duplicate claims.
 *
 * @param claimgraph - known true assumptions (usually extracted from a presentation or a cred)
 * @param proof - proof of composite claims (usually comes from calling proveh())
 * @param rules - ordered list of axioms
 * @returns {Object[]}
 */
export function getImplications(claimgraph, proof, rules) {
  const valid = validateh(rules, proof);

  // Check that all assumptions made by the proof were provided in the claimgraph of assumptions
  for (const assumption of valid.assumed) {
    if (!claimgraph.some((claim) => claimEq(claim, assumption))) {
      throw new UnverifiedAssumption([...assumption]);
    }
  }

  return valid.implied;
}

/**
 * Given the assumptions encoded in the provided presentation, prove a list of composite claims.
 * T return proof of composite claims as a jsonld json literal which can be attached directly to a
 * presentation as {expandedLogicProperty} before [signing and ]submitting.
 *
 * This function throws an error if the requested composite claims are unprovable.
 *
 * @param expandedPresentation - a VCDM presentation as expanded json-ld
 * @param compositeClaims - claims to prove, provide in claimgraph format
 * @param rules - ordered list of axioms which will be accepted within proofs of composite claims
 * @returns {Promise&lt;Object>} - proof is returned as a json literal
 */
export async function proveCompositeClaims(expandedPresentation, compositeClaims, rules) {
  assert(
    rules !== undefined,
    'An axiom list must be provided. Hint: rules may be "[]" to reject all.',
  );
  const cg = await presentationToEEClaimGraph(expandedPresentation);
  const prevProof = await extractProof(expandedPresentation);
  const newProof = proveh(cg, compositeClaims, rules);
  return toJsonLiteral(prevProof.concat(newProof));
}

// prove-high
// A higher level wrapper around prove that first converts rules, composite claims, and premises to
// the canonical representation as defined by `canon()` in `claimgraph.js`. This wrapper
// deserializes the returned values before passing them back to the caller.
export function proveh(
  premises,
  toProve,
  rules,
) {
  foreachQuadInRules(rules, assertQuad);
  premises.forEach(assertQuad);
  toProve.forEach(assertQuad);
  const proof = prove(
    canonClaimGraph(premises),
    canonClaimGraph(toProve),
    canonRules(rules),
  );
  return decanonProof(proof);
}

// validate-high
// A higher level wrapper around validate that first converts rules and proof to the canonical
// representation as defined by `canon()` in `claimgraph.js`. This wrapper deserializes the
// returned values before passing them back to the caller.
export function validateh(rules, proof) {
  foreachQuadInRules(rules, assertQuad);
  const {
    assumed,
    implied,
  } = validate(
    canonRules(rules),
    canonProof(proof),
  );
  return {
    assumed: decanonClaimGraph(assumed),
    implied: decanonClaimGraph(implied),
  };
}

// infer-high
// A higher level wrapper around infer that first converts premises and rules to the canonical
// representation as defined by `canon()` in `claimgraph.js`. This wrapper deserializes the
// returned values before passing them back to the caller.
export function inferh(premises, rules) {
  premises.forEach(assertQuad);
  foreachQuadInRules(rules, assertQuad);
  const inferred = infer(canonClaimGraph(premises), canonRules(rules));
  return decanonClaimGraph(inferred);
}

function foreachQuadInRules(rules, f) {
  for (const rule of rules) {
    for (const quad of rule.if_all) {
      f(quad);
    }
    for (const quad of rule.then) {
      f(quad);
    }
  }
}

function assertQuad(quad) {
  assert(quad.length === 4, () => `Quads must have length 4, got: ${JSON.stringify(quad)}`);
}

/// check two claims for equality
function claimEq(a, b) {
  for (const claim of [a, b]) {
    if (!(claim instanceof Array) || claim.length !== 4) {
      throw new TypeError();
    }
    for (const node of claim) {
      assertValidNode(node);
    }
  }
  return deepEqual(a, b);
}

// https://w3c.github.io/json-ld-syntax/#json-literals
function fromJSONLiteral(literal) {
  if (literal['@type'] !== '@json') {
    throw new TypeError(`not a json literal: ${literal}`);
  }
  if (literal['@value'] === undefined) {
    throw new TypeError(`json literal has no "@value": ${literal}`);
  }
  return literal['@value'];
}

// https://w3c.github.io/json-ld-syntax/#json-literals
function toJsonLiteral(json) {
  return {
    '@type': '@json',
    '@value': JSON.parse(JSON.stringify(json)),
  };
}

// Unwrap Expanded jsonld
//
// jsonld expansion by jsonld-js results in an array. This module operates on expanded jsonld so
// getting the first and only element from that expanded array is a common task.
//
// We assume that a root level expanded jsonld object will always be an array with exactly one
// element.
function unwrapE(expanded) {
  assert(
    Array.isArray(expanded) &amp;&amp; expanded.length === 1,
    'expected expanded jsonld as an array of one element',
  );
  return expanded[0];
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BlobModule.html">BlobModule</a></li><li><a href="DIDModule.html">DIDModule</a></li><li><a href="DockAPI.html">DockAPI</a></li><li><a href="module.html#.exports">exports</a></li><li><a href="module.exports_module.exports.html">exports</a></li><li><a href="NoDIDError.html">NoDIDError</a></li><li><a href="RevocationModule.html">RevocationModule</a></li><li><a href="setApi.html">setApi</a></li><li><a href="TokenMigration.html">TokenMigration</a></li><li><a href="VerifiableCredential.html">VerifiableCredential</a></li><li><a href="global.html#VerifiablePresentation">VerifiablePresentation</a></li></ul><h3>Global</h3><ul><li><a href="global.html#acceptCompositeClaims">acceptCompositeClaims</a></li><li><a href="global.html#addOwner">addOwner</a></li><li><a href="global.html#asDockAddress">asDockAddress</a></li><li><a href="global.html#batchDocumentsInMerkleTree">batchDocumentsInMerkleTree</a></li><li><a href="global.html#blobHexIdToQualified">blobHexIdToQualified</a></li><li><a href="global.html#buildDockCredentialStatus">buildDockCredentialStatus</a></li><li><a href="global.html#checkCredential">checkCredential</a></li><li><a href="global.html#checkCredentialJSONLD">checkCredentialJSONLD</a></li><li><a href="global.html#checkCredentialOptional">checkCredentialOptional</a></li><li><a href="global.html#checkCredentialRequired">checkCredentialRequired</a></li><li><a href="global.html#checkRevocationStatus">checkRevocationStatus</a></li><li><a href="global.html#claimgraphToStore">claimgraphToStore</a></li><li><a href="global.html#createDidAttestation">createDidAttestation</a></li><li><a href="global.html#createDidRemoval">createDidRemoval</a></li><li><a href="global.html#createKeyDetail">createKeyDetail</a></li><li><a href="global.html#createKeyUpdate">createKeyUpdate</a></li><li><a href="global.html#createNewDockBlobId">createNewDockBlobId</a></li><li><a href="global.html#createNewDockDID">createNewDockDID</a></li><li><a href="global.html#createRandomRegistryId">createRandomRegistryId</a></li><li><a href="global.html#createSignedAttestation">createSignedAttestation</a></li><li><a href="global.html#createSignedDidRemoval">createSignedDidRemoval</a></li><li><a href="global.html#createSignedKeyUpdate">createSignedKeyUpdate</a></li><li><a href="global.html#credsToEEClaimGraph">credsToEEClaimGraph</a></li><li><a href="global.html#credToEECG">credToEECG</a></li><li><a href="global.html#deploy">deploy</a></li><li><a href="global.html#deployTx">deployTx</a></li><li><a href="global.html#dereferenceFromIPFS">dereferenceFromIPFS</a></li><li><a href="global.html#documentLoader">documentLoader</a></li><li><a href="global.html#encodeExtrinsicAsHash">encodeExtrinsicAsHash</a></li><li><a href="global.html#ensureObject">ensureObject</a></li><li><a href="global.html#ensureObjectWithId">ensureObjectWithId</a></li><li><a href="global.html#ensureObjectWithKey">ensureObjectWithKey</a></li><li><a href="global.html#ensureString">ensureString</a></li><li><a href="global.html#ensureURI">ensureURI</a></li><li><a href="global.html#ensureValidDatetime">ensureValidDatetime</a></li><li><a href="global.html#expandJSONLD">expandJSONLD</a></li><li><a href="global.html#extractProof">extractProof</a></li><li><a href="global.html#from">from</a></li><li><a href="global.html#fromHex">fromHex</a></li><li><a href="global.html#fromKeyringPair">fromKeyringPair</a></li><li><a href="global.html#fromPolkadotJSKeyringPair">fromPolkadotJSKeyringPair</a></li><li><a href="global.html#generateEcdsaSecp256k1Keypair">generateEcdsaSecp256k1Keypair</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getAllEventsFromBlock">getAllEventsFromBlock</a></li><li><a href="global.html#getAllExtrinsicsFromBlock">getAllExtrinsicsFromBlock</a></li><li><a href="global.html#getAndValidateSchemaIfPresent">getAndValidateSchemaIfPresent</a></li><li><a href="global.html#getBytesForStateChange">getBytesForStateChange</a></li><li><a href="global.html#getCredentialStatuses">getCredentialStatuses</a></li><li><a href="global.html#getDockRevIdFromCredential">getDockRevIdFromCredential</a></li><li><a href="global.html#getHexIdentifier">getHexIdentifier</a></li><li><a href="global.html#getHexIdentifierFromBlobID">getHexIdentifierFromBlobID</a></li><li><a href="global.html#getHexIdentifierFromDID">getHexIdentifierFromDID</a></li><li><a href="global.html#getImplications">getImplications</a></li><li><a href="global.html#getJSONSchemaSpec">getJSONSchemaSpec</a></li><li><a href="global.html#getKeyPairType">getKeyPairType</a></li><li><a href="global.html#getPublicKeyFromKeyringPair">getPublicKeyFromKeyringPair</a></li><li><a href="global.html#getSignatureFromKeyringPair">getSignatureFromKeyringPair</a></li><li><a href="global.html#getSignatures">getSignatures</a></li><li><a href="global.html#getSuiteFromKeyDoc">getSuiteFromKeyDoc</a></li><li><a href="global.html#getTransferExtrinsicsFromBlock">getTransferExtrinsicsFromBlock</a></li><li><a href="global.html#getUniqueElementsFromArray">getUniqueElementsFromArray</a></li><li><a href="global.html#hasDockRevocation">hasDockRevocation</a></li><li><a href="global.html#hash">hash</a></li><li><a href="global.html#hexDIDToQualified">hexDIDToQualified</a></li><li><a href="global.html#isHexWithGivenByteSize">isHexWithGivenByteSize</a></li><li><a href="global.html#isObject">isObject</a></li><li><a href="global.html#isRevocationCheckNeeded">isRevocationCheckNeeded</a></li><li><a href="global.html#isString">isString</a></li><li><a href="global.html#issueCredential">issueCredential</a></li><li><a href="global.html#isVerifiedCredential">isVerifiedCredential</a></li><li><a href="global.html#isVerifiedPresentation">isVerifiedPresentation</a></li><li><a href="global.html#normalizeToHex">normalizeToHex</a></li><li><a href="global.html#parseRDFDocument">parseRDFDocument</a></li><li><a href="global.html#presentationToEEClaimGraph">presentationToEEClaimGraph</a></li><li><a href="global.html#proveCompositeClaims">proveCompositeClaims</a></li><li><a href="global.html#queryNextLookup">queryNextLookup</a></li><li><a href="global.html#resolve">resolve</a></li><li><a href="global.html#set">set</a></li><li><a href="global.html#setAuthor">setAuthor</a></li><li><a href="global.html#setJSONSchema">setJSONSchema</a></li><li><a href="global.html#setSignature">setSignature</a></li><li><a href="global.html#sign">sign</a></li><li><a href="global.html#signDidAttestation">signDidAttestation</a></li><li><a href="global.html#signDidRemoval">signDidRemoval</a></li><li><a href="global.html#signerFactory">signerFactory</a></li><li><a href="global.html#signKeyUpdate">signKeyUpdate</a></li><li><a href="global.html#signPresentation">signPresentation</a></li><li><a href="global.html#toBlob">toBlob</a></li><li><a href="global.html#toJSON">toJSON</a></li><li><a href="global.html#toJsonldjsNode">toJsonldjsNode</a></li><li><a href="global.html#toMap">toMap</a></li><li><a href="global.html#transferDock">transferDock</a></li><li><a href="global.html#transferMicroDock">transferMicroDock</a></li><li><a href="global.html#validate">validate</a></li><li><a href="global.html#validateBlobIDHexIdentifier">validateBlobIDHexIdentifier</a></li><li><a href="global.html#validateByteSize">validateByteSize</a></li><li><a href="global.html#validateCredentialSchema">validateCredentialSchema</a></li><li><a href="global.html#validateDockDIDHexIdentifier">validateDockDIDHexIdentifier</a></li><li><a href="global.html#validateDockDIDSS58Identifier">validateDockDIDSS58Identifier</a></li><li><a href="global.html#validateSchema">validateSchema</a></li><li><a href="global.html#verifier">verifier</a></li><li><a href="global.html#verifierFactory">verifierFactory</a></li><li><a href="global.html#verifyCredential">verifyCredential</a></li><li><a href="global.html#verifyEcdsaSecp256k1Sig">verifyEcdsaSecp256k1Sig</a></li><li><a href="global.html#verifyMerkleProofOfDocument">verifyMerkleProofOfDocument</a></li><li><a href="global.html#verifyMerkleProofOfLeaf">verifyMerkleProofOfLeaf</a></li><li><a href="global.html#verifyPresentation">verifyPresentation</a></li><li><a href="global.html#verifySignature">verifySignature</a></li><li><a href="global.html#writeToChain">writeToChain</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Tue Oct 19 2021 20:48:11 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
