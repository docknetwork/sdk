<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/vc/crypto/common/DockCryptoSignature.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/vc/crypto/common/DockCryptoSignature.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { initializeWasm, CredentialSchema, DefaultSchemaParsingOpts } from '@docknetwork/crypto-wasm-ts';

import jsonld from 'jsonld';
import { SECURITY_CONTEXT_URL } from 'jsonld-signatures';

import { u8aToU8a } from '@polkadot/util';
import stringify from 'json-stringify-deterministic';
import { withExtendedStaticProperties } from '../../../inheritance';
import CustomLinkedDataSignature from './CustomLinkedDataSignature';

const SUITE_CONTEXT_URL = 'https://www.w3.org/2018/credentials/v1';

export const DEFAULT_PARSING_OPTS = {
  useDefaults: false,
};

/**
 * Defines commons for the `@docknetwork/crypto-wasm-ts` signatures.
 */
export default withExtendedStaticProperties(
  ['KeyPair', 'CredentialBuilder', 'Credential', 'proofType'],
  class DockCryptoSignature extends CustomLinkedDataSignature {
    /**
     * Default constructor
     * @param options {SignatureSuiteOptions} options for constructing the signature suite
     * @param type
     * @param LDKeyClass
     * @param url
     */
    constructor(options = {}, type, LDKeyClass, url) {
      const {
        verificationMethod, signer, keypair, verifier,
      } = options;

      super({
        type,
        LDKeyClass,
        contextUrl: SUITE_CONTEXT_URL,
        alg: type,
        signer,
        verifier,
        useProofValue: true,
      });

      this.proof = {
        '@context': [
          {
            sec: 'https://w3id.org/security#',
            proof: {
              '@id': 'sec:proof',
              '@type': '@id',
              '@container': '@graph',
            },
          },
          url,
        ],
        type,
      };

      this.requireCredentialSchema = true;
      this.verificationMethod = verificationMethod;
      if (keypair) {
        if (verificationMethod === undefined) {
          this.verificationMethod = keypair.id;
        }
        this.key = keypair;
      }
    }

    /** Create serialized credential for signing and verification
     * @param {object} options - The options to use.
     * @param {object} options.document - The document to be signed/verified.
     * @param {object} options.proof - The proof to be verified.
     * @param {function} options.documentLoader - The document loader to use.
     * @param {function} options.expansionMap - NOT SUPPORTED; do not use.
     *
     * @returns {Promise&lt;Uint8Array[]>}.
     */
    async createVerifyData(options) {
      await initializeWasm();

      // If this function is being called for credential verification or not
      const forVerification = options.proof &amp;&amp; options.proof.proofValue;

      let serializedCredential;
      let credSchema;
      if (forVerification) {
        if (options.document.cryptoVersion) {
          // Newer credentials will have cryptoVersion field set
          [serializedCredential, credSchema] = this.constructor.convertCredentialForVerification(options);
        } else {
          // Legacy. Cannot use `convertCredentialForVerification` because JSON.stringify is not deterministic
          // and credentialSchema string becomes different. See https://stackoverflow.com/a/43049877
          [serializedCredential, credSchema] = this.constructor.convertCredential(options);
        }
      } else {
        // Serialize the data for signing
        [serializedCredential, credSchema] = await this.constructor.convertCredentialToSerializedForSigning(options);
      }

      // Encode messages, retrieve names/values array
      const nameValues = credSchema.encoder.encodeMessageObject(
        serializedCredential,
        false,
      );
      return nameValues[1];
    }

    /**
     * Convert given JSON-LD credential to TS-anoncred's credential. This would not have the signature.
     * @param document - JSON-LD credential
     * @param explicitProof
     * @param signingOptions
     * @returns {Array} - Returns [serialized cred object, cred schema]
     */
    static convertCredential({
      document,
      proof: explicitProof /* documentLoader */,
      signingOptions = { requireAllFieldsFromSchema: false },
    }) {
      const [trimmedProof] = this.getTrimmedProofAndValue(document, explicitProof);

      const [credSchema] = this.extractSchema(document);

      const credBuilder = new this.CredentialBuilder();
      // Set legacy version
      credBuilder.version = '0.2.0';
      credBuilder.schema = credSchema;

      // Extract top level fields from the document aside from these
      const {
        cryptoVersion: _cryptoVersion,
        credentialSchema: _credentialSchema,
        credentialSubject,
        credentialStatus,
        ...topLevelFields
      } = {
        ...document,
        proof: trimmedProof,
      };
      credBuilder.subject = credentialSubject;
      credBuilder.credStatus = credentialStatus;

      // Add all other top level fields to the credential
      Object.keys(topLevelFields)
        .sort()
        .forEach((k) => {
          credBuilder.setTopLevelField(k, topLevelFields[k]);
        });

      // To work with JSON-LD credentials/presentations, we must always reveal the context and type
      // NOTE: that they are encoded as JSON strings here to reduce message count and so its *always known*
      credBuilder.setTopLevelField(
        '@context',
        JSON.stringify(document['@context']),
      );
      credBuilder.setTopLevelField('type', JSON.stringify(document.type));

      // Allow for relaxed schema generation, then embed the generated schema directly into the credential
      const builtAnoncreds = credBuilder.updateSchemaIfNeeded(signingOptions);

      // Re-assign the embedded schema to the document schema object
      // this is a bit hacky, but its the only way right now
      if (document.credentialSchema) {
        const fullSchema = builtAnoncreds.credentialSchema;
        Object.assign(document.credentialSchema, typeof fullSchema === 'string' ? JSON.parse(fullSchema) : fullSchema);
      }

      // Return the built anoncreds credential and the schema associated
      return [builtAnoncreds, credBuilder.schema];
    }

    /**
     * Convert given JSON-LD credential to TS-anoncred's credential for adding to a presentation. This would have the signature.
     * @param document - JSON-LD credential
     * @param explicitProof
     * @returns {Credential}
     */
    static convertCredentialForPresBuilding({
      document,
      proof: explicitProof /* documentLoader */,
    }) {
      const [trimmedProof, proofVal] = this.getTrimmedProofAndValue(document, explicitProof);

      const [credSchema, wasLegacySchema] = this.extractSchema(document);

      const credJson = {
        ...document,
        proof: trimmedProof,
      };
      this.revealMandatoryFields(credJson, document);
      const cred = this.Credential.fromJSON(credJson, CustomLinkedDataSignature.fromJsigProofValue(proofVal));
      if (!wasLegacySchema) {
        cred.schema = CredentialSchema.generateAppropriateSchema(credJson, credSchema);
      }

      return cred;
    }

    /**
     * Convert given JSON-LD credential to TS-anoncred's credential. This would have the signature.
     * @param document - JSON-LD credential
     * @param explicitProof
     * @returns {Array}
     */
    static convertCredentialForVerification({
      document,
      proof: explicitProof /* documentLoader */,
    }) {
      const [trimmedProof] = this.getTrimmedProofAndValue(document, explicitProof);

      const s = this.extractSchema(document);
      let credSchema = s[0];
      const wasLegacySchema = s[1];

      const credJson = {
        ...document,
        proof: trimmedProof,
      };
      this.revealMandatoryFields(credJson, document);
      if (!wasLegacySchema) {
        // Older credentials didn't include the version field in the final credential but they did while signing
        credJson.cryptoVersion = '0.2.0';
        if (credJson.credentialSchema === undefined) {
          credJson.credentialSchema = JSON.stringify(credSchema.toJSON());
        }
        credSchema = CredentialSchema.generateAppropriateSchema(credJson, credSchema);
      }
      const schemaJson = credSchema.toJSON();
      // Older versions used JSON.stringify but newer use deterministic conversion
      credJson.credentialSchema = wasLegacySchema ? stringify(schemaJson) : JSON.stringify(schemaJson);

      if (document.credentialSchema) {
        Object.assign(document.credentialSchema, schemaJson);
      }

      return [credJson, credSchema];
    }

    /**
     * Convert given JSON-LD credential to TS-anoncred's credential. This would not have the signature.
     * @param document - JSON-LD credential
     * @param explicitProof
     * @returns {Promise&lt;Array>}
     */
    static async convertCredentialToSerializedForSigning({
      document,
      proof,
      documentLoader,
    }) {
      const [trimmedProof] = this.getTrimmedProofAndValue(document, proof);

      const [credSchema] = await this.extractSchemaForSigning(document, documentLoader);

      const credBuilder = new this.CredentialBuilder();
      credBuilder.schema = credSchema;

      // Extract top level fields from the document aside from these
      const {
        credentialSchema: _credentialSchema,
        credentialSubject,
        credentialStatus,
        ...topLevelFields
      } = {
        ...document,
        proof: trimmedProof,
      };
      credBuilder.subject = credentialSubject;
      credBuilder.credStatus = credentialStatus;

      // Add all other top level fields to the credential
      Object.keys(topLevelFields)
        .sort()
        .forEach((k) => {
          credBuilder.setTopLevelField(k, topLevelFields[k]);
        });

      // To work with JSON-LD credentials/presentations, we must always reveal the context and type
      // NOTE: that they are encoded as JSON strings here to reduce message count and so its *always known*
      credBuilder.setTopLevelField(
        '@context',
        JSON.stringify(document['@context']),
      );
      credBuilder.setTopLevelField('type', JSON.stringify(document.type));

      const serializedCred = credBuilder.serializeForSigning();

      credBuilder.schema = CredentialSchema.generateAppropriateSchema(serializedCred, credSchema);

      // Update `document` so that generated credential has `credentialSchema` and `cryptoVersion` set
      const updatedSchemaJson = credBuilder.schema.toJSON();
      serializedCred.credentialSchema = stringify(updatedSchemaJson);
      Object.assign(document.credentialSchema, updatedSchemaJson);
      // eslint-disable-next-line no-param-reassign
      document.cryptoVersion = serializedCred.cryptoVersion;

      return [serializedCred, credBuilder.schema];
    }

    /**
     * To work with JSON-LD credentials/presentations, we must always reveal the context, type
     * @param credJson
     * @param document
     */
    static revealMandatoryFields(credJson, document) {
      // NOTE: that they are encoded as JSON strings here to reduce message count and so its *always known*
      // eslint-disable-next-line no-param-reassign
      credJson['@context'] = JSON.stringify(document['@context']);
      // eslint-disable-next-line no-param-reassign
      credJson.type = JSON.stringify(document.type);
    }

    /**
     * Remove actual value of proof (signature) from the object and return the trimmed object and the proof value
     * @param document
     * @param explicitProof
     * @returns {Array}
     */
    static getTrimmedProofAndValue(document, explicitProof) {
      const proof = explicitProof || document.proof;
      if (proof.type !== this.proofType[0]) {
        throw new Error(
          `Invalid \`proof.type\`, expected ${this.proofType[0]}, received ${proof.type}`,
        );
      }
      // `jws`,`signatureValue`,`proofValue` must not be included in the proof
      const trimmedProof = {
        '@context': document['@context'] || SECURITY_CONTEXT_URL,
        ...proof,
      };

      const proofVal = trimmedProof.proofValue;

      delete trimmedProof.jws;
      delete trimmedProof.signatureValue;
      delete trimmedProof.proofValue;
      return [trimmedProof, proofVal];
    }

    /**
     * Extract schema from the document and load the schema from its id/reference if needed.
     * @param document
     * @param documentLoader
     * @returns {Promise&lt;Array>}
     */
    static async extractSchemaForSigning(document, documentLoader) {
      let credSchema;
      // Should be false for legacy cases or when the schema is generated by CredentialBuilder
      let wasExactSchema = true;

      if (document.credentialSchema &amp;&amp; document.credentialSchema.id) {
        /**
         * Fetch a schema given a schema id. Currenly only fetching it from Dock blockchain
         * @param schemaId
         * @returns {Promise&lt;Object>}
         */
        // eslint-disable-next-line no-inner-declarations
        async function getSchema(schemaId) {
          if (!schemaId.startsWith('blob:dock:')) {
            throw new Error(`Can only fetch schemas stored on Dock for now. Got schema id ${schemaId}`);
          }
          const { document: schema } = await documentLoader(schemaId);
          // schema[0] is the schema/blob id
          return schema[1];
        }

        // If we already have a schema to use, add that first and then generate relaxed values later on
        credSchema = await CredentialSchema.fromJSONWithPotentiallyExternalSchema({
          // Passing all the default parsing options. Ideally `document.credentialSchema` should contain these
          parsingOptions: DefaultSchemaParsingOpts,
          ...document.credentialSchema,
        }, getSchema);
      } else {
        credSchema = this.extractSchemaWhenIdNotSet(document);
        wasExactSchema = false;
      }
      return [credSchema, wasExactSchema];
    }

    static extractSchema(document) {
      let credSchema;
      // Should be false for legacy cases
      let wasExactSchema = true;

      if (document.credentialSchema &amp;&amp; document.credentialSchema.id) {
        // If we already have a schema to use, add that first and then generate relaxed values later on
        credSchema = CredentialSchema.fromJSON({
          // Passing all the default parsing options. Ideally `document.credentialSchema` should contain these
          parsingOptions: DefaultSchemaParsingOpts,
          ...document.credentialSchema,
        });
      } else {
        credSchema = this.extractSchemaWhenIdNotSet(document);
        wasExactSchema = false;
      }
      return [credSchema, wasExactSchema];
    }

    static extractSchemaWhenIdNotSet(document) {
      let credSchema;
      if (document.credentialSchema) {
        // schema object exists but no ID means the SDK is signalling for the suite to generate a schema
        credSchema = new CredentialSchema(CredentialSchema.essential());
      } else {
        // Else, no schema was found so just use the essentials and v0.0.1 schema version
        // NOTE: version is important here and MUST be 0.0.1 otherwise it will invalidate BBS+ credentials
        // that were issued before a change. This is required because the version value is not known in credentials
        // where no credentialSchema object is defined
        credSchema = new CredentialSchema(
          CredentialSchema.essential(),
          // Passing old parsing options and version
          {
            useDefaults: false,
            defaultMinimumInteger: -((2 ** 32) - 1),
            defaultDecimalPlaces: 0,
          },
          false,
          { version: '0.0.1' },
        );
      }

      return credSchema;
    }

    /**
     * @param document {object} to be signed.
     * @param proof {object}
     * @param documentLoader {function}
     * @param expansionMap {function}
     */
    static async getVerificationMethod({ proof, documentLoader }) {
      let { verificationMethod } = proof;
      if (typeof verificationMethod === 'object') {
        verificationMethod = verificationMethod.id;
      }
      if (!verificationMethod) {
        throw new Error('No "verificationMethod" found in proof.');
      }
      // Note: `expansionMap` is intentionally not passed; we can safely drop
      // properties here and must allow for it
      const result = await jsonld.frame(
        verificationMethod,
        {
          '@context': SECURITY_CONTEXT_URL,
          '@embed': '@always',
          id: verificationMethod,
        },
        {
          documentLoader,
          compactToRelative: false,
          expandContext: SECURITY_CONTEXT_URL,
        },
      );
      if (!result) {
        throw new Error(`Verification method ${verificationMethod} not found.`);
      }
      // ensure verification method has not been revoked
      if (result.revoked !== undefined) {
        throw new Error('The verification method has been revoked.');
      }
      return result;
    }

    /**
     * @param document {object} to be signed.
     * @param proof {object}
     * @param documentLoader {function}
     * @param expansionMap {function}
     */
    async getVerificationMethod({ proof, documentLoader }) {
      return this.constructor.getVerificationMethod({
        proof,
        documentLoader,
      });
    }

    /**
     * Generate object with `sign` method
     * @param keypair
     * @param verificationMethod
     * @returns {object}
     */
    static signerFactory(keypair, verificationMethod) {
      const { KeyPair } = this;

      return {
        id: verificationMethod,
        async sign({ data }) {
          if (!keypair || !keypair.privateKeyBuffer) {
            throw new Error('No private key to sign with.');
          }

          const msgCount = data.length;
          const sigParams = KeyPair.SignatureParams.getSigParamsOfRequiredSize(
            msgCount,
            KeyPair.defaultLabelBytes,
          );
          const sk = KeyPair.adaptKey(
            new KeyPair.SecretKey(u8aToU8a(keypair.privateKeyBuffer)),
            data.length,
          );
          const signature = KeyPair.Signature.generate(data, sk, sigParams);
          return signature.value;
        },
      };
    }

    ensureSuiteContext() {
      // no-op
    }
  },
);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BlobModule.html">BlobModule</a></li><li><a href="DidKeypair.html">DidKeypair</a></li><li><a href="DIDModule.html">DIDModule</a></li><li><a href="DockBlobResolver.html">DockBlobResolver</a></li><li><a href="DockDidOrDidMethodKey.html">DockDidOrDidMethodKey</a></li><li><a href="DockDIDResolver.html">DockDIDResolver</a></li><li><a href="DockKeyPair.html">DockKeyPair</a></li><li><a href="DockRevRegResolver.html">DockRevRegResolver</a></li><li><a href="DockStatusListResolver.html">DockStatusListResolver</a></li><li><a href="module.html#.exports">exports</a></li><li><a href="module.exports_module.exports.html">exports</a></li><li><a href="NoDIDError.html">NoDIDError</a></li><li><a href="NoOffchainDIDError.html">NoOffchainDIDError</a></li><li><a href="NoOnchainDIDError.html">NoOnchainDIDError</a></li><li><a href="Resolver.html">Resolver</a></li><li><a href="RevocationModule.html">RevocationModule</a></li><li><a href="setApi.html">setApi</a></li><li><a href="TokenMigration.html">TokenMigration</a></li><li><a href="VerifiableCredential.html">VerifiableCredential</a></li><li><a href="global.html#VerifiablePresentation">VerifiablePresentation</a></li></ul><h3>Global</h3><ul><li><a href="global.html#acceptCompositeClaims">acceptCompositeClaims</a></li><li><a href="global.html#accumulator">accumulator</a></li><li><a href="global.html#adaptKey">adaptKey</a></li><li><a href="global.html#addAttributeToReveal">addAttributeToReveal</a></li><li><a href="global.html#addCredentialToPresent">addCredentialToPresent</a></li><li><a href="global.html#addOwner">addOwner</a></li><li><a href="global.html#addParams">addParams</a></li><li><a href="global.html#addPositiveAccumulator">addPositiveAccumulator</a></li><li><a href="global.html#addPrivateStatusListEntryToCredential">addPrivateStatusListEntryToCredential</a></li><li><a href="global.html#addPublicKey">addPublicKey</a></li><li><a href="global.html#addRevRegIdToCredential">addRevRegIdToCredential</a></li><li><a href="global.html#addSchemaMetadata">addSchemaMetadata</a></li><li><a href="global.html#addStatusList21EntryToCredential">addStatusList21EntryToCredential</a></li><li><a href="global.html#addUniversalAccumulator">addUniversalAccumulator</a></li><li><a href="global.html#anchor">anchor</a></li><li><a href="global.html#asDockAddress">asDockAddress</a></li><li><a href="global.html#batchDocumentsInMerkleTree">batchDocumentsInMerkleTree</a></li><li><a href="global.html#bbs">bbs</a></li><li><a href="global.html#bbsPlus">bbsPlus</a></li><li><a href="global.html#blob">blob</a></li><li><a href="global.html#blobHexIdToQualified">blobHexIdToQualified</a></li><li><a href="global.html#buildCreateStatusListCredentialTx">buildCreateStatusListCredentialTx</a></li><li><a href="global.html#buildDockCredentialStatus">buildDockCredentialStatus</a></li><li><a href="global.html#buildParams">buildParams</a></li><li><a href="global.html#buildPublicKey">buildPublicKey</a></li><li><a href="global.html#buildRemoveStatusListCredentialTx">buildRemoveStatusListCredentialTx</a></li><li><a href="global.html#buildResolversMap">buildResolversMap</a></li><li><a href="global.html#buildUpdateStatusListCredentialTx">buildUpdateStatusListCredentialTx</a></li><li><a href="global.html#cacheLast">cacheLast</a></li><li><a href="global.html#checkCredential">checkCredential</a></li><li><a href="global.html#checkCredentialJSONLD">checkCredentialJSONLD</a></li><li><a href="global.html#checkCredentialOptional">checkCredentialOptional</a></li><li><a href="global.html#checkCredentialRequired">checkCredentialRequired</a></li><li><a href="global.html#checkRevocationRegistryStatus">checkRevocationRegistryStatus</a></li><li><a href="global.html#claimgraphToStore">claimgraphToStore</a></li><li><a href="global.html#controllerIds">controllerIds</a></li><li><a href="global.html#convertCredential">convertCredential</a></li><li><a href="global.html#convertCredentialForPresBuilding">convertCredentialForPresBuilding</a></li><li><a href="global.html#convertCredentialForVerification">convertCredentialForVerification</a></li><li><a href="global.html#convertCredentialToSerializedForSigning">convertCredentialToSerializedForSigning</a></li><li><a href="global.html#convertToPresentation">convertToPresentation</a></li><li><a href="global.html#create">create</a></li><li><a href="global.html#createAddParamsTx">createAddParamsTx</a></li><li><a href="global.html#createAddPositiveAccumulatorTx">createAddPositiveAccumulatorTx</a></li><li><a href="global.html#createAddPublicKeyTx">createAddPublicKeyTx</a></li><li><a href="global.html#createAddUniversalAccumulatorTx">createAddUniversalAccumulatorTx</a></li><li><a href="global.html#createDidKey">createDidKey</a></li><li><a href="global.html#createDidSig">createDidSig</a></li><li><a href="global.html#createDidSignature">createDidSignature</a></li><li><a href="global.html#createNewDockBlobId">createNewDockBlobId</a></li><li><a href="global.html#createNewDockDID">createNewDockDID</a></li><li><a href="global.html#createParamsObjFromChainResponse">createParamsObjFromChainResponse</a></li><li><a href="global.html#createPresentation">createPresentation</a></li><li><a href="global.html#createPublicKeyObjFromChainResponse">createPublicKeyObjFromChainResponse</a></li><li><a href="global.html#createRandomRegistryId">createRandomRegistryId</a></li><li><a href="global.html#createRemovePublicKeyTx">createRemovePublicKeyTx</a></li><li><a href="global.html#createResolver">createResolver</a></li><li><a href="global.html#createSignedRemoveStatusListCredential">createSignedRemoveStatusListCredential</a></li><li><a href="global.html#createSignedUpdateStatusListCredential">createSignedUpdateStatusListCredential</a></li><li><a href="global.html#createStatusListCredential">createStatusListCredential</a></li><li><a href="global.html#createVerifyData">createVerifyData</a></li><li><a href="global.html#credsToEEClaimGraph">credsToEEClaimGraph</a></li><li><a href="global.html#credToEECG">credToEECG</a></li><li><a href="global.html#deploy">deploy</a></li><li><a href="global.html#deployTx">deployTx</a></li><li><a href="global.html#dereferenceFromIPFS">dereferenceFromIPFS</a></li><li><a href="global.html#did">did</a></li><li><a href="global.html#documentLoader">documentLoader</a></li><li><a href="global.html#encodeExtrinsicAsHash">encodeExtrinsicAsHash</a></li><li><a href="global.html#ensureArray">ensureArray</a></li><li><a href="global.html#ensureItemsAllowed">ensureItemsAllowed</a></li><li><a href="global.html#ensureObject">ensureObject</a></li><li><a href="global.html#ensureObjectWithId">ensureObjectWithId</a></li><li><a href="global.html#ensureObjectWithKey">ensureObjectWithKey</a></li><li><a href="global.html#ensurePrivateStatusListId">ensurePrivateStatusListId</a></li><li><a href="global.html#ensureStatusListId">ensureStatusListId</a></li><li><a href="global.html#ensureString">ensureString</a></li><li><a href="global.html#ensureURI">ensureURI</a></li><li><a href="global.html#ensureValidDatetime">ensureValidDatetime</a></li><li><a href="global.html#expandJSONLD">expandJSONLD</a></li><li><a href="global.html#extractProof">extractProof</a></li><li><a href="global.html#extractSchemaForSigning">extractSchemaForSigning</a></li><li><a href="global.html#fetchStatusList2021Credential">fetchStatusList2021Credential</a></li><li><a href="global.html#fmtIter">fmtIter</a></li><li><a href="global.html#from">from</a></li><li><a href="global.html#fromBytes">fromBytes</a></li><li><a href="global.html#fromHex">fromHex</a></li><li><a href="global.html#fromJsigProofValue">fromJsigProofValue</a></li><li><a href="global.html#fromJSON">fromJSON</a></li><li><a href="global.html#fromKeypair">fromKeypair</a></li><li><a href="global.html#fromKeyringPair">fromKeyringPair</a></li><li><a href="global.html#fromPolkadotJSKeyringPair">fromPolkadotJSKeyringPair</a></li><li><a href="global.html#fromQualifiedString">fromQualifiedString</a></li><li><a href="global.html#fromSubstrateValue">fromSubstrateValue</a></li><li><a href="global.html#generate">generate</a></li><li><a href="global.html#generateEcdsaSecp256k1Keypair">generateEcdsaSecp256k1Keypair</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getAccount">getAccount</a></li><li><a href="global.html#getAccumulator">getAccumulator</a></li><li><a href="global.html#getActorDidAndNonce">getActorDidAndNonce</a></li><li><a href="global.html#getAllEventsFromBlock">getAllEventsFromBlock</a></li><li><a href="global.html#getAllExtrinsicsFromBlock">getAllExtrinsicsFromBlock</a></li><li><a href="global.html#getAllParamsByDid">getAllParamsByDid</a></li><li><a href="global.html#getAllPublicKeysByDid">getAllPublicKeysByDid</a></li><li><a href="global.html#getAndValidateSchemaIfPresent">getAndValidateSchemaIfPresent</a></li><li><a href="global.html#getBytesForStateChange">getBytesForStateChange</a></li><li><a href="global.html#getCredentialStatus">getCredentialStatus</a></li><li><a href="global.html#getDidNonce">getDidNonce</a></li><li><a href="global.html#getDockRevIdFromCredential">getDockRevIdFromCredential</a></li><li><a href="global.html#getHexIdentifier">getHexIdentifier</a></li><li><a href="global.html#getHexIdentifierFromBlobID">getHexIdentifierFromBlobID</a></li><li><a href="global.html#getImplications">getImplications</a></li><li><a href="global.html#getJsonSchemaFromCredential">getJsonSchemaFromCredential</a></li><li><a href="global.html#getJsonSchemasFromPresentation">getJsonSchemasFromPresentation</a></li><li><a href="global.html#getJSONSchemaSpec">getJSONSchemaSpec</a></li><li><a href="global.html#getKeyDoc">getKeyDoc</a></li><li><a href="global.html#getKeyPairType">getKeyPairType</a></li><li><a href="global.html#getLastParamsWritten">getLastParamsWritten</a></li><li><a href="global.html#getPrivateStatus">getPrivateStatus</a></li><li><a href="global.html#getPrivateStatuses">getPrivateStatuses</a></li><li><a href="global.html#getPublicKey">getPublicKey</a></li><li><a href="global.html#getPublicKeyFromKeyringPair">getPublicKeyFromKeyringPair</a></li><li><a href="global.html#getSerializedRemoveStatusListCredential">getSerializedRemoveStatusListCredential</a></li><li><a href="global.html#getSerializedUpdateStatusListCredential">getSerializedUpdateStatusListCredential</a></li><li><a href="global.html#getSignatureFromKeyringPair">getSignatureFromKeyringPair</a></li><li><a href="global.html#getSuiteFromKeyDoc">getSuiteFromKeyDoc</a></li><li><a href="global.html#getTransferExtrinsicsFromBlock">getTransferExtrinsicsFromBlock</a></li><li><a href="global.html#getTrimmedProofAndValue">getTrimmedProofAndValue</a></li><li><a href="global.html#getUniqueElementsFromArray">getUniqueElementsFromArray</a></li><li><a href="global.html#getUpdatesFromBlock">getUpdatesFromBlock</a></li><li><a href="global.html#getVerificationMethod">getVerificationMethod</a></li><li><a href="global.html#hash">hash</a></li><li><a href="global.html#hasRegistryRevocationStatus">hasRegistryRevocationStatus</a></li><li><a href="global.html#HEX_ID_REG_EXP_PATTERN">HEX_ID_REG_EXP_PATTERN</a></li><li><a href="global.html#initOrUpdate">initOrUpdate</a></li><li><a href="global.html#isAccumulatorRevocationStatus">isAccumulatorRevocationStatus</a></li><li><a href="global.html#isConnected">isConnected</a></li><li><a href="global.html#isHexWithGivenByteSize">isHexWithGivenByteSize</a></li><li><a href="global.html#isObject">isObject</a></li><li><a href="global.html#isRegistryRevocationStatus">isRegistryRevocationStatus</a></li><li><a href="global.html#isString">isString</a></li><li><a href="global.html#issueCredential">issueCredential</a></li><li><a href="global.html#isVerifiedCredential">isVerifiedCredential</a></li><li><a href="global.html#isVerifiedPresentation">isVerifiedPresentation</a></li><li><a href="global.html#matchingResolver">matchingResolver</a></li><li><a href="global.html#METHOD_REG_EXP_PATTERN">METHOD_REG_EXP_PATTERN</a></li><li><a href="global.html#normalizeToHex">normalizeToHex</a></li><li><a href="global.html#offchainSignatures">offchainSignatures</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#parseDid">parseDid</a></li><li><a href="global.html#parseEventAsAccumulatorUpdate">parseEventAsAccumulatorUpdate</a></li><li><a href="global.html#parseRDFDocument">parseRDFDocument</a></li><li><a href="global.html#parseRef">parseRef</a></li><li><a href="global.html#prepareAddParameters">prepareAddParameters</a></li><li><a href="global.html#prepareAddPublicKey">prepareAddPublicKey</a></li><li><a href="global.html#presentationToEEClaimGraph">presentationToEEClaimGraph</a></li><li><a href="global.html#proveCompositeClaims">proveCompositeClaims</a></li><li><a href="global.html#ps">ps</a></li><li><a href="global.html#publicKey">publicKey</a></li><li><a href="global.html#queryNextLookup">queryNextLookup</a></li><li><a href="global.html#random">random</a></li><li><a href="global.html#removeAccumulator">removeAccumulator</a></li><li><a href="global.html#removeAccumulatorTx">removeAccumulatorTx</a></li><li><a href="global.html#removeParams">removeParams</a></li><li><a href="global.html#removeParamsTx">removeParamsTx</a></li><li><a href="global.html#removePublicKey">removePublicKey</a></li><li><a href="global.html#removeStatusListCredential">removeStatusListCredential</a></li><li><a href="global.html#removeStatusListCredentialWithOneOfPolicy">removeStatusListCredentialWithOneOfPolicy</a></li><li><a href="global.html#resolve">resolve</a></li><li><a href="global.html#revealMandatoryFields">revealMandatoryFields</a></li><li><a href="global.html#revocation">revocation</a></li><li><a href="global.html#revoked">revoked</a></li><li><a href="global.html#revokedBatch">revokedBatch</a></li><li><a href="global.html#send">send</a></li><li><a href="global.html#setAccount">setAccount</a></li><li><a href="global.html#setJSONSchema">setJSONSchema</a></li><li><a href="global.html#sign">sign</a></li><li><a href="global.html#signAddParams">signAddParams</a></li><li><a href="global.html#signAddPublicKey">signAddPublicKey</a></li><li><a href="global.html#signAndSend">signAndSend</a></li><li><a href="global.html#signer">signer</a></li><li><a href="global.html#signerFactory">signerFactory</a></li><li><a href="global.html#signExtrinsic">signExtrinsic</a></li><li><a href="global.html#signPrehashed">signPrehashed</a></li><li><a href="global.html#signPresentation">signPresentation</a></li><li><a href="global.html#signRemoveParams">signRemoveParams</a></li><li><a href="global.html#signRemovePublicKey">signRemovePublicKey</a></li><li><a href="global.html#statusListCredential">statusListCredential</a></li><li><a href="global.html#supports">supports</a></li><li><a href="global.html#suspendIssuers">suspendIssuers</a></li><li><a href="global.html#toBlob">toBlob</a></li><li><a href="global.html#toBytes">toBytes</a></li><li><a href="global.html#toEncodedString">toEncodedString</a></li><li><a href="global.html#toJSON">toJSON</a></li><li><a href="global.html#toJsonldjsNode">toJsonldjsNode</a></li><li><a href="global.html#toSubstrate">toSubstrate</a></li><li><a href="global.html#transferDock">transferDock</a></li><li><a href="global.html#transferMicroDock">transferMicroDock</a></li><li><a href="global.html#trustRegistry">trustRegistry</a></li><li><a href="global.html#typedHexDID">typedHexDID</a></li><li><a href="global.html#typedHexDIDFromSubstrate">typedHexDIDFromSubstrate</a></li><li><a href="global.html#unsuspendIssuers">unsuspendIssuers</a></li><li><a href="global.html#update">update</a></li><li><a href="global.html#updateAccumulator">updateAccumulator</a></li><li><a href="global.html#updateAccumulatorTx">updateAccumulatorTx</a></li><li><a href="global.html#updateDelegatedIssuers">updateDelegatedIssuers</a></li><li><a href="global.html#updateSchemaMetadata">updateSchemaMetadata</a></li><li><a href="global.html#updateStatusList">updateStatusList</a></li><li><a href="global.html#updateStatusListCredential">updateStatusListCredential</a></li><li><a href="global.html#updateStatusListCredentialWithOneOfPolicy">updateStatusListCredentialWithOneOfPolicy</a></li><li><a href="global.html#validate">validate</a></li><li><a href="global.html#validateAddress">validateAddress</a></li><li><a href="global.html#validateBlobIDHexIdentifier">validateBlobIDHexIdentifier</a></li><li><a href="global.html#validateByteSize">validateByteSize</a></li><li><a href="global.html#validateCredentialSchema">validateCredentialSchema</a></li><li><a href="global.html#validateDockDIDHexIdentifier">validateDockDIDHexIdentifier</a></li><li><a href="global.html#validateDockDIDSS58Identifier">validateDockDIDSS58Identifier</a></li><li><a href="global.html#validateSchema">validateSchema</a></li><li><a href="global.html#verifier">verifier</a></li><li><a href="global.html#verifierFactory">verifierFactory</a></li><li><a href="global.html#verifyCredential">verifyCredential</a></li><li><a href="global.html#verifyEcdsaSecp256k1Sig">verifyEcdsaSecp256k1Sig</a></li><li><a href="global.html#verifyEcdsaSecp256k1SigPrehashed">verifyEcdsaSecp256k1SigPrehashed</a></li><li><a href="global.html#verifyID">verifyID</a></li><li><a href="global.html#verifyMerkleProofOfDocument">verifyMerkleProofOfDocument</a></li><li><a href="global.html#verifyMerkleProofOfLeaf">verifyMerkleProofOfLeaf</a></li><li><a href="global.html#verifyPresentation">verifyPresentation</a></li><li><a href="global.html#verifyPrivateStatus">verifyPrivateStatus</a></li><li><a href="global.html#verifySignature">verifySignature</a></li><li><a href="global.html#WILDCARD">WILDCARD</a></li><li><a href="global.html#withExtendedStaticProperties">withExtendedStaticProperties</a></li><li><a href="global.html#withInitializedDockAPI">withInitializedDockAPI</a></li><li><a href="global.html#writeToChain">writeToChain</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Wed Feb 07 2024 07:04:52 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
