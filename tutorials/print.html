<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dock SDK Tutorial</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">2.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts_did.html"><strong aria-hidden="true">2.1.</strong> DID</a></li><li class="chapter-item expanded "><a href="concepts_vcdm.html"><strong aria-hidden="true">2.2.</strong> Verifiable credentials and presentations</a></li><li class="chapter-item expanded "><a href="concepts_blobs_schemas.html"><strong aria-hidden="true">2.3.</strong> Schema</a></li><li class="chapter-item expanded "><a href="concepts_claim_deduction.html"><strong aria-hidden="true">2.4.</strong> Claim Deduction</a></li><li class="chapter-item expanded "><a href="concepts_poe_anchors.html"><strong aria-hidden="true">2.5.</strong> PoE Anchors</a></li><li class="chapter-item expanded "><a href="concepts_private_delegation.html"><strong aria-hidden="true">2.6.</strong> Private Delegation</a></li><li class="chapter-item expanded "><a href="concepts_public_attestation.html"><strong aria-hidden="true">2.7.</strong> Public Attestation</a></li><li class="chapter-item expanded "><a href="concepts_public_delegation.html"><strong aria-hidden="true">2.8.</strong> Public Delegation</a></li></ol></li><li class="chapter-item expanded "><a href="tutorials.html"><strong aria-hidden="true">3.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial_did.html"><strong aria-hidden="true">3.1.</strong> DID</a></li><li class="chapter-item expanded "><a href="tutorial_resolver.html"><strong aria-hidden="true">3.2.</strong> DID Resolver</a></li><li class="chapter-item expanded "><a href="tutorial_ipv.html"><strong aria-hidden="true">3.3.</strong> Credentials - Issuance, Presentation, Verification</a></li><li class="chapter-item expanded "><a href="tutorial_revocation.html"><strong aria-hidden="true">3.4.</strong> Revocation</a></li><li class="chapter-item expanded "><a href="tutorial_blobs_schemas.html"><strong aria-hidden="true">3.5.</strong> Schema</a></li><li class="chapter-item expanded "><a href="tutorial_claim_deduction.html"><strong aria-hidden="true">3.6.</strong> Claim Deduction</a></li><li class="chapter-item expanded "><a href="tutorial_poe_anchors.html"><strong aria-hidden="true">3.7.</strong> PoE Anchors</a></li><li class="chapter-item expanded "><a href="tutorial_private_delegation.html"><strong aria-hidden="true">3.8.</strong> Private Delegation</a></li><li class="chapter-item expanded "><a href="tutorial_public_delegation.html"><strong aria-hidden="true">3.9.</strong> Public Delegation</a></li><li class="chapter-item expanded "><a href="tutorial_evm.html"><strong aria-hidden="true">3.10.</strong> EVM</a></li><li class="chapter-item expanded "><a href="tutorial_anoncreds.html"><strong aria-hidden="true">3.11.</strong> Anonymous credentials using BBS+ signatures and accumulators</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Dock SDK Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p><a href="https://dock.io">Dock</a> is a blockchain built using <a href="https://www.parity.io/substrate/">Substrate</a> to facilitate the use of <a href="https://www.w3.org/TR/vc-data-model/">Verifiable Credentials Data Model 1.0</a> compliant documents, creating/managing <a href="https://www.w3.org/TR/did-core">W3C spec</a> compliant DIDs and more. The client SDK contains a library and tooling to interact with the Dock chain and also other things such as verifying and issuing credentials. View the video verison of this tutorial here: <a href="https://www.youtube.com/watch?v=jvgn9oSXBDQ">https://www.youtube.com/watch?v=jvgn9oSXBDQ</a></p>
<h1 id="pre-requisites-for-these-tutorials"><a class="header" href="#pre-requisites-for-these-tutorials">Pre-requisites for these tutorials</a></h1>
<p>For these tutorials we will be a running our own local development node. Instructions to do this can be found at the <a href="https://github.com/docknetwork/dock-substrate">dock substrate repository</a>. Once you have followed the instructions and have your local node running, you can continue. Please note that you don't always need a node to use the Dock SDK, but certain features rely on it.</p>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Installation of the SDK is pretty simple, we use NPM and our source is also available at GitHub (links below). To install via NPM or Yarn, run either <code>npm install @docknetwork/sdk</code> or <code>yarn add @docknetwork/sdk</code> respectively. Once the package and dependencies are installed, you can import it like any ES6/CJS module. You can find the complete source for the SDK at https://github.com/docknetwork/sdk and the tutorials at https://github.com/docknetwork/dock-tutorials.</p>
<h1 id="importing"><a class="header" href="#importing">Importing</a></h1>
<p>In this tutorial series we will be using NodeJS with babel for ES6 support, however the same code should work in browsers too once it is transpiled. To begin with, we should import the Dock SDK. Importing the default reference will give us a DockAPI instance. With this we will communicate with the blockchain. You can also import the DockAPI class instanciate your own objects if you prefer. Simply do:</p>
<pre><code class="language-javascript">// Import the dock SDK
import dock from "@docknetwork/sdk";
</code></pre>
<p>We will add one more import here for some shared constants across each tutorial, just the node address and account secret:</p>
<pre><code class="language-javascript">// Import some shared variables
import { address, secretUri } from "./shared-constants";
</code></pre>
<p>Lets also create this file, creating <code>shared-constants.js</code> with the contents:</p>
<pre><code class="language-javascript">export const address = "ws://localhost:9944"; // Websocket address of your Dock node
export const secretUri = "//Alice"; // Account secret in uri format, we will use Alice for local testing
</code></pre>
<h1 id="connecting-to-a-node"><a class="header" href="#connecting-to-a-node">Connecting to a node</a></h1>
<p>With the required packages and variables imported, we can go ahead and connect to our node. If you don't have a local testnet running alraedy, go to https://github.com/docknetwork/dock-substrate and follow the steps in the readme to start one. You could use the Dock testnet given a proper account with enough funds. First, create a method named <code>connectToNode</code> with an empty body for now:</p>
<pre><code class="language-javascript">export async function connectToNode() {}
</code></pre>
<p>Before working with the SDK, we need to initialize it. Upon initialization the SDK will connect to the node with the supplied address and create a keyring to manage accounts. Simply call <code>dock.init</code> and wait for the promise to resolve to connect to your node:</p>
<pre><code class="language-javascript">// Initialize the SDK and connect to the node
await dock.init({ address });
console.log("Connected to the node and ready to go!");
</code></pre>
<h1 id="creating-an-account"><a class="header" href="#creating-an-account">Creating an account</a></h1>
<p>In order to write to the chain we will need to set an account. We can perform read operations with no account set, but for our purposes we will need one. Accounts can be generated using the <code>dock.keyring</code> object through multiple methods such as URI, memonic phrase and raw seeds. See the polkadot keyring documentation (https://polkadot.js.org/api/start/keyring.html) for more information.</p>
<p>We will use our URI secret of <code>//Alice</code> which was imported from <code>shared-constants.js</code> to work with our local testnet. Add this code after <code>dock.init</code>:</p>
<pre><code class="language-javascript">// Create an Alice account for our local node
// using the dock keyring. You don't -need this
// to perform some read operations.
const account = dock.keyring.addFromUri(secretUri);
dock.setAccount(account);

// We are now ready to transact!
console.log("Connected to the node and ready to go!");
</code></pre>
<p>If all has gone well, you should be able to run this script and see that you are connected to the node. If any errors occur, the promise will fail and they will be outputted to the console.</p>
<h1 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h1>
<p>To construct your own API object, once the SDK has been installed, import the Dock API object as</p>
<pre><code class="language-js">import { DockAPI } from "@docknetwork/sdk/api";
const dock = new DockAPI();
</code></pre>
<p>To make the API object connect to the node call <code>init</code> method. This method accepts the Websocket RPC endpoint of the node is
needed. Say you have it in <code>address</code>. It also accepts a Polkadot-js keyring as well.</p>
<pre><code class="language-js">await dock.init({ address, keyring });
</code></pre>
<p>To disconnect from the node</p>
<pre><code class="language-js">await dock.disconnect();
</code></pre>
<p>To set the account used in sending the transaction and pay fees, call <code>setAccount</code> with the polkadot-js <code>account</code></p>
<pre><code class="language-js">// the `account` object might have been generated as
const account = dock.keyring.addFromUri(secretURI);
// Set the account to pay fees for transactions
dock.setAccount(account);
</code></pre>
<p>To get the account, call <code>getAccount</code></p>
<pre><code class="language-js">dock.getAccount();
</code></pre>
<p>To send a transaction, use the <code>signAndSend</code> on the <code>DockAPI</code> object</p>
<pre><code class="language-js">const res = await dock.signAndSend(transaction);
</code></pre>
<p>For interacting with the DID module, i.e. creating, updating and removing them, get the <code>didModule</code> with <code>did</code> getter</p>
<pre><code class="language-js">const didModule = dock.did;
</code></pre>
<p>Similarly, for the revocation module, get the <code>revocationModule</code> with <code>revocation</code> getter</p>
<pre><code class="language-js">const revocationModule = dock.revocation;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<ol>
<li><a href="./concepts_did.html">DID</a></li>
<li><a href="./concepts_vcdm.html">Verifiable credentials</a></li>
<li><a href="./concepts_blobs_schemas.html">Blobs and Schemas</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="w3c-did"><a class="header" href="#w3c-did">W3C DID</a></h1>
<p>DID stands for Decentralized IDentifiers. DIDs are meant to be globally unique identifiers that allow their owner to
prove cryptographic control over them. The owner(s) of the DID is called the <code>controller</code>. The identifiers are not just assignable
to humans but to anything. Quoting the <a href="https://www.w3.org/TR/did-core/">DID spec</a>,</p>
<blockquote>
<p>A DID identifies any subject (e.g., a person, organization, thing, data model, abstract entity, etc.) that the controller
of the DID decides that it identifies.</p>
</blockquote>
<p>DIDs differ from public keys in that DIDs are persistent, i.e. a public key has to be changed if the private key is stolen/lost
or the cryptographic scheme of the public key is no longer considered safe. This is not the case with DIDs, they can remain
unchanged even when the associated cryptographic material changes. Moreover, a DID can have multiple keys and any of its
keys can be rotated. Additionally, depending on the scheme, public keys can be quite large (several hundred bytes in RSA)
whereas a unique identifier can be much smaller.</p>
<p>Each DID is associated with a <code>DID Document</code> that specifies the subject, the public keys, the authentication mechanisms usable
by the subject, authorizations the subject has given to others, service endpoints to communicate with the subject, etc,
for all properties that can be put in the DID Document, refer <a href="https://www.w3.org/TR/did-core/#core-properties">this section of the spec</a>.
DIDs and their associated DID Documents are stored on the DID registry which is a term used for the centralized on decentralized
database persisting the DID and its Document.</p>
<p>The process of discovering the DID Document for a DID is called DID resolution and the tool (library or a service) is called DID
resolver. To resolve the DID, the resolver first needs to check on which registry the DID is hosted and then decide whether it
is capable or willing to lookup that registry. The registry is indicated by the <code>DID method</code> of that DID. In addition to the
registry, the method also specifies other details of that DID like the supported operations, crypto, etc. Each DID method
defines its own specification, Docks's DID method spec is <a href="https://github.com/docknetwork/dock-did-driver/blob/master/Dock%20DID%20method%20specification.md">here</a>.
In case of Dock, the registry is the Dock blockchain, and the method is <code>dock</code>.
We support 2 kinds of DIDs, on-chain and off-chain.
With off-chain DIDs, only a reference to the DID Document is kept on chain and this reference can be an CID (for IPFS) or a URL or any
custom format.
With on-chain DIDs, the keys, controllers and service endpoints of the DID are stored on chain. A DID key can have 1 or more <a href="https://www.w3.org/TR/did-core/#verification-relationships">verification
methods</a> which indicates what that key can be used for. Only a DID key with verification
relationship <code>capabilityInvocation</code> can update the DID document, i.e. add/remove keys, add/remove controllers,
add/remove service endpoints and remove the DID. Also a DID can have 1 or more controllers and these controllers can also
update its DID document. A DID with a key with <code>capabilityInvocation</code> verification relationship is its own controller.</p>
<p>An example on-chain Dock DID.</p>
<pre><code>did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW
</code></pre>
<p>Above DID has method <code>dock</code> and the DID identifier is <code>5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW</code>. Dock DID identifiers
are 32 bytes in size.</p>
<p>An example DID Document</p>
<pre><code class="language-json">{
  "@context": ["https://www.w3.org/ns/did/v1"],
  "id": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn",
  "controller": ["did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn"],
  "verificationMethod": [
    {
      "id": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-1",
      "type": "Sr25519VerificationKey2020",
      "controller": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn",
      "publicKeyBase58": "7d3QsaW6kP7bGiJtRZBxdyZsbJqp6HXv1owwr8aYBjbg"
    },
    {
      "id": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-2",
      "type": "Ed25519VerificationKey2018",
      "controller": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn",
      "publicKeyBase58": "p6gb7WNh9SWC4hkye4VV5epo1LYpLXKH21ojfwJLayg"
    }
  ],
  "authentication": [
    "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-1",
    "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-2"
  ],
  "assertionMethod": [
    "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-1"
  ],
  "capabilityInvocation": [
    "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-1"
  ]
}
</code></pre>
<p>Dock DIDs support multiple keys. The keys are present in the <code>publicKey</code> section. As per the above DID document, the DID <code>did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn</code>
has 2 public keys and 1 controller which is itself.
Note how that public key is referred to using its <code>id</code> in <code>authentication</code>, <code>assertionMethod</code> and <code>capabilityInvocation</code> sections.
The above document states that the DID <code>did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn</code> can authenticate with 2 public keys
whose id is specified under <code>authentication</code>. When it attests to some fact (becomes issuer), it can only use 1 key, which is under <code>assertionMethod</code>.
The keys specified under <code>capabilityInvocation</code> can be used to update the DID document, i.e. add/remove keys, etc.</p>
<pre><code class="language-json">{
  "@context": ["https://www.w3.org/ns/did/v1"],
  "id": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn",
  "controller": [
    "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn",
    "did:dock:5Hc3RZyfJd98QbFENrDP57Lga8mSofDFwKQpodN2g2ZcYscz"
  ],
  "verificationMethod": [
    {
      "id": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-1",
      "type": "Sr25519VerificationKey2020",
      "controller": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn",
      "publicKeyBase58": "7d3QsaW6kP7bGiJtRZBxdyZsbJqp6HXv1owwr8aYBjbg"
    },
    {
      "id": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-2",
      "type": "Ed25519VerificationKey2018",
      "controller": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn",
      "publicKeyBase58": "p6gb7WNh9SWC4hkye4VV5epo1LYpLXKH21ojfwJLayg"
    }
  ],
  "authentication": [
    "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-1",
    "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-2"
  ],
  "assertionMethod": [
    "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-1"
  ],
  "capabilityInvocation": [
    "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-1"
  ]
}
</code></pre>
<p>In the above DID document, there are controllers, 1 is the DID <code>did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn</code> itself
and the other is <code>did:dock:5Hc3RZyfJd98QbFENrDP57Lga8mSofDFwKQpodN2g2ZcYscz</code>. This means that DID <code>did:dock:5Hc3RZyfJd98QbFENrDP57Lga8mSofDFwKQpodN2g2ZcYscz</code>
can also modify above DID document, i.e. add/remove keys, add/remove controller, etc.</p>
<pre><code class="language-json">{
  "@context": ["https://www.w3.org/ns/did/v1"],
  "id": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn",
  "controller": [
    "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn",
    "did:dock:5Hc3RZyfJd98QbFENrDP57Lga8mSofDFwKQpodN2g2ZcYscz"
  ],
  "verificationMethod": [
    {
      "id": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-1",
      "type": "Sr25519VerificationKey2020",
      "controller": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn",
      "publicKeyBase58": "7d3QsaW6kP7bGiJtRZBxdyZsbJqp6HXv1owwr8aYBjbg"
    },
    {
      "id": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-2",
      "type": "Ed25519VerificationKey2018",
      "controller": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn",
      "publicKeyBase58": "p6gb7WNh9SWC4hkye4VV5epo1LYpLXKH21ojfwJLayg"
    }
  ],
  "authentication": [
    "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-1",
    "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-2"
  ],
  "assertionMethod": [
    "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-1"
  ],
  "capabilityInvocation": [
    "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-1"
  ],
  "service": [
    {
      "id": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#linked-domain-1",
      "type": "LinkedDomains",
      "serviceEndpoint": ["https://foo.example.com"]
    }
  ]
}
</code></pre>
<p>In the above document, there is also a service endpoint for the DID.</p>
<p>DIDs can also be keyless, i.e. not have any keys of its own. In this case the DID is not self-controlled by controlled by
another DID(s) and the other DID could add/remove keys, controllers or remove the DID. An example keyless DID is shown below</p>
<pre><code class="language-json">{
  "@context": ["https://www.w3.org/ns/did/v1"],
  "id": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn",
  "controller": ["did:dock:5Hc3RZyfJd98QbFENrDP57Lga8mSofDFwKQpodN2g2ZcYscz"],
  "verificationMethod": [],
  "authentication": [],
  "assertionMethod": [],
  "capabilityInvocation": [],
  "service": [
    {
      "id": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#linked-domain-1",
      "type": "LinkedDomains",
      "serviceEndpoint": ["https://bar.example.com"]
    }
  ]
}
</code></pre>
<p>In the above DID Doc, DID <code>did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn</code> is controlled by <code>did:dock:5Hc3RZyfJd98QbFENrDP57Lga8mSofDFwKQpodN2g2ZcYscz</code>. Now
<code>did:dock:5Hc3RZyfJd98QbFENrDP57Lga8mSofDFwKQpodN2g2ZcYscz</code> add a key, say for authentication to <code>did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn</code> and the
DID Doc will look like below</p>
<pre><code class="language-json">{
  "@context": ["https://www.w3.org/ns/did/v1"],
  "id": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn",
  "controller": ["did:dock:5Hc3RZyfJd98QbFENrDP57Lga8mSofDFwKQpodN2g2ZcYscz"],
  "verificationMethod": [
    {
      "id": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-1",
      "type": "Ed25519VerificationKey2018",
      "controller": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn",
      "publicKeyBase58": "p6gb7WNh9SWC4hkye4VV5epo1LYpLXKH21ojfwJLayg"
    }
  ],
  "authentication": [
    "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#keys-1"
  ],
  "assertionMethod": [],
  "capabilityInvocation": [],
  "service": [
    {
      "id": "did:dock:5Hhnorjqd7vXPKdT7Y1ZpHksMBHsVRNewntZjMF2NHm3PoFn#linked-domain-1",
      "type": "LinkedDomains",
      "serviceEndpoint": ["https://bar.example.com"]
    }
  ]
}
</code></pre>
<p>Another thing to keep in mind is that the keys associated with the Dock DID are independent of the keys used to send the
transaction on chain and pay fees. Eg. Alice might not have any tokens to write anything on chain but can still create a
DID and corresponding key and ask Bob who has tokens to register the DID on chain. Even though Bob wrote the DID on chain,
he cannot update or remove it since only Alice has the keys associated with that DID. Similarly, when Alice wants to update
the DID , it can create the update, sign it and send it to Carol this time to send the update on chain. Similar to blockchain
accounts, DIDs also have their own nonce which increments by 1 on each action of a DID. On DID creation, its nonce is set to
the block number on which its created and the DID is expected to send signed payloads, each with nonce 1 more than the previous nonce.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verifiable-credentials"><a class="header" href="#verifiable-credentials">Verifiable Credentials</a></h1>
<p>Credentials are a part of our daily lives: driver's licenses are used to
assert that we are capable of operating a motor vehicle, university degrees
can be used to assert our level of education, and government-issued passports
enable us to travel between countries.</p>
<p>These credentials provide benefits to us when used in the physical world, but
their use on the Web continues to be elusive.</p>
<p>Currently it is difficult to express education qualifications, healthcare
data, financial account details, and other sorts of third-party verified
machine-readable personal information on the Web.</p>
<p>The difficulty of expressing digital credentials on the Web makes it
challenging to receive the same benefits through the Web that physical
credentials provide us in the physical world.</p>
<p>The <a href="https://www.w3.org/TR/vc-data-model/">Verifiable Credentials Data Model 1.0 (VCDM)</a>
specification provides a standard way to express credentials on the Web in a
way that is cryptographically secure, privacy respecting, and
machine-verifiable.</p>
<h2 id="participants-and-workflow"><a class="header" href="#participants-and-workflow">Participants and workflow</a></h2>
<ul>
<li>Credentials are issued by an entity called the <strong>issuer</strong>.</li>
<li><strong>Issuer</strong> issues the credential about a <strong>subject</strong> by signing the credential with his key. If the credential is revocable,
the issuer must specify how and from where revocation status must be checked. It is not necessary that revocation is managed by
the issuer, the issuer might designate a different authority for revocation.</li>
<li><strong>Issuer</strong> gives the credential to the <strong>holder</strong>. The <strong>holder</strong> might be the same as the <strong>subject</strong>.</li>
<li>A service provider or anyone willing to check if the <strong>holder</strong> possesses certain credentials requests a <strong>presentation</strong> about those
credentials. This entity requesting the <strong>presentation</strong> is called the <strong>verifier</strong>. To protect against replay attacks, (a
verifier receiving the presentation and replaying the same presentation at some other verifier), a verifier must supply a
challenge that must be embedded in the presentation.</li>
<li><strong>Holder</strong> creates a <strong>presentation</strong> for the required credentials. The <strong>presentation</strong> must indicate which
credentials it is about and must be signed by the <strong>holder</strong> of the credentials.</li>
<li><strong>Verifier</strong> on receiving the presentation verifies the validity of each credential in the <strong>presentation</strong>. This includes
checking correctness of the data model of the credential, the authenticity by verifying the issuer's signature and revocation
status if the credential is revocable. It then checks whether the presentation contains the signature from the
<strong>holder</strong> on the presentation which also includes his given challenge.</li>
</ul>
<h2 id="issuing"><a class="header" href="#issuing">Issuing</a></h2>
<p>To issue a verifiable credential, the issuer needs to have a public key that is accessible by the holder and verifier to verify the
signature (in <code>proof</code>) in the credential. Though the VCDM spec does not mandate it, an issuer in Dock must have a DID on chain.
This DID is present in the credential in the <code>issuer</code> field. An example credential where both the issuer and holder have Dock DIDs</p>
<pre><code class="language-js">{
    '@context': [
      'https://www.w3.org/2018/credentials/v1',
      'https://www.w3.org/2018/credentials/examples/v1'
    ],
    id: '0x9b561796d3450eb2673fed26dd9c07192390177ad93e0835bc7a5fbb705d52bc',
    type: [ 'VerifiableCredential', 'AlumniCredential' ],
    issuanceDate: '2020-03-18T19:23:24Z',
    credentialSubject: {
      id: 'did:dock:5GL3xbkr3vfs4qJ94YUHwpVVsPSSAyvJcafHz1wNb5zrSPGi',
      alumniOf: 'Example University'
    },
    issuer: 'did:dock:5GUBvwnV6UyRWZ7wjsBptSquiSHGr9dXAy8dZYUR9WdjmLUr',
    proof: {
      type: 'Ed25519Signature2018',
      created: '2020-04-22T07:50:13Z',
      jws: 'eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..GBqyaiTMhVt4R5P2bMGcLNJPWEUq7WmGHG7Wc6mKBo9k3vSo7v7sRKwqS8-m0og_ANKcb5m-_YdXC2KMnZwLBg',
      proofPurpose: 'assertionMethod',
      verificationMethod: 'did:dock:5GUBvwnV6UyRWZ7wjsBptSquiSHGr9dXAy8dZYUR9WdjmLUr#keys-1'
    }
}
</code></pre>
<h2 id="presentation"><a class="header" href="#presentation">Presentation</a></h2>
<p>The holder while creating the presentation signs it with his private key. For the verifier to verify the presentation, in
addition to verifying the issuer's signature, he needs to verify this signature as well, and for that he must know the
holder's public key. One way to achieve this is to make the holder have a DID too so that the verifier can look up the DID
on chain and learn the public key. An example presentation signed by the holder</p>
<pre><code class="language-js">{
    '@context': [ 'https://www.w3.org/2018/credentials/v1' ],
    type: [ 'VerifiablePresentation' ],
    verifiableCredential: [
      {
          '@context': [
            'https://www.w3.org/2018/credentials/v1',
            'https://www.w3.org/2018/credentials/examples/v1'
          ],
          id: 'A large credential id with size &gt; 32 bytes',
          type: [ 'VerifiableCredential', 'AlumniCredential' ],
          issuanceDate: '2020-03-18T19:23:24Z',
          credentialSubject: {
            id: 'did:dock:5GnE6u2dt9nC7tgf5vSdKy4gYX3jwqthbrBnjiay2LWETdrV',
            alumniOf: 'Example University'
          },
          credentialStatus: {
            id: 'rev-reg:dock:0x0194db371bab472a9cc920b5dfb1447aad5a6db906c46ff378cf0fc337a0c8c0',
            type: 'CredentialStatusList2017'
          },
          issuer: 'did:dock:5CwAuM8cPetXWbZN2JhMFWtLjxZ6DokiDdHViGw2FfxC1Cya',
          proof: {
            type: 'Ed25519Signature2018',
            created: '2020-04-22T07:58:43Z',
            jws: 'eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..bENDgnK29BHRhP05ehbQkOPfqweppGyI7NeH02YT1hzSDEHseOzCDx-g9dS4lY-m_bElwbOptOlRnQ2g9MW7Ag',
            proofPurpose: 'assertionMethod',
            verificationMethod: 'did:dock:5CwAuM8cPetXWbZN2JhMFWtLjxZ6DokiDdHViGw2FfxC1Cya#keys-1'
          }
      }
    ],
    id: '0x4bd107aee17744dcec10208d7551620664dcba7e88ce11c2312c02df562754f1',
    proof: {
      type: 'Ed25519Signature2018',
      created: '2020-04-22T07:58:49Z',
      challenge: '0x6a5a5d58a99705c4d499fa7cdcdc62eeb2f742eb878456babf49b9a6669d0b76',
      domain: 'test domain',
      jws: 'eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..HW7bDjvsRETeM25a3BtMgER53FtzK6rUBX_46cFo-i6O1y7p_TM-ED2iSTrFBUrDc7vH8QqoeUTY8e5ir5RvCg',
      proofPurpose: 'authentication',
      verificationMethod: 'did:dock:5GnE6u2dt9nC7tgf5vSdKy4gYX3jwqthbrBnjiay2LWETdrV#keys-1'
    }
}
</code></pre>
<h2 id="revocation"><a class="header" href="#revocation">Revocation</a></h2>
<p>If the credential is revocable, the issuer must specify how the revocation check must be done in the <code>credentialStatus</code> field.
On Dock, credential revocation is managed with a revocation registry. There can be multiple registries on chain and each
registry has a unique id. It is recommended that the revocation authority creates a new registry for each credential type.
While issuing the credential, issuer embeds the revocation registry's id in the credential in the <code>credentialStatus</code> field.
An example credential with Dock revocation registry</p>
<pre><code class="language-js">{
    '@context': [
      'https://www.w3.org/2018/credentials/v1',
      'https://www.w3.org/2018/credentials/examples/v1'
    ],
    id: 'A large credential id with size &gt; 32 bytes',
    type: [ 'VerifiableCredential', 'AlumniCredential' ],
    issuanceDate: '2020-03-18T19:23:24Z',
    credentialSubject: {
      id: 'did:dock:5GnE6u2dt9nC7tgf5vSdKy4gYX3jwqthbrBnjiay2LWETdrV',
      alumniOf: 'Example University'
    },
    credentialStatus: {
      id: 'rev-reg:dock:0x0194db371bab472a9cc920b5dfb1447aad5a6db906c46ff378cf0fc337a0c8c0',
      type: 'CredentialStatusList2017'
    },
    issuer: 'did:dock:5CwAuM8cPetXWbZN2JhMFWtLjxZ6DokiDdHViGw2FfxC1Cya',
    proof: {
      type: 'Ed25519Signature2018',
      created: '2020-04-22T07:58:43Z',
      jws: 'eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..bENDgnK29BHRhP05ehbQkOPfqweppGyI7NeH02YT1hzSDEHseOzCDx-g9dS4lY-m_bElwbOptOlRnQ2g9MW7Ag',
      proofPurpose: 'assertionMethod',
      verificationMethod: 'did:dock:5CwAuM8cPetXWbZN2JhMFWtLjxZ6DokiDdHViGw2FfxC1Cya#keys-1'
    }
}
</code></pre>
<p>To revoke a credential, the revocation authority (might be same as the issuer), puts a hash of the credential id in the revocation registry.
To check the revocation status of a credential, hash the credential id and query the registry id specified in the credential.
The revocation of a credential can be undone if the revocation registry supports undoing. Moreover, currently, each registry is
owned by a single DID so that DID can revoke a credential or undo the revocation. In future, Dock will support ownership of
the registry with mulitple DIDs and in different fashions, like any one of the owner DIDs could revoke or a threshold is needed,
etc. To learn more about revocation registries, refer the <a href="./tutorial_revocation.html">revocation section</a> of the documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schemas"><a class="header" href="#schemas">Schemas</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="concepts_blobs_schemas.html#intro-to-schemas">Intro</a></li>
<li><a href="concepts_blobs_schemas.html#blobs">Blobs</a></li>
<li><a href="concepts_blobs_schemas.html#json-schemas">JSON Schemas</a></li>
<li><a href="concepts_blobs_schemas.html#schemas-in-verifiable-credentials">Schemas in Verifiable Credentials</a></li>
</ol>
<h2 id="intro-to-schemas"><a class="header" href="#intro-to-schemas">Intro to Schemas</a></h2>
<p>Data Schemas are useful when enforcing a specific structure on a collection of data like a Verifiable Credential.
Data Verification schemas, for example, are used to verify that the structure and contents of a Verifiable Credential
conform to a published schema. Data Encoding schemas, on the other hand, are used to map the contents of a Verifiable
Credential to an alternative representation format, such as a binary format used in a zero-knowledge proof.
Data schemas serve a different purpose than that of the <code>@context</code> property in a Verifiable Credential, the latter
neither enforces data structure or data syntax, nor enables the definition of arbitrary encodings to alternate
representation formats.</p>
<h2 id="blobs"><a class="header" href="#blobs">Blobs</a></h2>
<p>Before diving further into Schemas in it is important to understand the way these are stored in the Dock chain.
Schemas are stored on chain as a <code>Blob</code> in the Blob Storage module. They are identified and retrieved by their unique
blob id, a 32 byte long hex string. They are authored by a DID and have a max size of 8192 bytes.
The chain is agnostic to the contents of blobs and thus to schemas. Blobs may be used to store types of data other than
schemas.</p>
<h2 id="json-schemas"><a class="header" href="#json-schemas">JSON Schemas</a></h2>
<p>JSON Schema can be used to require that a given JSON document (an instance) satisfies a certain number of criteria.
JSON Schema validation asserts constraints on the structure of instance data. An instance location that satisfies all
asserted constraints is then annotated with any keywords that contain non-assertion information, such as descriptive
metadata and usage hints. If all locations within the instance satisfy all asserted constraints, then the instance is
said to be valid against the schema.
Each schema object is independently evaluated against each instance location to which it applies.
This greatly simplifies the implementation requirements for validators by ensuring that they do not need to maintain
state across the document-wide validation process.
More about JSON schemas can be found <a href="http://json-schema.org/draft/2019-09/json-schema-validation.html">here</a> and
<a href="https://json-schema.org/understanding-json-schema/index.html">here</a>.</p>
<p>Let's see an example JSON schema definition:</p>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Alumni",
  "type": "object",
  "properties": {
    "emailAddress": {
      "type": "string",
      "format": "email"
    },
    "alumniOf": {
      "type": "string"
    }
  },
  "required": ["emailAddress", "alumniOf"],
  "additionalProperties": false
}
</code></pre>
<p>In our context, these schemas are stored on-chain as a blob, which means they have a Blob Id as id and a DID as author:</p>
<pre><code class="language-json">{
  "id": "blob:dock:1DFdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW",
  "author": "did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW",
  "schema": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "description": "Alumni",
    "type": "object",
    "properties": {
      "emailAddress": {
        "type": "string",
        "format": "email"
      },
      "alumniOf": {
        "type": "string"
      }
    },
    "required": ["emailAddress", "alumniOf"],
    "additionalProperties": false
  }
}
</code></pre>
<p>Had we referenced this JSON schema from within a Verifiable Credential, validation would fail if the <code>credentialSubject</code>
doesn't contain an <code>emailAddress</code> field, or it isn't a string formatted as an email; or if it doesn't contain a
property <code>alumniOf</code> with type string. It'd also fail if a subject contains other properties not listed here (except for
the <code>id</code> property which is popped out before validation).</p>
<h2 id="schemas-in-verifiable-credentials"><a class="header" href="#schemas-in-verifiable-credentials">Schemas in Verifiable Credentials</a></h2>
<p>In pursuit of <a href="https://w3c.github.io/vc-data-model/#extensibility">extensibility</a>, VCDM makes an Open World Assumption;
a credential can state anything. Schemas allow issuers to "opt-out" of some of the freedom VCDM allows. Issuers can
concretely limit what a given credential will claim. In a closed world, a verifier can rely on the structure of a
credential to enable new types of credential processing e.g. generating a complete and human-friendly graphical
representation of a credential.</p>
<p>The <a href="https://www.w3.org/TR/vc-data-model/">Verifiable Credentials Data Model</a> specifies the models used for Verifiable
Credentials and Verifiable Presentations, and explains the relationships between three parties: issuer, holder, and
verifier. A critical piece of infrastructure out of the scope of those specifications is the Credential Schema.
<a href="https://w3c-ccg.github.io/vc-json-schemas/">This specification</a> provides a mechanism to express a Credential Schema
and the protocols for evolving the schema.</p>
<p>Following our example above, we could use the current SDK to store the Email schema above as a Blob in the Dock chain.
Assuming we did that and our schema was stored as <code>blob:dock:1DFdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW</code>, we
can use it in a Verifiable Credential as follows:</p>
<pre><code class="language-json">"credentialSchema": {
  "id": "blob:dock:1DFdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW",
  "type": "JsonSchemaValidator2018"
}
</code></pre>
<p>The following is an example of a valid Verifiable Credential using the above schema:</p>
<pre><code class="language-json">{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "uuid:0x9b561796d3450eb2673fed26dd9c07192390177ad93e0835bc7a5fbb705d52bc",
  "type": ["VerifiableCredential", "AlumniCredential"],
  "issuanceDate": "2020-03-18T19:23:24Z",
  "credentialSchema": {
    "id": "blob:dock:1DFdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW",
    "type": "JsonSchemaValidator2018"
  },
  "credentialSubject": {
    "id": "did:dock:5GL3xbkr3vfs4qJ94YUHwpVVsPSSAyvJcafHz1wNb5zrSPGi",
    "emailAddress": "john.smith@example.com",
    "alumniOf": "Example University"
  },
  "issuer": "did:dock:5GUBvwnV6UyRWZ7wjsBptSquiSHGr9dXAy8dZYUR9WdjmLUr",
  "proof": {
    "type": "Ed25519Signature2018",
    "created": "2020-04-22T07:50:13Z",
    "jws": "eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..GBqyaiTMhVt4R5P2bMGcLNJPWEUq7WmGHG7Wc6mKBo9k3vSo7v7sRKwqS8-m0og_ANKcb5m-_YdXC2KMnZwLBg",
    "proofPurpose": "assertionMethod",
    "verificationMethod": "did:dock:5GUBvwnV6UyRWZ7wjsBptSquiSHGr9dXAy8dZYUR9WdjmLUr#keys-1"
  }
}
</code></pre>
<p>In contrast, the following is an example of an invalid Verifiable Credential:</p>
<pre><code class="language-json">{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "uuid:0x9b561796d3450eb2673fed26dd9c07192390177ad93e0835bc7a5fbb705d52bc",
  "type": ["VerifiableCredential", "AlumniCredential"],
  "issuanceDate": "2020-03-18T19:23:24Z",
  "credentialSchema": {
    "id": "blob:dock:1DFdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW",
    "type": "JsonSchemaValidator2018"
  },
  "credentialSubject": [
    {
      "id": "did:dock:5GL3xbkr3vfs4qJ94YUHwpVVsPSSAyvJcafHz1wNb5zrSPGi",
      "emailAddress": "john.smith@example.com",
      "alumniOf": "Example University"
    },
    {
      "id": "did:dock:6DF3xbkr3vfs4qJ94YUHwpVVsPSSAyvJcafHz1wNb5zrSPGi"
    }
  ],
  "issuer": "did:dock:5GUBvwnV6UyRWZ7wjsBptSquiSHGr9dXAy8dZYUR9WdjmLUr",
  "proof": {
    "type": "Ed25519Signature2018",
    "created": "2020-04-22T07:50:13Z",
    "jws": "eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..GBqyaiTMhVt4R5P2bMGcLNJPWEUq7WmGHG7Wc6mKBo9k3vSo7v7sRKwqS8-m0og_ANKcb5m-_YdXC2KMnZwLBg",
    "proofPurpose": "assertionMethod",
    "verificationMethod": "did:dock:5GUBvwnV6UyRWZ7wjsBptSquiSHGr9dXAy8dZYUR9WdjmLUr#keys-1"
  }
}
</code></pre>
<p>the reason this last Credential is invalid is that only one of the subjects properly follow the Schema, the second
subject does not specify the fields <code>emailAddress</code> and <code>alumniOf</code> which were specified as required.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="claim-deduction"><a class="header" href="#claim-deduction">Claim Deduction</a></h1>
<p>The <a href="https://www.w3.org/TR/vc-data-model/">verifiable credentials data model</a> is based on a machine comprehensible language called <a href="https://www.w3.org/TR/rdf-primer/">RDF</a>. RDF represents arbitrary semantic knowledge as <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">graph</a>s. Computers can perform automatic deductive reasoning over RDF; given assumptions (represented as an RDF graph) and axioms (represented as logical rules), a computer can infer new conclusions and even prove them to other computers using deductive derivations (proofs).</p>
<p>Every VCDM credential is representable as an RDF graph. So computers can reason about them, deriving new conclusions that weren't explicitly stated by the issuer.</p>
<p>The Dock SDK exposes utilities for primitive deductive reasoning over verified credentials. The Verifier has a choice to perform deduction themself (expensive), or offload that responsibility to the Presenter of the credential[s] by accepting deductive proofs of composite claims.</p>
<p>In RDF, if graph A is true and graph B is true, then the <a href="https://en.wikipedia.org/wiki/Union_(set_theory)">union</a> of those graphs, is also true <code>A∧B-&gt;A∪B</code> <sup class="footnote-reference"><a href="#1">1</a></sup>. Using this property we can combine multiple credentials and reason over their union.</p>
<h2 id="explicit-ethos"><a class="header" href="#explicit-ethos">Explicit Ethos</a></h2>
<p>Imagine a signed credential issued by <strong>Alice</strong> claiming that <strong>Joe</strong> is a <strong>Member</strong>.</p>
<pre><code class="language-json">{
  ...
  "issuer": "Alice",
  "credentialSubject": {
    "id": "Joe",
    "@type": "Member"
  },
  "proof": ...,
  ...
}
</code></pre>
<p>The credential does not directly prove that <strong>Joe</strong> is a <strong>Member</strong>. Rather, it proves <strong>Alice</strong> <strong>Claims</strong> <strong>Joe</strong> to be a <strong>Member</strong>.</p>
<p>Not proven:</p>
<pre><code class="language-nquads">&lt;Joe&gt; &lt;type&gt; &lt;Member&gt; .
</code></pre>
<p>Proven:</p>
<pre><code class="language-nquads">&lt;Joe&gt; &lt;type&gt; &lt;Member&gt; &lt;Alice&gt; .
</code></pre>
<p>The fourth and final element of the proven <em>quad</em> is used here to indicate the source of the information, Alice. The final element of a quad is its <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-graph-name">graph name</a>.</p>
<p>A signed credentials are <a href="https://en.wikipedia.org/wiki/Modes_of_persuasion#Ethos">ethos</a> arguments and a credential may be converted to a list of quads (a claimgraph). We call this representation "Explicit Ethos" form. If a credential is <em>verified</em>, then its explicit ethos form is <em>true</em>.</p>
<h2 id="rule-format"><a class="header" href="#rule-format">Rule Format</a></h2>
<p>To perform reasoning and to accept proofs, the Verifier must select the list of logical rules wish to accept. Rules (or axioms if you prefer), are modeled as if-then relationships.</p>
<pre><code class="language-js">const rules = [
  {
    if_all: [],
    then: [],
  },
];
</code></pre>
<p>During reasoning, when an <code>if_all</code> pattern is matched, its corresponding <code>then</code> pattern will be implied. In logic terms, each "rule" is the conditional premise of a <a href="https://en.wikipedia.org/wiki/Modus_ponens">modus ponens</a>.</p>
<p><code>{ if_all: [A, B, C], then: [D, E] }</code> means that <code>if (A and B and C) then (D and E)</code>.</p>
<p>Rules can contain Bound or Unbound entities. Unbound entities are named variables. Each rule has it's own unique scope, so Unbound entities introduced in the <code>if_all</code> pattern can be used in the <code>then</code> pattern.</p>
<pre><code class="language-js">{
  if_all: [
    [
      { Bound: alice },
      { Bound: likes },
      { Unbound: 'thing' },
      { Bound: defaultGraph },
    ],
  ],
  then: [
    [
      { Bound: bob },
      { Bound: likes },
      { Unbound: 'thing' },
      { Bound: defaultGraph },
    ],
  ],
}
</code></pre>
<p>means</p>
<pre><code>For any ?thing:
  if [alice likes ?thing]
  then [bob likes ?thing]
</code></pre>
<p>in other words: <code>∀ thing: [alice likes thing] -&gt; [bob likes thing]</code></p>
<p>If an unbound variable appears in the <code>then</code> pattern but does not appear in the <code>if_all</code> pattern the rule is considered invalid and will be rejected by the reasoner.</p>
<p>Bound entities are constants of type RdfTerm. RDF nodes may be one of four things, an IRI, a blank node, a literal, or the default graph. For those familiar with algebraic datatypes:</p>
<pre><code class="language-rust ignore">enum RdfNode {
  Iri(Url),
  Blank(String),
  Literal {
    value: String,
    datatype: Url,
  },
  DefaultGraph,
}</code></pre>
<p>The SDK represents RDF nodes like so:</p>
<pre><code class="language-js">const alice = { Iri: "did:sample:alice" };
const literal = {
  Literal: {
    value: "{}",
    datatype: "http://www.w3.org/1999/02/22-rdf-syntax-ns#JSON",
  },
};
// blank nodes are generally not useful in rule definitions
const blank = { Blank: "_:b0" };
const defaultGraph = { DefaultGraph: true };
</code></pre>
<p>Here is an example of a complete rule definition:</p>
<pre><code class="language-js">{
  if_all: [
    [
      { Unbound: 'food' },
      { Bound { Iri: 'https://example.com/contains' } },
      { Bound: { Iri: 'https://example.com/butter' } },
      { Bound: { DefaultGraph: true } }
    ],
    [
      { Unbound: 'person' },
      { Bound: 'http://xmlns.com/foaf/0.1/name' },
      { Literal: {
        value: 'Bob',
        datatype: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral',
      } },
      { Bound: { DefaultGraph: true } }
    ],
  ],
  then: [
    [
      { Unbound: 'person' },
      { Bound: { Iri: 'https://example.com/likes' } },
      { Unbound: 'food' },,
      { Bound: { DefaultGraph: true } }
    ]
  ],
}
// all things named "Bob" like all things containing butter
</code></pre>
<p>See the <a href="tutorial_claim_deduction.html">claim deduction tutorial</a> for more another example.</p>
<h2 id="limited-expresiveness"><a class="header" href="#limited-expresiveness">Limited Expresiveness</a></h2>
<p>The astute among you may notice the SDK's model for rules does not allow logical negation. This is by design. For one, it keeps the the rule description language from being turing complete so inference time is always bounded. Secondly, RDF choses the <a href="https://en.wikipedia.org/wiki/Open-world_assumption">Open World Assumption</a> so absence of any particular statement in a credential/claimgraph is not meaningful within RDF semantics.</p>
<p>The rule language is expected to be expressive enough to implement <a href="https://www.w3.org/TR/owl2-profiles/#OWL_2_EL">OWL 2 EL</a> but not <a href="https://www.w3.org/TR/owl-ref/">OWL 1 DL</a>.</p>
<h2 id="terms"><a class="header" href="#terms">Terms</a></h2>
<ul>
<li><a href="https://www.w3.org/TR/vc-data-model/#dfn-verifier">Verifier</a>: The party that accepts and checks VCDM credential[s].</li>
<li><a href="https://www.w3.org/TR/vc-data-model/#dfn-issuer">Issuer</a>: The party that signed a VCDM credential.</li>
<li><a href="https://www.w3.org/TR/vc-data-model/">VCDM</a>: Verifiable Credentials Data Model</li>
<li><a href="https://en.wikipedia.org/wiki/Resource_Description_Framework">RDF</a>: A model for representing general knowledge in a machine friendly way.</li>
<li>RDF triple: A single sentence consisting of subject, predicate and object. Each element of the triple is an RDF node.</li>
<li>RDF quad: A single sentence consisting of subject, predicate, object, graph. Each element of the quad is an RDF term.</li>
<li><a href="https://www.w3.org/TR/rdf-primer/#rdfmodel">RDF graph</a>: A directed, labeled <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">graph</a> with RDF triples as edges.</li>
<li><a href="https://www.w3.org/TR/rdf-primer/#rdfmodel">RDF node</a></li>
<li>Composite Claim: An rdf triple which was infered, rather than stated explicitly in a credential.</li>
<li>Explicit <a href="https://en.wikipedia.org/wiki/Modes_of_persuasion#Ethos">Ethos</a> statement: A statement of the form "A claims X." where X is also a statement. Explicit Ethos is encodable in natural human languages as well as in RDF.</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>If you ever decide to implement your own algorithm to merge RDF graphs, remember that <a href="https://www.w3.org/TR/rdf11-concepts/#section-blank-nodes">blank nodes</a> exists and may need to be renamed depending on the type of graph representation in use.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p>The Dock Blockchain includes a module explicitly intended for proof of existence. Aside from being explicitly supported by the on-chain runtime, it works the same way you would expect. You post the hash of a document on-chain at a specific block. Later you can use that hash to prove the document existed at or before that block.</p>
<p>The PoE module accepts arbitrary bytes as an anchor but in order to keep anchor size constant the chain stores only the blake2b256 hash of those bytes.</p>
<p>Developers are free to use the anchoring module however they want, taloring their software to their own use case. An anchoring example can be found in the sdk examples directory. Dock provides a <a href="https://fe.dock.io/#/anchor/batch">fully functioning reference client</a> for anchoring. The client even implements batching anchors into a merkle tree so you can anchor multiple documents in a single transaction.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="private-delegation"><a class="header" href="#private-delegation">Private Delegation</a></h1>
<p>Claim Deduction rules can express delegation of authority to issue credentials! It's expected to be a common enough use case that Dock has declared some rdf vocabulary and associated claim deduction rules aid potential delegators.</p>
<p>An issuer may grant delegation authority to another issuer simply by issuing them a vcdm credential. Let's say <code>did:ex:a</code> wants to grant delegation authority to <code>did:ex:b</code>. <code>did:ex:a</code> simply issues the credential saying that <code>did:ex:b</code> may make any claim.</p>
<pre><code class="language-json">{
  "@context": [ "https://www.w3.org/2018/credentials/v1" ],
  "id": "urn:uuid:9b472d4e-492b-49f7-821c-d8c91e7fe767",
  "type": [ "VerifiableCredential" ],
  "issuer": "did:dock:a",
  "credentialSubject": {
    "id": "did:dock:b",
    "https://rdf.dock.io/alpha/2021#mayClaim": "https://rdf.dock.io/alpha/2021#ANYCLAIM"
  },
  "issuanceDate": "2021-03-18T19:23:24Z",
  "proof": { ... }
}
</code></pre>
<p>When <code>did:ex:b</code> wishes to issue a credential on behalf of <code>did:ex:a</code>, they should bundle it (e.g. in a presentation) with it this "delegation" credential. A delegation credential constitutes a proof of delegation. A proof of delegation bundled with a credential issued by the delegate can be prove that some statement[s] were made by authority of some root delegator.</p>
<p>In order to process delegated credentials a verifier accepts a bundle. The bundle includes both delegations and credentials issued by delegates. After verifying every credential within the bundle (including the delegations) the verifier uses <a href="concepts_claim_deduction.html">Claim Deduction</a> to determine which statements are proven by the delegated credential.</p>
<p>Dock's delegation ontology (i.e. rdf vocabulary) and ruleset are currently in alpha. See <a href="tutorial_private_delegation.html">Private Delegation</a> for an example of their use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="public-attestation"><a class="header" href="#public-attestation">Public Attestation</a></h1>
<p>This feature should be considered <em>Alpha</em>.</p>
<p><a href="https://github.com/docknetwork/planning/blob/master/rfc/0014-public-attestation.md">RFC</a></p>
<p>VCDM Verifiable credentials are a way to prove an <em>attestation</em>. Valid credentials prove statements of the form <code>Issuer claims X</code>, where <code>X</code> is itself a statement. One property of verifiable credentials is that the holder may keep them private simply by not sharing them with other parties. That property will be sometimes useful, sometimes not. VCDM crededentials are private and therefore not automatically discoverable but Public Attestations give a decentralized identity the ability to post claims that <em>are</em> discoverable by any party. For Dock DIDs, attestations are linked on-chain but Public Attestations are not specicfic to Dock. Other DID methods can implement public attestations by including them in DID documents.</p>
<p>Public Attestations are posted as RDF documents. Since RDF can represent, or link to, arbitrary types of data, Public Attestations can be used to publish arbitrary content.</p>
<h2 id="data-model"><a class="header" href="#data-model">Data Model</a></h2>
<p>Public Attestaions live in the DID document of their poster. A DID with a public attestation will have an extra property, "https://rdf.dock.io/alpha/2021#attestsDocumentContent". The value of that property is an IRI that is expected to point to an RDF document. Any statement contained in that document is considered to be a claim made by the DID.</p>
<p>If <code>DID attestsDocumentContent DOC</code> then for every statement <code>X</code> in <code>DOC</code> <code>DID claims X</code>.</p>
<p>Two IRI schemes are supported for pionting to attested documents: DIDs and ipfs links. DIDs are dereferenced and interpreted as <a href="https://www.w3.org/TR/json-ld/">json-ld</a>. Ipfs links are dereferenced and interpreted as <a href="https://www.w3.org/TR/turtle/">turtle</a> documents. The sdk makes it easy to dereferece DIDs and ipfs attestation documents but the Public Attestation concept is extendable to other types of IRI, like <a href="https://tools.ietf.org/html/draft-sporny-hashlink-06">hashlinks</a> or <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">data URIs</a>.</p>
<p>For Dock DIDs public attestation are made by <a href="https://github.com/docknetwork/sdk/blob/61cbaaf61e11cc8cc57d8582095bffafecd794b9/src/modules/did.js#L94">setting the attestation for the DID</a> on-chain. Changing the value of an attestation effectively revokes the previous attestation and issues a new one. A DIDs attestation can also be set to <code>None</code>, which is equivalent to attesting an empty claimgraph. Dock DIDs have their attestation set to <code>None</code> by default. A Dock DID with attestation set to <code>None</code> will not contain the <code>attestsDocumentContents</code> key.</p>
<h3 id="example-of-a-did-attesting-to-a-document-in-ipfs"><a class="header" href="#example-of-a-did-attesting-to-a-document-in-ipfs">Example of A DID attesting to a document in ipfs</a></h3>
<p><code>did:ex:ex</code>:</p>
<pre><code class="language-json">{
  "@context": "https://www.w3.org/ns/did/v1",
  "id": "did:ex:ex",
  "https://rdf.dock.io/alpha/2021#attestsDocumentContent": {
    "@id": "ipfs://Qmeg1Hqu2Dxf35TxDg19b7StQTMwjCqhWigm8ANgm8wA3p"
  }
}
</code></pre>
<p>Content of <code>ipfs://Qmeg1Hqu2Dxf35TxDg19b7StQTMwjCqhWigm8ANgm8wA3p</code>:</p>
<pre><code class="language-turtle">&lt;https://www.wikidata.org/wiki/Q25769&gt;
  &lt;https://www.wikidata.org/wiki/Property:P171&gt;
  &lt;https://www.wikidata.org/wiki/Q648422&gt; .
</code></pre>
<p>From these documents we can derive two facts. The first fact is encodeded directly in the DID document.</p>
<p>Fact 1:</p>
<pre><code class="language-turtle"># `did:ex:ed` attests to the content of `ipfs://Qmeg1..`
`&lt;did:ex:ed&gt; &lt;https://rdf.dock.io/alpha/2021#attestsDocumentContent&gt; &lt;ipfs://Qmeg1..&gt; .
</code></pre>
<p>The second fact is infered. Since we know the content of <code>ipfs://Qmeg1..</code> we know that <code>ipfs://Qmeg1..</code> contains the statement <code>wd:Q25769 wd:Property:P171 wd:Q648422</code> (Short-eared Owl is in the genus "Asio"). <code>did:ex:ex</code> attests the document <code>ipfs://Qmeg1..</code> and <code>ipfs://Qmeg1..</code> states that the Short-eared Owl is in the genus "Asio", therefore:</p>
<p>Fact 2:</p>
<pre><code class="language-turtle">@prefix wd: &lt;https://www.wikidata.org/wiki/&gt; .
# `did:ex:ex` claims that the Short-eared Owl is in the genus "Asio".
&lt;wd:Q25769&gt; &lt;wd:Property:P171&gt; &lt;wd:Q648422&gt; &lt;did:ex:ex&gt; .
</code></pre>
<h3 id="example-of-a-did-attesting-to-multiple-documents"><a class="header" href="#example-of-a-did-attesting-to-multiple-documents">Example of A DID attesting to multiple documents</a></h3>
<p>While it is valid DIDs to include multiple attested IRIs in a single DID document, Dock artificially limits the number of attestation to one per Dock DID. This is to encourage off-chain (ipfs) data storage. If a DID wishes to attests to multiple documents, there are two suggested options: 1) merge the two documents into a single document or 2) attest to a single document which in turn notes an <code>attestsDocumentContents</code> for each of it's children. The following is an example of option "2)".</p>
<p><code>did:ex:ex</code>:</p>
<pre><code class="language-json">{
  "@context": "https://www.w3.org/ns/did/v1",
  "id": "did:ex:ex",
  "https://rdf.dock.io/alpha/2021#attestsDocumentContent": {
    "@id": "ipfs://Qmeg1Hqu2Dxf35TxDg19b7StQTMwjCqhWigm8ANgm8wA3p"
  }
}
</code></pre>
<p><code>ipfs://Qmeg1Hqu2Dxf35TxDg19b7StQTMwjCqhWigm8ANgm8wA3p</code>:</p>
<pre><code class="language-turtle">&lt;did:ex:ex&gt;
  &lt;https://rdf.dock.io/alpha/2021#attestsDocumentContent&gt;
  &lt;ipfs://QmXoypizjW3WknFiJnLLwHCnL72vedxjQkDDP1mXWo6uco&gt; . # document1
&lt;did:ex:ex&gt;
  &lt;https://rdf.dock.io/alpha/2021#attestsDocumentContent&gt;
  &lt;ipfs://QmdycyxM3r882pHx3M63Xd8NUfsXoEmBnU8W6PgL9eY9cN&gt; . # document2
</code></pre>
<h2 id="uses"><a class="header" href="#uses">Uses</a></h2>
<p>Two properties of RDF have the potential to supercharge Public Attestations.</p>
<ol>
<li>It's a semantic knowlege representation, it can be <a href="https://github.com/docknetwork/rify">reasoned over</a>.</li>
<li>It's <a href="https://en.wikipedia.org/wiki/SPARQL">queryable</a> in it's native form.</li>
</ol>
<p>Via these properties the sdk implements a "Curious Agent". The Curious Agent seeks out information. It starts with an initial kernel of knowlege (an RDF dataset) and it follows a sense of curiosity, gradually building it's knowlege graph by dereferencing IRIs, stopping when it finds nothing new to be curious about. As it crawls, it reasons over the information it's found, deducing new facts, which may in turn spark new curiosity. The Curious Agent accepts it's curiosity as Sparql queries. The logical rules it uses to reason are also configurable, axioms are provided to the Agent as conjunctive if-then statements (like in <a href="./concepts_claim_deduction.html">Claim Deduction</a>). Within the sdk, the Curious Agent is simply called <code>crawl()</code>.</p>
<p>The Curious Agent is sometimes referred to as "the crawler".</p>
<p>The use-case that drove implementation of the crawler is to search for <a href="./concepts_public_delegation.html">publicaly posted Delegation information</a>. As such, a bare minimum of functionality is implemented by <code>crawl()</code>. Want more? Consider contacting us.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="public-delegation"><a class="header" href="#public-delegation">Public Delegation</a></h1>
<p>This feature should be considered <em>Alpha</em>.</p>
<p><a href="https://github.com/docknetwork/planning/blob/master/rfc/0013-public-delegation.md">RFC</a></p>
<p>We combine <a href="./concepts_private_delegation.html">Private Delegation</a> and <a href="./concepts_public_attestation.html">Public Attestation</a> to get Public Delegation.</p>
<p>When a delegation is attested via a credential, we call that a Private Delegation. As discussed in the <a href="./concepts_public_attestation.html">previous section</a>, attestations can be made in other ways. When a delegation is <a href="./concepts_public_attestation.html">attested publically</a> we call it a Public Delegation.</p>
<p>Public Delegations remove the need for credential holders to manage and present delegation chains. With Public Delegations, credential verifiers may look up delegation information out-of-band.</p>
<p>Just like in <a href="./concepts_private_delegation.html">Private Delegation</a>, verified delegation information constitutes a knowlege graph that can be merged with the knowlege graph from a verified credential. The merged graphs are reasoned over to determine facts that are proven true.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Let's say there is trusted root issuer, <code>did:ex:root</code>. <code>did:ex:root</code> may delegate authority to make claims on behalf of <code>did:ex:root</code>. To do so, <code>did:ex:root</code> would attest to a claimgraph like this one:</p>
<p><code>ipfs://Qmeg1Hqu2Dxf35TxDg19b7StQTMwjCqhWigm8ANgm8wA3p</code>:</p>
<pre><code class="language-turtle">@prefix dockalpha: &lt;https://rdf.dock.io/alpha/2021#&gt; .
&lt;did:ex:delegate1&gt; dockalpha:mayClaim dockalpha:ANYCLAIM .
&lt;did:ex:delegate2&gt; dockalpha:mayClaim dockalpha:ANYCLAIM .
</code></pre>
<p>When <code>did:ex:root</code> attests to the above triples, the following dataset is true.</p>
<pre><code class="language-turtle">@prefix dockalpha: &lt;https://rdf.dock.io/alpha/2021#&gt; .
&lt;did:ex:delegate1&gt; dockalpha:mayClaim dockalpha:ANYCLAIM &lt;did:ex:root&gt; .
&lt;did:ex:delegate2&gt; dockalpha:mayClaim dockalpha:ANYCLAIM &lt;did:ex:root&gt; .
</code></pre>
<p><code>did:ex:root</code> may attests to <code>ipfs://Qmeg1Hq...</code> by adding the ipfs link to its DID document.</p>
<pre><code class="language-json">{
  "@context": "https://www.w3.org/ns/did/v1",
  "id": "did:ex:root",
  "https://rdf.dock.io/alpha/2021#attestsDocumentContent": {
    "@id": "ipfs://Qmeg1Hqu2Dxf35TxDg19b7StQTMwjCqhWigm8ANgm8wA3p"
  }
}
</code></pre>
<p>By modifying its DID document to include the ipfs link <code>did:ex:root</code> attests to the delegation publically.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<ol>
<li><a href="./tutorial_did.html">DID</a></li>
<li><a href="./tutorial_revocation.html">Revocation</a></li>
<li><a href="./tutorial_ipv.html">Verifiable credentials</a></li>
<li><a href="./tutorial_blobs_schemas.html">Blobs and Schemas</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="did"><a class="header" href="#did">DID</a></h1>
<p>If you are not familiar with DIDs, you can get a conceptual overview <a href="./concepts_did.html">here</a>.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>DIDs in Dock are created by choosing a 32 byte unique (on Dock chain) identifier along with 1 ore more public keys or controllers.
The public key can be added or removed by the DID's controller (which the DID maybe itself) signature with a key having
<code>capabilityInvocation</code> verification relationship.</p>
<p>The DID can also be removed by providing a signature from the DID's controller.</p>
<p>The chain-state stores a few things for a DID, the active public keys, the controllers, service endpoints and the current nonce
of the DID. The nonce starts as the block number where the DID was created and each subsequent action like adding/removing a key
for itself or any DID it controls, adding a blob, etc should supply a nonce 1 higher than the previous one.</p>
<p>This is done for replay protection but this detail however is hidden in the API so the caller should not have to worry about this.</p>
<h2 id="did-creation"><a class="header" href="#did-creation">DID creation</a></h2>
<p>Create a new random DID.</p>
<pre><code class="language-js">import { DockDid } from "@docknetwork/credential-sdk/types";

const did = DockDid.random();
</code></pre>
<p>The DID is not yet registered on the chain. Before the DID can be registered, a public key needs to created as well.</p>
<h2 id="keypair-creation"><a class="header" href="#keypair-creation">Keypair creation</a></h2>
<p>We can create a random <code>ed25519</code> keypair using <code>Ed25519Keypair</code> class.</p>
<pre><code class="language-js">import { Ed25519Keypair } from "@docknetwork/credential-sdk/keypairs";

const kp = Ed25519Keypair.random();
</code></pre>
<p>The result pair can be used as following:</p>
<pre><code class="language-javascript">const publicKey = kp.publicKey();
const privateKey = kp.privateKey();

const message = Uint8Array.from([1, 2, 3]);
const signature = kp.sign(message);

const verified = Ed25519Keypair.verify(message, signature, publicKey);
</code></pre>
<h2 id="registering-a-new-did-on-chain"><a class="header" href="#registering-a-new-did-on-chain">Registering a new DID on chain</a></h2>
<p>Now that you have a DID and a public key, the DID can be registered on the Dock chain. Note that this public key associated
with DID is independent of the key used for sending the transaction and paying the fees.</p>
<h3 id="self-controlled-dids"><a class="header" href="#self-controlled-dids">Self-controlled DIDs</a></h3>
<p>In most cases, a DID will have its own keys and will control itself, i.e. a self-controlled DID. Following is an example of DID creation in this scenario.</p>
<ol>
<li>
<p>First, create a <code>DidKeypair</code> object. The first argument is a DID reference and the second is the underlying keypair.</p>
<pre><code class="language-js">import { DidKeypair } from "@docknetwork/credential-sdk/keypair";

const didKeypair = new DidKeypair([did, 1], kp);
</code></pre>
</li>
<li>
<p>Second, let's get a did key with verication relationship from the did's keypair. The only argument is
the verification relationship. A verification relationship can be 1 or more of these <code>authentication</code>, <code>assertion</code>, <code>capabilityInvocation</code> or <code>keyAgreement</code></p>
<pre><code class="language-js">const didKey = didKeypair.didKey();
</code></pre>
</li>
<li>
<p>Now submit the transaction using a <code>DockAPI</code> object and the newly created DID <code>did</code> and <code>didKey</code>.</p>
<pre><code class="language-js">const document = DIDDocument.create(did, [didKey]);
await dock.did.createDocument(document, didKeypair);
</code></pre>
</li>
</ol>
<h3 id="keyless-dids"><a class="header" href="#keyless-dids">Keyless DIDs</a></h3>
<p>A DID might not have any keys and thus be controlled by other DIDs. Assuming a DID <code>did</code> already exists, it can register a
keyless DID <code>did2</code> as</p>
<pre><code class="language-js">const document = DIDDocument.create(did2);
await dock.did.createDocument(document, didKeypair);
</code></pre>
<p>Moreover, a DID can have keys for certain functions like authentication but still be controlled by other DID(s).</p>
<h2 id="fetching-a-did-from-chain"><a class="header" href="#fetching-a-did-from-chain">Fetching a DID from chain</a></h2>
<p>To get a DID document, use <code>getDocument</code></p>
<pre><code class="language-js">const result = await dock.did.getDocument(did);
</code></pre>
<h2 id="adding-a-key-to-an-existing-did"><a class="header" href="#adding-a-key-to-an-existing-did">Adding a key to an existing DID</a></h2>
<p>A DID's controller can add a public key to an on-chain DID by preparing a signed payload. Each new key is given a number key index
which 1 is greater than the last used index. Key indices start from 1.</p>
<ol>
<li>Create a new public key and use the current keypair to sign the message
<pre><code class="language-js">// the current pair, its a sr25519 in this example
const newKp = Ed25519Keypair.random();
</code></pre>
</li>
<li>Now send the signed payload in a transaction to the chain in a transaction.
In the arguments, the first <code>did</code> specifies that a key must be added to DID <code>did</code> and the second <code>did</code> specifies that DID <code>did</code> is signing the payload.
<pre><code class="language-js">const document = await dock.did.getDocument(did);
document.addKey([did, 2], newKp.didKey());
await dock.did.updateDocument(document, didKeypair);
</code></pre>
</li>
</ol>
<h2 id="removing-an-existing-did-from-chain"><a class="header" href="#removing-an-existing-did-from-chain">Removing an existing DID from chain</a></h2>
<p>A DID can be removed from the chain by sending the corresponding message signed with an appropriate key.</p>
<ol>
<li>Now send the message with the signature to the chain in a transaction
<pre><code class="language-js">dock.did.removeDocument(did, didKeypair);
</code></pre>
</li>
</ol>
<p>For more details see example in <code>examples/dock-did.js</code> or the integration tests.</p>
<p>Note that they accounts used to send the transactions are independent of the keys associated with the DID.</p>
<p>So the DID could have been created with one account, updated with another account and removed with another account.</p>
<p>The accounts are not relevant in the data model and not associated with the DID in the chain-state.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="did-resolver"><a class="header" href="#did-resolver">DID resolver</a></h1>
<p>The process of learning the DID Document of a DID is called DID resolution and tool that does the resolution is called the
resolver.</p>
<p>Resolution involves looking at the DID method and then fetching the DID Document from the registry, the registry
might be a centralized database or a blockchain.</p>
<p>The SDK supports resolving Dock DIDs natively. For other DIDs, resolving the DID through the
<a href="https://uniresolver.io">Universal Resolver</a> is supported.</p>
<p>Each resolver should extend the class <code>DIDResolver</code> and implement the <code>resolve</code> method that accepts a DID and returns the
DID document.</p>
<p>There is another class called <code>MultiResolver</code> that can accept several types of resolvers (objects of subclasses
of <code>DIDResolver</code>) and once the <code>MultiResolver</code> is initialized with the resolvers of different DID methods, it can resolve
DIDs of those methods.</p>
<h2 id="dock-resolver"><a class="header" href="#dock-resolver">Dock resolver</a></h2>
<p>The resolver for Dock DIDs <code>DockResolver</code> connects to the Dock blockchain to get the DID details.</p>
<p>The resolver is constructed by passing it a Dock API object so that it can connect to a Dock node.
This is how you resolve a Dock DID:</p>
<pre><code class="language-js">import { DockResolver } from "@docknetwork/sdk/resolver";

// Assuming the presence of Dock API object `dock`
const dockResolver = new DockResolver(dock);
// Say you had a DID `did:dock:5D.....`
const didDocument = dockResolver.resolve("did:dock:5D.....");
</code></pre>
<h2 id="creating-a-resolver-class-for-a-different-method"><a class="header" href="#creating-a-resolver-class-for-a-different-method">Creating a resolver class for a different method</a></h2>
<p>If you want to resolve DIDs other than Dock and do not have/want access to the universal resolver, you can extend the
<code>DIDResolver</code> class to derive a custom resolver.</p>
<p>Following is an example to build a custom Ethereum resolver. It uses the library
<a href="https://github.com/decentralized-identity/ethr-did-resolver">ethr-did-resolver</a> and accepts a provider information
as configuration. The example below uses Infura to get access to an Ethereum node and read the DID off Ethereum.</p>
<pre><code class="language-js">import { DIDResolver } from "@docknetwork/sdk/resolver";
import ethr from "ethr-did-resolver";

// Infura's Ethereum provider for the main net.
const ethereumProviderConfig = {
  networks: [
    {
      name: "mainnet",
      rpcUrl: "https://mainnet.infura.io/v3/blahblahtoken",
    },
  ],
};

// Custom ethereum resolver class
class EtherResolver extends DIDResolver {
  static METHOD = "ethr";

  constructor(config) {
    super();
    this.ethres = ethr.getResolver(config).ethr;
  }

  async resolve(did) {
    const parsed = this.parseDid(did);
    try {
      return this.ethres(did, parsed);
    } catch (e) {
      throw new NoDIDError(did);
    }
  }
}

// Construct the resolver
const ethResolver = new EtherResolver(ethereumProviderConfig);

// Say you had a DID `did:ethr:0x6f....`
const didDocument = ethResolver.resolve("did:ethr:0x6f....");
</code></pre>
<h2 id="universal-resolver"><a class="header" href="#universal-resolver">Universal resolver</a></h2>
<p>To resolve DIDs using the <a href="https://uniresolver.io">Universal Resolver</a>, use the <code>UniversalResolver</code>. It needs the URL
of the universal resolver and assumes the universal resolver from this <a href="https://github.com/decentralized-identity/universal-resolver">codebase</a>
is running at the URL.</p>
<pre><code class="language-js">import { UniversalResolver } from "@docknetwork/sdk/resolver";

// Change the resolver URL to something else in case you cannot use the resolver at https://uniresolver.io
const universalResolverUrl = "https://uniresolver.io";
const universalResolver = new UniversalResolver(universalResolverUrl);

// Say you had a DID `did:btcr:xk....`
const didDocument = universalResolver.resolve("did:btcr:xk....");
</code></pre>
<h2 id="resolving-dids-of-several-did-methods-with-a-single-resolver"><a class="header" href="#resolving-dids-of-several-did-methods-with-a-single-resolver">Resolving DIDs of several DID methods with a single resolver</a></h2>
<p>In case you need to resolve DIDs from more than one method, a <code>DIDResolver</code> can be created by passing
resolvers of various DID methods to the derived class constructor.</p>
<p>The derived <code>DIDResolver</code> without overriden <code>resolve</code> accepts a list of resolvers each of which
will be dispatched according to their prefix and method configuration. The <code>resolvers</code> array below
has resolvers for DID methods <code>dock</code> and <code>ethr</code>.</p>
<p>For resolving DID of any other method, <code>UniversalResolver</code> object will be used.</p>
<pre><code class="language-js">import {
  DockDIDResolver,
  DIDResolver,
  WILDCARD,
} from "@docknetwork/sdk/resolver";

class MultiDIDResolver extends DIDResolver {
  static METHOD = WILDCARD;

  constructor(dock) {
    super([
      new DockDIDResolver(dock),
      new EtherResolver(ethereumProviderConfig),
      new UniversalResolver(universalResolverUrl),
    ]);
  }
}

const multiResolver = new MultiDIDResolver(resolvers);

// Say you had a DID `did:dock:5D....`, then the `DockResolver` will be used as there a resolver for Dock DID.
const didDocumentDock = multiResolver.resolve("did:dock:5D....");

// Say you had a DID `did:btcr:xk....`, then the `UniversalResolver` will be used as there is no resolver for BTC DID.
const didDocumentBtc = multiResolver.resolve("did:btcr:xk....");
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verifiable-credentials-and-verifiable-presentations-issuing-signing-and-verification"><a class="header" href="#verifiable-credentials-and-verifiable-presentations-issuing-signing-and-verification">Verifiable Credentials and Verifiable Presentations: issuing, signing and verification</a></h1>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of contents</a></h2>
<ul>
<li><a href="tutorial_ipv.html#incremental-creation-and-verification-of-verifiable-credentials">Incremental creation and verification of VC</a>
<ul>
<li><a href="tutorial_ipv.html#building-a-verifiable-credential">Building a Verifiable Credential</a>
<ul>
<li><a href="tutorial_ipv.html#adding-a-context">Adding a Context</a></li>
<li><a href="tutorial_ipv.html#adding-a-type">Adding a Type</a></li>
<li><a href="tutorial_ipv.html#adding-a-subject">Adding a Subject</a></li>
<li><a href="tutorial_ipv.html#setting-a-status">Setting a Status</a></li>
<li><a href="tutorial_ipv.html#setting-the-issuance-date">Setting the Issuance Date</a></li>
<li><a href="tutorial_ipv.html#setting-an-expiration-date">Setting an Expiration Date</a></li>
</ul>
</li>
<li><a href="tutorial_ipv.html#signing-a-verifiable-credential">Signing a Verifiable Credential</a></li>
<li><a href="tutorial_ipv.html#verifying-a-verifiable-credential">Verifying a Verifiable Credential</a></li>
</ul>
</li>
<li><a href="tutorial_ipv.html#incremental-creation-and-verification-of-verifiable-presentations">Incremental creation and verification of VP</a>
<ul>
<li><a href="tutorial_ipv.html#building-a-verifiable-presentation">Building a Verifiable Presentation</a>
<ul>
<li><a href="tutorial_ipv.html#adding-a-context">Adding a Context</a></li>
<li><a href="tutorial_ipv.html#adding-a-type">Adding a Type</a></li>
<li><a href="tutorial_ipv.html#setting-a-holder">Setting a Holder</a></li>
<li><a href="tutorial_ipv.html#adding-a-verifiable-credential">Adding a Verifiable Credential</a></li>
</ul>
</li>
<li><a href="tutorial_ipv.html#signing-a-verifiable-presentation">Signing a Verifiable Presentation</a></li>
<li><a href="tutorial_ipv.html#verifying-a-verifiable-presentation">Verifying a Verifiable Presentation</a></li>
</ul>
</li>
<li><a href="tutorial_ipv.html#using-dids">Using DIDs</a></li>
<li><a href="tutorial_ipv.html#creating-a-keydoc">Creating a keyDoc</a></li>
</ul>
<hr />
<h2 id="incremental-creation-and-verification-of-verifiable-credentials"><a class="header" href="#incremental-creation-and-verification-of-verifiable-credentials">Incremental creation and verification of Verifiable Credentials</a></h2>
<p>The <code>client-sdk</code> exposes a <code>VerifiableCredential</code> class that is useful to incrementally create valid Verifiable Credentials of any type, sign them and verify them.
Once the credential is initialized, you can sequentially call the different methods provided by the class to add contexts, types, issuance dates and everything else.</p>
<h3 id="building-a-verifiable-credential"><a class="header" href="#building-a-verifiable-credential">Building a Verifiable Credential</a></h3>
<p>The first step to build a Verifiable Credential is to initialize it, we can do that using the <code>VerifiableCredential</code> class constructor which takes a <code>credentialId</code> as sole argument:</p>
<pre><code class="language-javascript">let vc = new VerifiableCredential("http://example.edu/credentials/2803");
</code></pre>
<p>You now have an unsigned Verifiable Credential in the <code>vc</code> variable!
This Credential isn't signed since we only just initialized it. It brings however some useful defaults to make your life easier.</p>
<pre><code class="language-javascript">&gt;    vc.context
&lt;-   ["https://www.w3.org/2018/credentials/v1"]
&gt;    vc.issuanceDate
&lt;-   "2020-04-14T14:48:48.486Z"
&gt;    vc.type
&lt;-   ["VerifiableCredential"]
&gt;    vc.credentialSubject
&lt;-   []
</code></pre>
<p>The default <code>context</code> is an array with
<code>"https://www.w3.org/2018/credentials/v1"</code> as first element. This is required
by the VCDMv1 specs so having it as default helps ensure your Verifiable
Credentials will be valid in the end.</p>
<p>A similar approach was taken on the <code>type</code> property, where the default is an
array with <code>"VerifiableCredential"</code> already populated. This is also required
by the specs. The <code>subject</code> property is required to exist, so this is already
initialized for you as well although it is empty for now. Finally the
<code>issuanceDate</code> is also set to the moment you initialized the
<code>VerifiableCredential</code> object. You can change this later if desired but it
helps having it in the right format from the get go.</p>
<p>We could also have checked those defaults more easily by checking the
Verifiable Credential's JSON representation.</p>
<p>This can be achieved by calling the <code>toJSON()</code> method on it:</p>
<pre><code class="language-javascript">&gt;    vc.toJSON()
&lt;-   {
       "@context": [ "https://www.w3.org/2018/credentials/v1" ],
       "credentialSubject": [],
       "id": "http://example.edu/credentials/2803",
       "type": [
         "VerifiableCredential"
       ],
       "issuanceDate": "2020-04-14T14:48:48.486Z"
     }
</code></pre>
<p>An interesting thing to note here is the transformation happening to some of
the root level keys in the JSON representation of a <code>VerifiableCredential</code>
object.</p>
<p>For example <code>context</code> gets transformed into <code>@context</code> and <code>subject</code>
into <code>credentialSubject</code>.</p>
<p>This is to ensure compliance with the Verifiable Credential Data Model specs
while at the same time providing you with a clean interface to the
<code>VerifiableCredential</code> class in your code.</p>
<p>Once your Verifiable Credential has been initialized, you can proceed to use
the rest of the building functions to define it completely before finally
signing it.</p>
<h4 id="adding-a-context"><a class="header" href="#adding-a-context">Adding a Context</a></h4>
<p>A context can be added with the <code>addContext</code> method. It accepts a single argument <code>context</code> which can either be a string (in which case it needs to be a valid URI), or an object:</p>
<pre><code class="language-javascript">&gt;   vc.addContext('https://www.w3.org/2018/credentials/examples/v1')
&gt;   vc.context
&lt;-  [
      'https://www.w3.org/2018/credentials/v1',
      'https://www.w3.org/2018/credentials/examples/v1'
    ])
</code></pre>
<h4 id="adding-a-type"><a class="header" href="#adding-a-type">Adding a Type</a></h4>
<p>A type can be added with the <code>addType</code> function. It accepts a single argument <code>type</code> that needs to be a string:</p>
<pre><code class="language-javascript">&gt;   vc.addType('AlumniCredential')
&gt;   vc.type
&lt;-  [
      'VerifiableCredential',
      'AlumniCredential'
    ]
</code></pre>
<h4 id="adding-a-subject"><a class="header" href="#adding-a-subject">Adding a Subject</a></h4>
<p>A subject can be added with the <code>addSubject</code> function. It accepts a single argument <code>subject</code> that needs to be an object with an <code>id</code> property:</p>
<pre><code class="language-javascript">&gt;   vc.addSubject({ id: 'did:dock:123qwe123qwe123qwe', alumniOf: 'Example University' })
&gt;   vc.credentialSubject
&lt;-  {id: 'did:dock:123qwe123qwe123qwe', alumniOf: 'Example University'}
</code></pre>
<h4 id="setting-a-status"><a class="header" href="#setting-a-status">Setting a Status</a></h4>
<p>A status can be set with the <code>setStatus</code> function. It accepts a single argument <code>status</code> that needs to be an object with an <code>id</code> property:</p>
<pre><code class="language-javascript">&gt;   vc.setStatus({ id: "https://example.edu/status/24", type: "CredentialStatusList2017" })
&gt;   vc.status
&lt;-  {
        "id": "https://example.edu/status/24",
        "type": "CredentialStatusList2017"
    }
</code></pre>
<h4 id="setting-the-issuance-date"><a class="header" href="#setting-the-issuance-date">Setting the Issuance Date</a></h4>
<p>The issuance date is set by default to the datetime you first initialize your
<code>VerifiableCredential</code> object.</p>
<p>This means that you don't necessarily need to
call this method to achieve a valid Verifiable Credential (which are required
to have an issuanceDate property).</p>
<p>However, if you need to change this date you can use the <code>setIssuanceDate</code>
method. It takes a single argument <code>issuanceDate</code> that needs to be a string
with a valid ISO formatted datetime:</p>
<pre><code class="language-javascript">&gt;   vc.issuanceDate
&lt;-  "2020-04-14T14:48:48.486Z"
&gt;   vc.setIssuanceDate("2019-01-01T14:48:48.486Z")
&gt;   vc.issuanceDate
&lt;-  "2019-01-01T14:48:48.486Z"
</code></pre>
<h4 id="setting-an-expiration-date"><a class="header" href="#setting-an-expiration-date">Setting an Expiration Date</a></h4>
<p>An expiration date is not set by default as it isn't required by the specs.
If you wish to set one, you can use the <code>setExpirationDate</code> method.</p>
<p>It takes a single argument <code>expirationDate</code> that needs to be a string with a
valid ISO formatted datetime:</p>
<pre><code class="language-javascript">&gt;   vc.setExpirationDate("2029-01-01T14:48:48.486Z")
&gt;   vc.expirationDate
&lt;-  "2029-01-01T14:48:48.486Z"
</code></pre>
<h3 id="signing-a-verifiable-credential"><a class="header" href="#signing-a-verifiable-credential">Signing a Verifiable Credential</a></h3>
<p>Once you've crafted your Verifiable Credential it is time to sign it. This
can be achieved with the <code>sign</code> method.</p>
<p>It requires a <code>keyDoc</code> parameter (an object with the params and keys you'll
use for signing) and it also accepts a boolean <code>compactProof</code> that determines
whether you want to compact the JSON-LD or not:</p>
<pre><code class="language-javascript">&gt;   await vc.sign(keyDoc)
</code></pre>
<p>Please note that signing is an async process.
Once done, your <code>vc</code> object will have a new <code>proof</code> field:</p>
<pre><code class="language-javascript">&gt;   vc.proof
&lt;-  {
        type: "EcdsaSecp256k1Signature2019",
        created: "2020-04-14T14:48:48.486Z",
        jws: "eyJhbGciOiJFUzI1NksiLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ..MEQCIAS8ZNVYIni3oShb0TFz4SMAybJcz3HkQPaTdz9OSszoAiA01w9ZkS4Zx5HEZk45QzxbqOr8eRlgMdhgFsFs1FnyMQ",
        proofPurpose: "assertionMethod",
        verificationMethod: "https://gist.githubusercontent.com/faustow/13f43164c571cf839044b60661173935/raw"
    }
</code></pre>
<h3 id="verifying-a-verifiable-credential"><a class="header" href="#verifying-a-verifiable-credential">Verifying a Verifiable Credential</a></h3>
<p>Once your Verifiable Credential has been signed you can proceed to verify it
with the <code>verify</code> method. The <code>verify</code> method takes an object of arguments,
and is optional.</p>
<p>If you've used DIDs you need to pass a <code>resolver</code> for them.
You can also use the booleans <code>compactProof</code> (to compact the JSON-LD).</p>
<p>If your credential has uses the <code>credentialStatus</code> field, the credential will be checked
not to be revoked unless you pass <code>skipRevocationCheck</code> flag.</p>
<pre><code class="language-javascript">&gt;   const result = await vc.verify({ ... })
&gt;   result
&lt;-  {
      verified: true,
      results: [
        {
          proof: [
            {
                '@context': 'https://w3id.org/security/v2',
                type: "EcdsaSecp256k1Signature2019",
                created: "2020-04-14T14:48:48.486Z",
                jws: "eyJhbGciOiJFUzI1NksiLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ..MEQCIAS8ZNVYIni3oShb0TFz4SMAybJcz3HkQPaTdz9OSszoAiA01w9ZkS4Zx5HEZk45QzxbqOr8eRlgMdhgFsFs1FnyMQ",
                proofPurpose: "assertionMethod",
                verificationMethod: "https://gist.githubusercontent.com/faustow/13f43164c571cf839044b60661173935/raw"
            }
          ],
          verified: true
        }
      ]
    }
</code></pre>
<p>Please note that the verification is an async process that returns an object
when the promise resolves. A boolean value for the entire verification
process can be checked at the root level <code>verified</code> property.</p>
<hr />
<h2 id="incremental-creation-and-verification-of-verifiable-presentations"><a class="header" href="#incremental-creation-and-verification-of-verifiable-presentations">Incremental creation and verification of Verifiable Presentations</a></h2>
<p>The <code>client-sdk</code> exposes a <code>VerifiablePresentation</code> class that is useful to
incrementally create valid Verifiable Presentations of any type, sign them
and verify them.</p>
<p>Once the presentation is initialized, you can sequentially call the different
methods provided by the class to add <code>contexts</code>, <code>types</code>, <code>holders</code> and
<code>credentials</code>.</p>
<h3 id="building-a-verifiable-presentation"><a class="header" href="#building-a-verifiable-presentation">Building a Verifiable Presentation</a></h3>
<p>The first step to build a Verifiable Presentation is to initialize it, we can
do that using the <code>VerifiablePresentation</code> class constructor which takes an
<code>id</code> as sole argument:</p>
<pre><code class="language-javascript">let vp = new VerifiablePresentation("http://example.edu/credentials/1986");
</code></pre>
<p>You now have an unsigned Verifiable Presentation in the <code>vp</code> variable!</p>
<p>This Presentation isn't signed since we only just initialized it. It brings
however some useful defaults to make your life easier.</p>
<pre><code class="language-javascript">&gt;    vp.context
&lt;-   ["https://www.w3.org/2018/credentials/v1"]
&gt;    vp.type
&lt;-   ["VerifiablePresentation"]
&gt;    vp.credentials
&lt;-   []
</code></pre>
<p>The default <code>context</code> is an array with
<code>"https://www.w3.org/2018/credentials/v1"</code> as first element. This is required
by the VCDMv1 specs so having it as default helps ensure your Verifiable
Presentations will be valid in the end.</p>
<p>A similar approach was taken on the <code>type</code> property, where the default is an
array with <code>"VerifiablePresentation"</code> already populated. This is also
required by the specs.</p>
<p>The <code>credentials</code> property is required to exist, so this is already
initialized for you as well although it is empty for now.</p>
<p>We could also have checked those defaults more easily by checking the
Verifiable Presentation's JSON representation.</p>
<p>This can be achieved by calling the <code>toJSON()</code> method on it:</p>
<pre><code class="language-javascript">&gt;    vp.toJSON()
&lt;-   {
       "@context": [ "https://www.w3.org/2018/credentials/v1" ],
       "id": "http://example.edu/credentials/1986",
       "type": [
         "VerifiablePresentation"
       ],
       "verifiableCredential": [],
     }
</code></pre>
<p>An interesting thing to note here is the transformation happening to some of
the root level keys in the JSON representation of a <code>VerifiablePresentation</code>
object.</p>
<p>For example <code>context</code> gets transformed into <code>@context</code> and <code>credentials</code> into
<code>verifiableCredential</code>. This is to ensure compliance with the Verifiable
Credentials Data Model specs while at the same time providing you with a
clean interface to the <code>VerifiablePresentation</code> class in your code.</p>
<p>Once your Verifiable Presentation has been initialized, you can proceed to
use the rest of the building functions to define it completely before finally
signing it.</p>
<h4 id="adding-a-context-1"><a class="header" href="#adding-a-context-1">Adding a Context</a></h4>
<p>A context can be added with the <code>addContext</code> method. It accepts a single
argument <code>context</code> which can either be a string (in which case it needs to be
a valid URI), or an object</p>
<pre><code class="language-javascript">&gt;   vp.addContext('https://www.w3.org/2018/credentials/examples/v1')
&gt;   vp.context
&lt;-  [
      'https://www.w3.org/2018/credentials/v1',
      'https://www.w3.org/2018/credentials/examples/v1'
    ])
</code></pre>
<h4 id="adding-a-type-1"><a class="header" href="#adding-a-type-1">Adding a Type</a></h4>
<p>A type can be added with the <code>addType</code> function. It accepts a single argument <code>type</code> that needs to be a string:</p>
<pre><code class="language-javascript">&gt;   vp.addType('CredentialManagerPresentation')
&gt;   vp.type
&lt;-  [
      'VerifiablePresentation',
      'CredentialManagerPresentation'
    ]
</code></pre>
<h4 id="setting-a-holder"><a class="header" href="#setting-a-holder">Setting a Holder</a></h4>
<p>Setting a Holder is optional and it can be achieved using the <code>setHolder</code>
method. It accepts a single argument <code>type</code> that needs to be a string (a URI
for the entity that is generating the presentation):</p>
<pre><code class="language-javascript">&gt;   vp.setHolder('https://example.com/credentials/1234567890');
&gt;   vp.holder
&lt;-  'https://example.com/credentials/1234567890'
</code></pre>
<h4 id="adding-a-verifiable-credential"><a class="header" href="#adding-a-verifiable-credential">Adding a Verifiable Credential</a></h4>
<p>Your Verifiable Presentations can contain one or more Verifiable Credentials inside.</p>
<p>Adding a Verifiable Credential can be achieved using the <code>addCredential</code>
method. It accepts a single argument <code>credential</code> that needs to be an object
(a valid, signed Verifiable Credential):</p>
<pre><code class="language-javascript">&gt;   vp.addCredential(vc);
&gt;   vp.credentials
&lt;-  [
      {...}
    ]
</code></pre>
<p>Please note that the example was truncated to enhance readability.</p>
<h3 id="signing-a-verifiable-presentation"><a class="header" href="#signing-a-verifiable-presentation">Signing a Verifiable Presentation</a></h3>
<p>Once you've crafted your Verifiable Presentation and added your Verifiable
Credentials to it, it is time to sign it.</p>
<p>This can be achieved with the <code>sign</code> method. It requires a <code>keyDoc</code> parameter
(an object with the params and keys you'll use for signing), and a
<code>challenge</code> string for the proof.</p>
<p>It also accepts a <code>domain</code> string for the proof, a <code>resolver</code> in case you're
using DIDs and a boolean <code>compactProof</code> that determines whether you want to
compact the JSON-LD or not:</p>
<pre><code class="language-javascript">&gt;   await vp.sign(
          keyDoc,
          'some_challenge',
          'some_domain',
        );
</code></pre>
<p>Please note that signing is an async process.
Once done, your <code>vp</code> object will have a new <code>proof</code> field:</p>
<pre><code class="language-javascript">&gt;   vp.proof
&lt;-  {
      "type": "EcdsaSecp256k1Signature2019",
      "created": "2020-04-14T20:57:01Z",
      "challenge": "some_challenge",
      "domain": "some_domain",
      "jws": "eyJhbGciOiJFUzI1NksiLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ..MEUCIQCTTpivdcTKFDNdmzqe3l0nV6UjXgv0XvzCge--CTAV6wIgWfLqn_62U8jHkNSujrHFRmJ_ULj19b5rsNtjum09vbg",
      "proofPurpose": "authentication",
      "verificationMethod": "https://gist.githubusercontent.com/faustow/13f43164c571cf839044b60661173935/raw"
    }
</code></pre>
<h3 id="verifying-a-verifiable-presentation"><a class="header" href="#verifying-a-verifiable-presentation">Verifying a Verifiable Presentation</a></h3>
<p>Once your Verifiable Presentation has been signed you can proceed to verify
it with the <code>verify</code> method.</p>
<p>If you've used DIDs you need to pass a <code>resolver</code> for them. You can also use
the booleans <code>compactProof</code> (to compact the JSON-LD).</p>
<p>If your credential uses the <code>credentialStatus</code> field, the credential will be checked to be not revoked unless you pass <code>skipRevocationCheck</code>.
For the simplest cases you only need a <code>challenge</code> string and possibly a
<code>domain</code> string:</p>
<pre><code class="language-javascript">&gt;   const results = await vp.verify({ challenge: 'some_challenge', domain: 'some_domain' });
&gt;   results
&lt;-  {
      "presentationResult": {
        "verified": true,
        "results": [
          {
            "proof": {
              "@context": "https://w3id.org/security/v2",
              "type": "EcdsaSecp256k1Signature2019",
              "created": "2020-04-14T20:57:01Z",
              "challenge": "some_challenge",
              "domain": "some_domain",
              "jws": "eyJhbGciOiJFUzI1NksiLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ..MEUCIQCTTpivdcTKFDNdmzqe3l0nV6UjXgv0XvzCge--CTAV6wIgWfLqn_62U8jHkNSujrHFRmJ_ULj19b5rsNtjum09vbg",
              "proofPurpose": "authentication",
              "verificationMethod": "https://gist.githubusercontent.com/faustow/13f43164c571cf839044b60661173935/raw"
            },
            "verified": true
          }
        ]
      },
      "verified": true,
      "credentialResults": [
        {
          "verified": true,
          "results": [
            {
              "proof": {
                "@context": "https://w3id.org/security/v2",
                "type": "EcdsaSecp256k1Signature2019",
                "created": "2020-04-14T20:49:00Z",
                "jws": "eyJhbGciOiJFUzI1NksiLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ..MEUCIQCCCRuJbSUPePpOfkxsMJeQAqpydOFYWsA4cGiQRAR_QQIgehRZh8XE24hV0TPl5bMS6sNeKtC5rwZGfmflfY0eS-Y",
                "proofPurpose": "assertionMethod",
                "verificationMethod": "https://gist.githubusercontent.com/faustow/13f43164c571cf839044b60661173935/raw"
              },
              "verified": true
            }
          ]
        }
      ]
    }
</code></pre>
<p>Please note that the verification is an async process that returns an object
when the promise resolves.</p>
<p>This object contains separate results for the verification processes of the
included Verifiable Credentials and the overall Verifiable Presentation.</p>
<p>A boolean value for the entire verification process can be checked at the
root level <code>verified</code> property.</p>
<h2 id="using-dids"><a class="header" href="#using-dids">Using DIDs</a></h2>
<p>The examples shown above use different kinds of URIs as <code>id</code> property of
different sections. It is worth mentioning that the use of DIDs is not only
supported but also encouraged.</p>
<p>Their usage is very simple: create as many DIDs as you need and then use them instead of the URIs shown above.</p>
<p>For example when adding a subject to a Verifiable Credential here we're using a DID instead of a regular URI in the <code>id</code> property of the object:<code>vc.addSubject({ id: 'did:dock:123qwe123qwe123qwe', alumniOf: 'Example University' })</code>.</p>
<p>If you don't know how to create a DID there's a specific <a href="tutorial_did.html">tutorial on DIDs</a> you can read.</p>
<p>Bear in mind that you will need to provide a <code>resolver</code> method if you decide to use DIDs in your Verifiable Credentials or Verifiable Presentations. More on resolvers can be found in the <a href="tutorial_resolver.html">tutorial on Resolvers</a>.</p>
<p>Here's an example of issuing a Verifiable Credential using DIDs, provided that you've created and a DID that you store in <code>issuerDID</code>:</p>
<pre><code class="language-javascript">const issuerKey = getKeyDoc(
  issuerDID,
  dock.keyring.addFromUri(issuerSeed, null, "ed25519"),
  "Ed25519VerificationKey2018"
);
await vc.sign(issuerKey);
const verificationResult = await signedCredential.verify({
  resolver,
  compactProof: true,
});
console.log(verificationResult.verified); // Should print `true`
</code></pre>
<h2 id="creating-a-keydoc"><a class="header" href="#creating-a-keydoc">Creating a keyDoc</a></h2>
<p>It can be seen from the above examples that signing of credentials and
presentations require keypairs to be formatted into a <code>keyDoc</code> object.</p>
<p>There is a helper function to help with this formatting, it's called
<code>getKeyDoc</code> and it is located in the <code>vc</code> helpers.</p>
<p>Its usage is very simple, it accepts a <code>did</code> string which is a DID in fully
qualified form, a <code>keypair</code> object (generated by either using polkadot-js's
keyring for Sr25519 and Ed25519 or keypair generated with
<code>generateEcdsaSecp256k1Keypair</code> for curve secp256k1)
and a <code>type</code> string containing the type of the provided key (one of the
supported 'Sr25519VerificationKey2020', 'Ed25519VerificationKey2018' or
'EcdsaSecp256k1VerificationKey2019'):</p>
<pre><code class="language-javascript">const keyDoc = getKeyDoc(did, keypair, type);
</code></pre>
<p>Please check the example on the <a href="tutorial_ipv.html#using-dids">previous section</a> or refer to the <a href="../../tests/integration/presenting.test.js">presenting integration tests</a> for a live example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="revocation-1"><a class="header" href="#revocation-1">Revocation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schemas-1"><a class="header" href="#schemas-1">Schemas</a></h1>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of contents</a></h2>
<ol>
<li><a href="tutorial_blobs_schemas.html#intro">Intro</a></li>
<li><a href="tutorial_blobs_schemas.html#blobs">Blobs</a>
<ol>
<li><a href="tutorial_blobs_schemas.html#writing-a-blob">Writing a Blob</a></li>
<li><a href="tutorial_blobs_schemas.html#reading-a-blob">Reading a Blob</a></li>
</ol>
</li>
<li><a href="tutorial_blobs_schemas.html#blobs">Schemas</a>
<ol>
<li><a href="tutorial_blobs_schemas.html#creating-a-schema">Creating a Schema</a></li>
<li><a href="tutorial_blobs_schemas.html#writing-a-schema-to-the-dock-chain">Writing a Schema</a></li>
<li><a href="tutorial_blobs_schemas.html#reading-a-schema-from-the-dock-chain">Reading a Schema</a></li>
<li><a href="tutorial_blobs_schemas.html#schemas-in-verifiable-credentials">Schemas in Verifiable Credentials</a></li>
<li><a href="tutorial_blobs_schemas.html#schemas-in-verifiable-presentations">Schemas in Verifiable Presentations</a></li>
</ol>
</li>
</ol>
<h2 id="intro-1"><a class="header" href="#intro-1">Intro</a></h2>
<p>Data Schemas are useful way of enforcing a specific structure on a collection of data like a Verifiable Credential.
Data schemas serve a different purpose than that of the <code>@context</code> property in a Verifiable Credential, the latter
neither enforces data structure or data syntax, nor enables the definition of arbitrary encodings to alternate
representation formats.</p>
<h2 id="blobs-1"><a class="header" href="#blobs-1">Blobs</a></h2>
<p>Schemas are stored on chain as a <code>Blob</code> in the Blob Storage module of the Dock chain, so understanding blobs is
important before diving into Schemas.</p>
<h3 id="writing-a-blob"><a class="header" href="#writing-a-blob">Writing a Blob</a></h3>
<p>A new Blob can be registered on the Dock Chain by using the method <code>writeToChain</code> in the BlobModule class.
It accepts a <code>blob</code> object with the struct to store on chain (it can either be a hex string or a byte array), and one of <code>keyPair</code> (a
keyPair to sign the payload with). You'll get a signed extrinsic that you can send to the Dock chain:</p>
<pre><code class="language-javascript">const blobId = DockBlobId.random(); // 32-bytes long hex string to use as the blob's id
const blobStruct = {
  id: blobId,
  blob: blobHexOrArray, // Contents of your blob as a hex string or byte array
};
const result = await dock.blob.new(blobStruct, ownerDid, didKeypair);
</code></pre>
<p>If everything worked properly <code>result</code> will indicate a successful transaction.
We'll see how to retrieve the blob next.</p>
<h3 id="reading-a-blob"><a class="header" href="#reading-a-blob">Reading a Blob</a></h3>
<p>A Blob can be retrieved by using the method <code>get</code> in the BlobModule class.
It accepts a <code>blobId</code> string param which can either be a fully-qualified blob id like <code>blob:dock:0x...</code>
or just its hex identifier. In response you will receive a two-element array:</p>
<pre><code class="language-javascript">const chainBlob = await dock.blob.get(blobId);
</code></pre>
<p><code>chainBlob</code>'s first element will be the blob's author (a DID). It's second element will be the contents of your
blob (<code>blobHexOrArray</code> in our previous example).</p>
<h2 id="schemas-2"><a class="header" href="#schemas-2">Schemas</a></h2>
<p>Since Schemas are stored on chain as a <code>Blob</code> in the Blob Storage module, the <code>Schema</code> class uses the <code>BlobModule</code>
class internally. Schemas are identified and retrieved by their unique <code>blobId</code>, a 32 byte long hex string. As
mentioned, the chain is agnostic to the contents of blobs and thus to schemas.</p>
<h3 id="creating-a-schema"><a class="header" href="#creating-a-schema">Creating a Schema</a></h3>
<p>The first step to creating a Schema is to initialize it, we can do that using the <code>Schema</code> class constructor which
accepts an (optional) <code>id</code> string as sole argument:</p>
<pre><code class="language-javascript">const myNewSchema = new Schema();
</code></pre>
<p>When an <code>id</code> isn't passed, a random <code>blobId</code> will be assigned as the schema's id.</p>
<pre><code class="language-javascript">&gt; myNewSchema.id
&lt;- "blob:dock:5Ek98pDX61Dwo4EDmsogUkYMBqfFHtiS5hVS7xHuVvMByh3N"
</code></pre>
<p>Also worth noticing is the JSON representation of the schema as is right now, which can be achieved by calling
the <code>toJSON</code> method on your new schema:</p>
<pre><code class="language-javascript">&gt;  myNewSchema.toJSON()
&lt;- {"id":"0x768c21de02890dad5dbf6f108b6822b865e4ea495bb7f43f8947714e90fcc060"}
</code></pre>
<p>where you can see that the schema's <code>id</code> gets modified with <code>getHexIdentifierFromBlobID</code>.</p>
<h4 id="setting-a-json-schema"><a class="header" href="#setting-a-json-schema">Setting a JSON Schema</a></h4>
<p>A JSON schema can be added with the <code>setJSONSchema</code> method. It accepts a single argument <code>json</code> (an object that is
checked to be a valid JSON schema before being added):</p>
<pre><code class="language-javascript">&gt;   const someNewJSONSchema = {
         $schema: 'http://json-schema.org/draft-07/schema#',
         description: 'Dock Schema Example',
         type: 'object',
         properties: {
           id: {
             type: 'string',
           },
           emailAddress: {
             type: 'string',
             format: 'email',
           },
           alumniOf: {
             type: 'string',
           },
         },
         required: ['emailAddress', 'alumniOf'],
         additionalProperties: false,
       }
&gt;   myNewSchema.setJSONSchema(someNewJSONSchema)
&gt;   myNewSchema.schema === someNewJSONSchema
&lt;-  true
</code></pre>
<h4 id="formatting-for-storage"><a class="header" href="#formatting-for-storage">Formatting for storage</a></h4>
<p>Your new schema is now ready to be written to the Dock chain, the last step is to format it properly for the BlobModule
to be able to use it. That's where the <code>toBlob</code> method comes in handy:</p>
<pre><code class="language-javascript">&gt;   myNewSchema.toBlob()
&lt;-  {
      id: ...,
      blob: ...,
    }
</code></pre>
<h3 id="writing-a-schema-to-the-dock-chain"><a class="header" href="#writing-a-schema-to-the-dock-chain">Writing a Schema to the Dock chain</a></h3>
<p>Writing a Schema to the Dock chain is similar to writing any other Blob. <code>1</code> is the key id for the on-chain public key corresponding to <code>keyPair</code></p>
<pre><code class="language-javascript">&gt;  const formattedBlob = myNewSchema.toBlob(dockDID);
&gt;  await myNewSchema.writeToChain(modules.blob, dockDID, keypair);
</code></pre>
<h3 id="reading-a-schema-from-the-dock-chain"><a class="header" href="#reading-a-schema-from-the-dock-chain">Reading a Schema from the Dock chain</a></h3>
<p>Reading a Schema from the Dock chain can easily be achieved by using the <code>get</code> method from the <code>Schema</code> class.
It accepts a string <code>id</code> param (a fully-qualified blob id like "blob:dock:0x..." or just its hex identifier) and a
<code>dockAPI</code> instance:</p>
<pre><code class="language-javascript">&gt;  const result = await Schema.get(blob.id, modules.blob);
</code></pre>
<p><code>result[0]</code> will be the author of the Schema, and <code>result[1]</code> will be the contents of the schema itself.</p>
<h3 id="schemas-in-verifiable-credentials-1"><a class="header" href="#schemas-in-verifiable-credentials-1">Schemas in Verifiable Credentials</a></h3>
<p>The <a href="https://www.w3.org/TR/vc-data-model/#data-schemas">VCDM spec</a> specify how the <code>credentialSchema</code> property should be
used when present. Basically, once you've created and stored your Schema on chain, you can reference to it by its
<code>blobId</code> when issuing a Verifiable Credential. Let's see an example:</p>
<pre><code class="language-javascript">&gt;    const dockApi = new DockAPI();
&gt;    const dockResolver = new DockResolver(dockApi);
&gt;    let validCredential = new VerifiableCredential('https://example.com/credentials/123');
&gt;    validCredential.addContext('https://www.w3.org/2018/credentials/examples/v1');
&gt;    const ctx1 = {
      '@context': {
        emailAddress: 'https://schema.org/email',
      },
    };
&gt;    validCredential.addContext(ctx1);
&gt;    validCredential.addType('AlumniCredential');
&gt;    validCredential.addSubject({
      id: dockDID,
      alumniOf: 'Example University',
      emailAddress: 'john@gmail.com',
    });
&gt;    validCredential.setSchema(blobHexIdToQualified(blobId), 'JsonSchemaValidator2018');
&gt;    await validCredential.sign(keyDoc);
&gt;    await validCredential.verify({
       resolver: dockResolver,
       compactProof: true,
     });
</code></pre>
<p>Assuming that the <code>blobId</code> points to a schema taken from the previous examples, the verification above would fail if I
the <code>credentialSubject</code> in the Verifiable Credential didn't have one of the <code>alumniOf</code> or <code>emailAddress</code> properties.</p>
<h3 id="schemas-in-verifiable-presentations"><a class="header" href="#schemas-in-verifiable-presentations">Schemas in Verifiable Presentations</a></h3>
<p>The current implementation does not specify a way to specify a schema for a Verifiable Presentation itself.
However, a Verifiable Presentation may contain any number of Verifiable Credentials, each of which may or may not use a
Schema themselves. The <code>verify</code> method for Verifiable Presentations will enforce a schema validation in each of the
Verifiable Credentials contained in a presentation that are using the <code>credentialSchema</code> and <code>credentialSubject</code>
properties simultaneously.
This means that the verification of an otherwise valid Verifiable Presentation will fail if one of the Verifiable
Credentials contained within it uses a Schema and fails to pass schema validation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="claim-deduction-1"><a class="header" href="#claim-deduction-1">Claim Deduction</a></h1>
<h2 id="specifying-axioms"><a class="header" href="#specifying-axioms">Specifying Axioms</a></h2>
<p>A Verifier has complete and low level control over the logical rules they deem valid. Rules may vary from use-case to use-case and from verifier to verifier.</p>
<p>A common first step when writing a ruleset will be to unwrap of Explicit Ethos statements.</p>
<h3 id="simple-unwrapping-of-explicit-ethos"><a class="header" href="#simple-unwrapping-of-explicit-ethos">Simple Unwrapping of Explicit Ethos</a></h3>
<p>This ruleset names a specific issuer and states that any claims made by that issuer are true.</p>
<pre><code class="language-js">const rules = [
  {
    if_all: [
      [
        { Unbound: "subject" },
        { Unbound: "predicate" },
        { Unbound: "object" },
        { Bound: { Iri: "did:example:issuer" } },
      ],
    ],
    then: [
      [
        { Unbound: "subject" },
        { Unbound: "predicate" },
        { Unbound: "object" },
        { Bound: { DefaultGraph: true } },
      ],
    ],
  },
];
</code></pre>
<p>That single rule is enough for some use-cases but it's not scalable. What if we want to allow more than one issuer? Instead of copying the same rule for each issuer we trust, let's define "trustworthiness".</p>
<h3 id="unwrapping-explicit-ethos-by-defining-trustworthiness"><a class="header" href="#unwrapping-explicit-ethos-by-defining-trustworthiness">Unwrapping Explicit Ethos by Defining Trustworthiness</a></h3>
<pre><code class="language-js">const trustworthy = {
  Bound: { Iri: "https://www.dock.io/rdf2020#Trustworthy" },
};
const type = {
  Bound: { Iri: "http://www.w3.org/1999/02/22-rdf-syntax-ns#type" },
};
const defaultGraph = { Bound: { DefaultGraph: true } };

const rules = [
  {
    if_all: [
      [{ Unbound: "issuer" }, type, trustworthy, defaultGraph],
      [
        { Unbound: "s" },
        { Unbound: "p" },
        { Unbound: "o" },
        { Unbound: "issuer" },
      ],
    ],
    then: [
      [{ Unbound: "s" }, { Unbound: "p" }, { Unbound: "o" }, defaultGraph],
    ],
  },
  {
    if_all: [],
    then: [
      [
        { Bound: { Iri: "did:example:issuer" } },
        type,
        trustworthy,
        defaultGraph,
      ],
    ],
  },
];
</code></pre>
<p>You may ask "So what's the difference? There is still only one issuer."</p>
<p>By the primitive definition of "trustworthiness" written above, any claim made by a trustworthy issuer is true. <code>did:example:issuer</code> can claim whatever they want by issuing verifiable credentials. They can even claim that some other issuer is trustworthy. Together, the two rules defined in the above example implement a system analogous to TLS certificate chains with <code>did:example:issuer</code> as the single root authority.</p>
<h2 id="proving-composite-claims"><a class="header" href="#proving-composite-claims">Proving Composite Claims</a></h2>
<p>As a Holder of verifiable credentials, you'll want to prove specific claims to a Verifier. If those claims are composite, you'll sometimes need to bundle a deductive proof in your verifiable credentials presentation. This should be done after the presentation has been assembled. If the presentation is going to be signed, sign it <em>after</em> including the deductive proof.</p>
<pre><code class="language-js">import { proveCompositeClaims } from '@docknetwork/sdk/utils/cd';
import jsonld from 'jsonld';

// Check out the Issuance, Presentation, Verification tutorial for info on creating
// VCDM presentations.
const presentation = { ... };

// the claim we wish to prove
const compositeClaim = [
  { Iri: 'uuid:19e91192-210b-4b03-8e9c-8ded0a48d5bf' },
  { Iri: 'http://dbpedia.org/ontology/owner' },
  { Iri: 'did:example:bob' },
  { DefaultGraph: true },
];

// SDK reasoning utilities take presentations in expanded form
// https://www.w3.org/TR/json-ld/#expanded-document-form
const expPres = await jsonld.expand(presentation);

let proof;
try {
  proof = await proveCompositeClaims(expPres, [compositeClaim], rules);
} catch (e) {
  console.error('couldn\'t prove bob is an owner');
  throw e;
}

// this is that standard property name of a Dock deductive proof in VCDM presentation
const logic = 'https://www.dock.io/rdf2020#logicV1';

presentation[logic] = proof;

// Now JSON.stringify(presentation) is ready to send to a verifier.
</code></pre>
<h2 id="verifying-composite-claims"><a class="header" href="#verifying-composite-claims">Verifying Composite Claims</a></h2>
<pre><code class="language-js">import { acceptCompositeClaims } from '../src/utils/cd';
import jsonld from 'jsonld';
import deepEqual from 'deep-equal';

/// received from the presenter
const presentation = ...;

// Check out the Issuance, Presentation, Verification tutorial for info on verifying
// VCDM presentations.
let ver = await verify(presentation);
if (!ver.verified) {
  throw ver;
}

const expPres = await jsonld.expand(presentation);

// acceptCompositeClaims will verify and take into account any deductive proof provided
// via the logic property
const claims = await acceptCompositeClaims(expPres, rules);

if (claims.some(claim =&gt; deepEqual(claim, compositeClaim))) {
  console.log('the composite claim was shown to be true');
} else {
  console.error('veracity of the composite claim is unknown');
}
</code></pre>
<h2 id="verifier-side-reasoning"><a class="header" href="#verifier-side-reasoning">Verifier-Side Reasoning</a></h2>
<p>Some use-cases may require the verifier to perform inference in place of the presenter.</p>
<pre><code class="language-js">import { proveCompositeClaims } from '../src/utils/cd';
import jsonld from 'jsonld';

/// received from the presenter
const presentation = ...;

// Check out the Issuance, Presentation, Verification tutorial for info on verifying
// VCDM presentations.
let ver = await verify(presentation);
if (!ver.verified) {
  throw ver;
}

const expPres = await jsonld.expand(presentation);

try {
  await proveCompositeClaims(expPres, [compositeClaim], rules);
  console.log('the composite claim was shown to be true');
} except (e) {
  console.error('veracity of the composite claim is unknown');
}
</code></pre>
<h2 id="we-need-to-go-deeper"><a class="header" href="#we-need-to-go-deeper">We Need to Go Deeper</a></h2>
<p>The SDK claim deduction module exposes lower level functionality for those who need it. <code>getImplications</code>, <code>proveh</code> and <code>validateh</code>, for example, operate on raw claimgraphs represented as adjacency lists. For even lower level access, check out our <a href="https://github.com/docknetwork/rify">inference engine</a> which is written in Rust and exposed to javascript via wasm.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="graphical-anchoring-utility"><a class="header" href="#graphical-anchoring-utility">Graphical Anchoring Utility</a></h2>
<p>You can also anchor without touching any code. Visit <a href="https://fe.dock.io/#/anchor/batch">https://fe.dock.io/#/anchor/batch</a> for creation of anchors and <a href="https://fe.dock.io/#/anchor/check">https://fe.dock.io/#/anchor/check</a> for anchor verification.</p>
<h3 id="to-batch-or-not-to-batch"><a class="header" href="#to-batch-or-not-to-batch">To Batch, or not to Batch</a></h3>
<p>Batching (combining multiple anchors into one) can be used to save on transaction costs by anchoring multiple documents in a single transaction as a merkle tree root.</p>
<p>Batching does have a drawback. In order to verify a document that was anchored as part of the batch, you must provde the merkle proof that was generated when batching said file. Merkle proofs are expressed as <code>.proof.json</code> files and can be downloaded before posting the anchor. No merkle proof is required for batches containing only one document.</p>
<h2 id="programatic-usage"><a class="header" href="#programatic-usage">Programatic Usage</a></h2>
<p>The on-chain anchoring module allows to developers the flexibility talor anchors to their own use-case, but the sdk does provide a reference example for batching and anchoring documents.</p>
<p>The anchoring module is hashing algorithm and hash length agnostic. You can post a <a href="https://github.com/multiformats/multihash">multihash</a>, or even use the identity hash; the chain doesn't care.</p>
<p>One thing to note is that rather than storing your anchor directly, the anchoring module will store the blake2b256 hash of the anchor. This means as a developer you'll need to perform an additional hashing step when looking up anchors:</p>
<pre><code>// pseudocode

function postAnchor(file) {
  anchor = myHash(file)
  deploy(anchor)
}

fuction checkAnchor(file) {
  anchor = myHash(file)
  anchorblake = blake2b256(anchor)
  return lookup(anchorblake)
}
</code></pre>
<p>See the <code>example/anchor.js</code> in the sdk repository for more info.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="private-delegation-1"><a class="header" href="#private-delegation-1">Private Delegation</a></h1>
<p>This tutorial follows the lifecycle of a delegated credential. It builds builds on previous turorials <a href="./tutorial_ipv.html">Issuance, Presentation, Verification</a> and <a href="./tutorial_claim_deduction.html">Claim Deduction</a>.</p>
<h2 id="create-a-delegation"><a class="header" href="#create-a-delegation">Create a Delegation</a></h2>
<p>Let's assume some root authority, <code>did:ex:a</code>, wants grant <code>did:ex:b</code> full authority to make claims on behalf of <code>did:ex:a</code>. To do this <code>did:ex:a</code> will issue a delegation credential to <code>did:ex:b</code>.</p>
<details>
<summary>Boilerplate</summary>
<pre><code class="language-js">const { v4: uuidv4 } = require('uuid');

function uuid() {
  return `uuid:${uuidv4()}`;
}

// Check out the Issuance, Presentation, Verification tutorial for info on signing
// credentials.
function signCredential(cred, issuer_secret) { ... }

// Check out the Issuance, Presentation, Verification tutorial for info on verifying
// VCDM presentations.
async function verifyPresentation(presentation) { ... }
</code></pre>
</details>
<pre><code class="language-js">const delegation = {
  "@context": ["https://www.w3.org/2018/credentials/v1"],
  id: uuid(),
  type: ["VerifiableCredential"],
  issuer: "did:ex:a",
  credentialSubject: {
    id: "did:ex:b",
    "https://rdf.dock.io/alpha/2021#mayClaim":
      "https://rdf.dock.io/alpha/2021#ANYCLAIM",
  },
  issuanceDate: new Date().toISOString(),
};
const signed_delegation = signCredential(delegation, dida_secret);
</code></pre>
<p>Next <code>did:ex:a</code> sends the signed credential to <code>did:ex:b</code>.</p>
<h2 id="issue-a-credential-as-a-delegate"><a class="header" href="#issue-a-credential-as-a-delegate">Issue a Credential as a Delegate</a></h2>
<p><code>did:ex:b</code> accepts the delegation credential from <code>did:ex:a</code>. Now <code>did:ex:b</code> can use the delegation to make arbitrary attestations on behalf of <code>did:ex:a</code>.</p>
<pre><code class="language-js">const newcred = {
  "@context": ["https://www.w3.org/2018/credentials/v1"],
  id: uuid(),
  type: ["VerifiableCredential"],
  issuer: "did:ex:b",
  credentialSubject: {
    id: "did:ex:c",
    "https://example.com/score": 100,
  },
  issuanceDate: new Date().toISOString(),
};
const signed_newcred = signCredential(newcred, didb_secret);
</code></pre>
<p>So far we have two credentials, <code>signed_delegation</code> and <code>signed_newcred</code>. <code>signed_delegation</code> proves that any claim made by <code>did:ex:b</code> is effectively a claim made by <code>did:ex:a</code>. <code>signed_newcred</code> proves tha <code>did:ex:b</code> claims that <code>did:ex:c</code> has a score of 100. By applying one of the logical rules provided by the sdk, we can infer that <code>did:ex:a</code> claims <code>did:ex:c</code> has a score of 100. The logical rule named <code>MAYCLAIM_DEF_1</code> will work for this use-case. <code>MAYCLAIM_DEF_1</code> will be used by the verifier.</p>
<p>Now <code>did:ex:b</code> has both signed credentials. <code>did:ex:b</code> may now pass both credentials to the <em>holder</em>. In this case the holder is <code>did:ex:c</code>. <code>did:ex:c</code> also happens to be the <em>subject</em> of one of the credentials.</p>
<h2 id="present-a-delegated-credential"><a class="header" href="#present-a-delegated-credential">Present a Delegated Credential</a></h2>
<p><code>did:ex:c</code> now holds two credentials, <code>signed_delegation</code> and <code>signed_newcred</code>. Together they prove that <code>did:ex:a</code> indirectly claims <code>did:ex:c</code> to have a score of 100. <code>did:ex:c</code> wants to prove this statement to another party, a <em>verifier</em>. <code>did:ex:c</code> must bundle the two credentials into a VCDM <em>presentation</em>.</p>
<pre><code class="language-js">let presentation = {
  "@context": ["https://www.w3.org/2018/credentials/v1"],
  type: ["VerifiablePresentation"],
  id: uuid(),
  holder: `did:ex:c`,
  verifiableCredential: [signed_delegation, signed_newcred],
};
</code></pre>
<p><code>presentation</code> is sent to the verifier.</p>
<h2 id="accept-a-delegated-credential"><a class="header" href="#accept-a-delegated-credential">Accept a Delegated Credential</a></h2>
<p>The verifier receives <code>presentation</code>, <em>verifies the enclosed credentials</em>, then reasons over the union of all the credentials in the bundle using the rule <code>MAYCLAIM_DEF_1</code>. The process is the one outlined in <a href="./tutorial_claim_deduction.html#verifier-side-reasoning">Verifier-Side Reasoning</a> but using a different composite claim and a different rule list.</p>
<pre><code class="language-js">import { MAYCLAIM_DEF_1 } from '@docknetwork/sdk/rdf-defs';
import { proveCompositeClaims } from '../src/utils/cd';
import jsonld from 'jsonld';

const compositeClaim = [
  { Iri: 'did:ex:c' },
  { Iri: 'https://example.com/score' },
  { Literal: { datatype: 'http://www.w3.org/2001/XMLSchema#integer', value: '100' } }
  { Iri: 'did:ex:a' },
];

let ver = await verifyPresentation(presentation);
if (!ver.verified) {
  throw ver;
}

const expPres = await jsonld.expand(presentation);

try {
  await proveCompositeClaims(expPres, [compositeClaim], MAYCLAIM_DEF_1);
  console.log('the composite claim was shown to be true');
} except (e) {
  console.error('veracity of the composite claim is unknown');
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="public-delegation-1"><a class="header" href="#public-delegation-1">Public Delegation</a></h1>
<p>This feature should be considered <em>Alpha</em>.</p>
<p>Public Delegations use the same data model as Private Delegations. A delegator attests to some delegation. The verifier somehow gets and verifies that attestation then reasons over it in conjuction with a some credential. The difference is that while Private Delegations are passed around as credentials, Public Delegations are linked from the DID document of the delegator.</p>
<h2 id="create-a-delegation-1"><a class="header" href="#create-a-delegation-1">Create a Delegation</a></h2>
<p>It's assumed that the delegator already controls a DID. See the <a href="./tutorial_did.html">tutorial on DIDs</a> for instructions on creating your own on-chain DID.</p>
<p>Like in the Private Delegation tutorial, let's assume a root authority, <code>did:ex:a</code>, wants to grant <code>did:ex:b</code> full authority to make claims on behalf of <code>did:ex:a</code>. <code>did:ex:a</code> will post an attestation delegating to <code>did:ex:b</code>.</p>
<details>
<summary>Boilerplate</summary>
<pre><code class="language-js">import { graphResolver } from '@docknetwork/sdk/crawl.js';
const { v4: uuidv4 } = require('uuid');

// A running ipfs node is required for crawling.
const ipfsUrl = 'http://localhost:5001';

function uuid() {
  return `uuid:${uuidv4()}`;
}

// Check out the Issuance, Presentation, Verification tutorial for info on signing
// credentials.
function signCredential(cred, issuer_secret) { ... }

// Check out the Issuance, Presentation, Verification tutorial for info on verifying
// VCDM presentations.
async function verifyPresentation(presentation) { ... }

// This function can be implemeted using setClaim().
// An example of setClaim() usage can be found here:
//  https://github.com/docknetwork/sdk/blob/master/tests/integration/did-basic.test.js
async function setAttestation(did, didKey, iri) { ... }

// See the DID resolver tutorial For information about implementing a documentLoader.
const documentLoader = ...;

const { createHelia } = await import('helia');
const { strings } = await import('@helia/strings');
const ipfsClient = strings(await createHelia(ipfsUrl));
const resolveGraph = graphResolver(ipfsClient, documentLoader);
</code></pre>
</details>
<p>Instead of a credential, the delegation will be expressed as a turtle document, posted on ipfs.</p>
<pre><code class="language-turtle">@prefix dockalpha: &lt;https://rdf.dock.io/alpha/2021#&gt; .
&lt;did:ex:b&gt; dockalpha:mayClaim dockalpha:ANYCLAIM .
</code></pre>
<p>A link to this ipfs document is then added to the delegators DID document. For a Dock DID, this is done by submitting a transaction on-chain.</p>
<pre><code class="language-js">await setAttestation(
  delegatorDid,
  delegatorSk,
  "ipfs://Qmeg1Hqu2Dxf35TxDg19b7StQTMwjCqhWigm8ANgm8wA3p"
);
</code></pre>
<h2 id="issue-a-credential-as-a-delegate-1"><a class="header" href="#issue-a-credential-as-a-delegate-1">Issue a Credential as a Delegate</a></h2>
<p>With Public Delegation, the delegate doesn't need to worry about the passing on delegation credentials to the holder. The delegations are already posted where the verifier can find them.</p>
<h2 id="present-a-delegated-credential-1"><a class="header" href="#present-a-delegated-credential-1">Present a Delegated Credential</a></h2>
<p>With Public Delegation the holder does not need to include a delegation chain when presenting their credential. From the holders perspective, the process of presenting a publically delegated credential is exactly the same as the <a href="./tutorial_ipv.html">process for presenting a normal credential</a>.</p>
<h2 id="accept-a-delegated-credential-1"><a class="header" href="#accept-a-delegated-credential-1">Accept a Delegated Credential</a></h2>
<p>The verifier accepts Publicly delegated credentials by merging the credential's claimgraph representation with publically posted delegation information, then reasoning over the result. Once found, the delegation information is also a claimgraph. The delegation information is found by <a href="./concepts_public_attestation.html#uses">crawling the public attestation supergraph</a>. Crawling is potentially slow, so when verification speed is important it should be done early on, like at program startup. Delegation information can be re-used across multiple credential verifications.</p>
<p>As with any Public Attestations, delegation information is revocable by removing the delegation attestation from the delegators DID doc. As such it is possible for cached delegation information to become out of date. Long running validator processes should devise a mechanism for invalidating out-of-date delegation information, such as re-crawing whenever a change is detected to the DID doc of a delegator (or sub-delegator). This tutorial does not cover invalidation of out-of-date delegations.</p>
<p>The following example shows how a verifier might</p>
<pre><code class="language-js">import { ANYCLAIM, MAYCLAIM, MAYCLAIM_DEF_1 } from "@docknetwork/sdk/rdf-defs";
import { crawl } from "@docknetwork/sdk/crawl.js";
import {
  proveCompositeClaims,
  presentationToEEClaimGraph,
  inferh,
} from "@docknetwork/sdk/utils/cd";
import { merge } from "@docknetwork/sdk/utils/claimgraph";
import jsonld from "jsonld";

// These logical rules will be used for reasoning during both crawing and verifiying
// credentials.
const RULES = [
  // Imports the definition of dockalpha:mayClaim from sdk
  ...MAYCLAIM_DEF_1,
  // Adds a custom rule stating that by attesting to a document the attester grants the
  // document full delegation authority.
  {
    if_all: [
      [
        { Unbound: "a" },
        { Bound: { Iri: ATTESTS } },
        { Unbound: "doc" },
        { Unbound: "a" },
      ],
    ],
    then: [
      [
        { Unbound: "doc" },
        { Bound: { Iri: MAYCLAIM } },
        { Bound: { Iri: ANYCLAIM } },
        { Unbound: "a" },
      ],
    ],
  },
];

// This query dictates what the crawler will be "curious" about. Any matches to
// `?lookupNext` will be dereferenced as IRIs. When an IRI is successfully dereferenced
// the resultant data is merged into the crawlers knowlege graph.
const CURIOSITY = `
  prefix dockalpha: &lt;https://rdf.dock.io/alpha/2021#&gt;

  # Any entity to which "did:ex:a" grants full delegation authority is interesting.
  select ?lookupNext where {
    graph &lt;did:ex:a&gt; {
      ?lookupNext dockalpha:mayClaim dockalpha:ANYCLAIM .
    }
  }
`;

// To spark the crawlers interest we'll feed it some initial knowlege about did:ex:a .
const initialFacts = await resolveGraph({ Iri: "did:ex:a" });

// `allFact` contains our delegation information, it will be merged with verified
// credentials in order to reason over delegations
let allFacts = await crawl(initialFacts, RULES, CURIOSITY, resolveGraph);

// Now that we've obtained delegation information for `did:ex:a` we can verify
// credentials much like normal. The only difference is that we merge claimgraphs
// before reasoning over the verified credentials.
//
// `presentation` is assumed to be a VCDM presentation provided by a credential holder
let ver = await verifyPresentation(presentation);
if (!ver.verified) {
  throw ver;
}
const expPres = await jsonld.expand(presentation);
const presCg = await presentationToEEClaimGraph(expPres);
const cg = inferh(merge(presCg, allFacts), RULES);

// At this point all the RDF quads in `cg` are known to be true.
// doSomethingWithVerifiedData(cg);
</code></pre>
<p>More examples of <code>crawl()</code> usage can be found <a href="https://github.com/docknetwork/sdk/blob/master/tests/integration/crawl.test.js">here</a> and <a href="https://github.com/docknetwork/sdk/blob/master/tests/unit/crawl.test.js">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evm"><a class="header" href="#evm">EVM</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anonymous-credentials"><a class="header" href="#anonymous-credentials">Anonymous credentials</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>This document talks about building anonymous credentials using mainly 2 primitives, BBS+ signature scheme which issuer uses to sign the
credential and accumulators for membership check needed for revocation. BBS+ implementation comes from <a href="https://github.com/docknetwork/crypto-wasm-ts/">this</a>
Typescript package which uses <a href="https://github.com/docknetwork/crypto-wasm">this</a> WASM wrapper which itself uses <a href="https://github.com/docknetwork/crypto">our Rust crypto library</a>.</p>
<p>For an overview of these primitives, see <a href="https://github.com/docknetwork/crypto-wasm#overview">this</a>.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>On chain, there are 2 modules, one for BBS+ and the other for accumulator. The modules store the BBS+ params, public keys, accumulator params,
accumulator public keys and some accumulator details like current accumulated value, last updated, etc. They are somewhat agnostic
to the cryptographic details and treat the values as bytes with some size bounds.</p>
<ul>
<li>
<p><strong>BBS+ module</strong></p>
<ul>
<li>At path <code>src/modules/bbs-plus.js</code> in the repo.</li>
<li>Used to create and remove signature parameters and public keys.</li>
<li>The public keys can either refer the signature params or not pass the reference while creating.</li>
<li>The params and public keys are owned by a DID and can be only removed by that DID.</li>
<li>See the tests at <code>tests/integration/anoncreds/bbs-plus.test.js</code> on how to create, query and remove these.</li>
</ul>
</li>
<li>
<p><strong>Accumulator module</strong></p>
<ul>
<li>At path <code>src/modules/accumulator.js</code> in the repo.</li>
<li>The parameters and public keys are managed in the same way as BBS+ signatures.</li>
<li>Accumulators are owned by a DID and can be only removed by that DID.</li>
<li>Accumulators are identified by a unique id and that id is used to send updates or remove it.</li>
<li>The accumulator update contains the additions, removals and the witness update info and these are not stored in chain
state but are present in the blocks and the accumulated value corresponding to the update is logged in the event.</li>
<li>In the chain state, only the most recent accumulated value is stored (along with some metadata like creation time,
last update, etc), which is sufficient to verify the witness or the proof of knowledge.</li>
<li>To update the witness, the updates and witness update info should be parsed from the blocks and the accumulator module provides
the functions get the updates and necessary events from the block,</li>
<li>See the tests at <code>tests/integration/anoncreds/accumulator.test.js</code> on how to create, query and remove params and keys as well as
the accumulator.</li>
</ul>
</li>
<li>
<p>Composite proofs</p>
<ul>
<li>Proofs that use BBS+ signatures and accumulator</li>
<li>The SDK itself doesn't include the Typescript package containing the crypto as a dependency. But it can be used with the SDK to issue, prove,
verify and revoke credentials as shown in tests mentioned below.</li>
<li>See the test <code>tests/integration/anoncreds/demo.test.js</code> for an example of how a BBS+ signature can be used with an
accumulator for anonymous credentials. The accumulator is used to hold a user/credential id. Presence of the id in accumulator
means the credential is valid and absence means invalid.</li>
</ul>
</li>
<li>
<p>Verifiable encryption</p>
<ul>
<li>Encrypt messages from BBS+ signatures for a 3rd party and prove that the encryption was done correctly.</li>
<li>See the test <code>tests/integration/anoncreds/saver-and-bound-check.test.js</code></li>
</ul>
</li>
<li>
<p>Bound check/Range proof</p>
<ul>
<li>Prove that messages under a BBS+ signature satisfy some bounds.</li>
<li>See the test <code>tests/integration/anoncreds/saver-and-bound-check.test.js</code></li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
