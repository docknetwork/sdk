<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dock SDK Tutorial</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">2.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts_did.html"><strong aria-hidden="true">2.1.</strong> DID</a></li><li class="chapter-item expanded "><a href="concepts_vcdm.html"><strong aria-hidden="true">2.2.</strong> Verifiable credentials and presentations</a></li><li class="chapter-item expanded "><a href="concepts_blobs_schemas.html"><strong aria-hidden="true">2.3.</strong> Schema</a></li><li class="chapter-item expanded "><a href="concepts_claim_deduction.html"><strong aria-hidden="true">2.4.</strong> Claim Deduction</a></li><li class="chapter-item expanded "><a href="concepts_poe_anchors.html"><strong aria-hidden="true">2.5.</strong> PoE Anchors</a></li></ol></li><li class="chapter-item expanded "><a href="tutorials.html"><strong aria-hidden="true">3.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial_did.html"><strong aria-hidden="true">3.1.</strong> DID</a></li><li class="chapter-item expanded "><a href="tutorial_resolver.html"><strong aria-hidden="true">3.2.</strong> DID Resolver</a></li><li class="chapter-item expanded "><a href="tutorial_ipv.html"><strong aria-hidden="true">3.3.</strong> Credentials - Issuance, Presentation, Verification</a></li><li class="chapter-item expanded "><a href="tutorial_revocation.html"><strong aria-hidden="true">3.4.</strong> Revocation</a></li><li class="chapter-item expanded "><a href="tutorial_blobs_schemas.html"><strong aria-hidden="true">3.5.</strong> Schema</a></li><li class="chapter-item expanded "><a href="tutorial_claim_deduction.html"><strong aria-hidden="true">3.6.</strong> Claim Deduction</a></li><li class="chapter-item expanded "><a href="tutorial_poe_anchors.html"><strong aria-hidden="true">3.7.</strong> PoE Anchors</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Dock SDK Tutorial</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p><a href="https://dock.io">Dock</a> is a blockchain built using <a href="https://www.parity.io/substrate/">Substrate</a> to facilitate the use of <a href="https://www.w3.org/TR/vc-data-model/">Verifiable Credentials Data Model 1.0</a> compliant documents, creating/managing <a href="https://www.w3.org/TR/did-core">W3C spec</a> compliant DIDs and more. The client SDK contains a library and tooling to interact with the Dock chain and also other things such as verifying and issuing credentials. View the video verison of this tutorial here: <a href="https://www.youtube.com/watch?v=jvgn9oSXBDQ">https://www.youtube.com/watch?v=jvgn9oSXBDQ</a></p>
<h1 id="pre-requisites-for-these-tutorials"><a class="header" href="#pre-requisites-for-these-tutorials">Pre-requisites for these tutorials</a></h1>
<p>For these tutorials we will be a running our own local development node. Instructions to do this can be found at the <a href="https://github.com/docknetwork/dock-substrate">dock substrate repository</a>. Once you have followed the instructions and have your local node running, you can continue. Please note that you don't always need a node to use the Dock SDK, but certain features rely on it.</p>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Installation of the SDK is pretty simple, we use NPM and our source is also available at GitHub (links below). To install via NPM or Yarn, run either <code>npm install @docknetwork/sdk</code> or <code>yarn add @docknetwork/sdk</code> respectively. Once the package and dependencies are installed, you can import it like any ES6/CJS module. You can find the complete source for the SDK at https://github.com/docknetwork/sdk and the tutorials at https://github.com/docknetwork/dock-tutorials.</p>
<h1 id="importing"><a class="header" href="#importing">Importing</a></h1>
<p>In this tutorial series we will be using NodeJS with babel for ES6 support, however the same code should work in browsers too once it is transpiled. To begin with, we should import the Dock SDK. Importing the default reference will give us a DockAPI instance. With this we will communicate with the blockchain. You can also import the DockAPI class instanciate your own objects if you prefer. Simply do:</p>
<pre><code class="language-javascript">// Import the dock SDK
import dock from '@docknetwork/sdk';
</code></pre>
<p>We will add one more import here for some shared constants across each tutorial, just the node address and account secret:</p>
<pre><code class="language-javascript">// Import some shared variables
import { address, secretUri } from './shared-constants';
</code></pre>
<p>Lets also create this file, creating <code>shared-constants.js</code> with the contents:</p>
<pre><code class="language-javascript">export const address = 'ws://localhost:9944'; // Websocket address of your Dock node
export const secretUri = '//Alice'; // Account secret in uri format, we will use Alice for local testing
</code></pre>
<h1 id="connecting-to-a-node"><a class="header" href="#connecting-to-a-node">Connecting to a node</a></h1>
<p>With the required packages and variables imported, we can go ahead and connect to our node. If you don't have a local testnet running alraedy, go to https://github.com/docknetwork/dock-substrate and follow the steps in the readme to start one. You could use the Dock testnet given a proper account with enough funds. First, create a method named <code>connectToNode</code> with an empty body for now:</p>
<pre><code class="language-javascript">export async function connectToNode() {

}
</code></pre>
<p>Before working with the SDK, we need to initialize it. Upon initialization the SDK will connect to the node with the supplied address and create a keyring to manage accounts. Simply call <code>dock.init</code> and wait for the promise to resolve to connect to your node:</p>
<pre><code class="language-javascript">// Initialize the SDK and connect to the node
await dock.init({ address });
console.log('Connected to the node and ready to go!');
</code></pre>
<h1 id="creating-an-account"><a class="header" href="#creating-an-account">Creating an account</a></h1>
<p>In order to write to the chain we will need to set an account. We can perform read operations with no account set, but for our purposes we will need one. Accounts can be generated using the <code>dock.keyring</code> object through multiple methods such as URI, memonic phrase and raw seeds. See the polkadot keyring documentation (https://polkadot.js.org/api/start/keyring.html) for more information.</p>
<p>We will use our URI secret of <code>//Alice</code> which was imported from <code>shared-constants.js</code> to work with our local testnet. Add this code after <code>dock.init</code>:</p>
<pre><code class="language-javascript">// Create an Alice account for our local node
// using the dock keyring. You don't -need this
// to perform some read operations.
const account = dock.keyring.addFromUri(secretUri);
dock.setAccount(account);

// We are now ready to transact!
console.log('Connected to the node and ready to go!');
</code></pre>
<p>If all has gone well, you should be able to run this script and see that you are connected to the node. If any errors occur, the promise will fail and they will be outputted to the console.</p>
<h1 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h1>
<p>To construct your own API object, once the SDK has been installed, import the Dock API object as</p>
<pre><code class="language-js">import { DockAPI } from '@docknetwork/sdk/api';
const dock = new DockAPI();
</code></pre>
<p>To make the API object connect to the node call <code>init</code> method. This method accepts the Websocket RPC endpoint of the node is
needed. Say you have it in <code>address</code>. It also accepts a Polkadot-js keyring as well.</p>
<pre><code class="language-js">await dock.init({ address, keyring });
</code></pre>
<p>To disconnect from the node</p>
<pre><code class="language-js">await dock.disconnect();
</code></pre>
<p>To set the account used in sending the transaction and pay fees, call <code>setAccount</code> with the polkadot-js <code>account</code></p>
<pre><code class="language-js">// the `account` object might have been generated as
const account = dock.keyring.addFromUri(secretURI);
// Set the account to pay fees for transactions
dock.setAccount(account);
</code></pre>
<p>To get the account, call <code>getAccount</code></p>
<pre><code class="language-js">dock.getAccount();
</code></pre>
<p>To send a transaction, use the <code>signAndSend</code> on the <code>DockAPI</code> object</p>
<pre><code class="language-js">const res = await dock.signAndSend(transaction);
</code></pre>
<p>For interacting with the DID module, i.e. creating, updating and removing them, get the <code>didModule</code> with <code>did</code> getter</p>
<pre><code class="language-js">const didModule = dock.did;
</code></pre>
<p>Similarly, for the revocation module, get the <code>revocationModule</code> with <code>revocation</code> getter</p>
<pre><code class="language-js">const revocationModule = dock.revocation;
</code></pre>
<h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<ol>
<li><a href="./concepts_did.html">DID</a></li>
<li><a href="./concepts_vcdm.html">Verifiable credentials</a></li>
<li><a href="./concepts_blobs_schemas.html">Blobs and Schemas</a></li>
</ol>
<h1 id="w3c-did"><a class="header" href="#w3c-did">W3C DID</a></h1>
<p>DID stands for Decentralized IDentifiers. DIDs are meant to be globally unique identifiers that allow their owner to
prove cryptographic control over them. The owner(s) of the DID is called the <code>controller</code>. The identifiers are not just assignable
to humans but to anything. Quoting the <a href="https://www.w3.org/TR/did-core/">DID spec</a>,</p>
<blockquote>
<p>A DID identifies any subject (e.g., a person, organization, thing, data model, abstract entity, etc.) that the controller
of the DID decides that it identifies.</p>
</blockquote>
<p>DIDs differ from public keys in that DIDs are persistent, i.e. a public key has to be changed if the private key is stolen/lost
or the cryptographic scheme of the public key is no longer considered safe. This is not the case with DIDs, they can remain
unchanged even when the associated cryptographic material changes. Moreover, a DID can have multiple keys and any of its
keys can be rotated. Additionally, depending on the scheme, public keys can be quite large (several hundred bytes in RSA)
whereas a unique identifier can be much smaller.</p>
<p>Each DID is associated with a <code>DID Document</code> that specifies the subject, the public keys, the authentication mechanisms usable
by the subject, authorizations the subject has given to others, service endpoints to communicate with the subject, etc,
for all properties that can be put in the DID Document, refer <a href="https://www.w3.org/TR/did-core/#core-properties">this section of the spec</a>.
DIDs and their associated DID Documents are stored on the DID registry which is a term used for the centralized on decentralized
database persisting the DID and its Document.</p>
<p>The process of discovering the DID Document for a DID is called DID resolution and the tool (library or a service) is called DID
resolver. To resolve the DID, the resolver first needs to check on which registry the DID is hosted and then decide whether it
is capable or willing to lookup that registry. The registry is indicated by the <code>DID method</code> of that DID. In addition to the
registry, the method also specifies other details of that DID like the supported operations, crypto, etc. Each DID method
defines its own specification, Docks's DID method spec is <a href="https://github.com/docknetwork/dock-did-driver/blob/master/Dock%20DID%20method%20specification.md">here</a>.
In case of Dock, the registry is the Dock blockchain, and the method is <code>dock</code>.</p>
<p>An example Dock DID.</p>
<pre><code>did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW
</code></pre>
<p>Above DID has method <code>dock</code> and the DID identifier is <code>5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW</code>. Dock DID identifiers
are 32 bytes in size.</p>
<p>An example DID Document</p>
<pre><code class="language-json">{
  &quot;@context&quot;: &quot;https://www.w3.org/ns/did/v1&quot;,
  &quot;id&quot;: &quot;did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW&quot;,
  &quot;authentication&quot;: [
    &quot;did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW#keys-1&quot;
  ],
  &quot;assertionMethod&quot;: [
    &quot;did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW#keys-1&quot;
  ],
  &quot;publicKey&quot;: [
    {
      &quot;id&quot;: &quot;did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW#keys-1&quot;,
      &quot;type&quot;: &quot;Sr25519VerificationKey2020&quot;,
      &quot;controller&quot;: &quot;did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW&quot;,
      &quot;publicKeyBase58&quot;: &quot;8bEsU4JWBVVFQCdd8du7Txo6L3JHdJYQByHBqzL1WXwy&quot;
    }
  ]
}
</code></pre>
<p>Note that Dock DIDs support only one key as of now. The key is present in the <code>publicKey</code> section. Note how that public key
is referred to using its <code>id</code> in <code>authentication</code> and <code>assertionMethod</code> sections. The above document states that the DID
<code>did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW</code> authenticates with public key under <code>publicKey</code> and also when
it attests to some fact (becomes issuer), it uses that key. As there is only one public key supported for a DID, that
public key is used for both <code>authentication</code> and <code>assertionMethod</code>. When support for multiple keys is added, the DID can
specify which key(s) needs to be used for <code>authentication</code> and which ones for <code>assertionMethod</code>.</p>
<p>Another thing to keep in mind is that the keys associated with the Dock DID are independent of the keys used to send the
transaction on chain and pay fees. Eg. Alice might not have any tokens to write anything on chain but can still create a
DID and corresponding key and ask Bob who has tokens to register the DID on chain. Even though Bob wrote the DID on chain,
he cannot update or remove it since only Alice has the keys associated with that DID. Similarly, when Alice wants to update
the DID (public key or controller), it can create the update, sign it and send it to Carol this time to send the update on
chain.</p>
<h1 id="verifiable-credentials"><a class="header" href="#verifiable-credentials">Verifiable Credentials</a></h1>
<p>Credentials are a part of our daily lives: driver's licenses are used to
assert that we are capable of operating a motor vehicle, university degrees
can be used to assert our level of education, and government-issued passports
enable us to travel between countries.</p>
<p>These credentials provide benefits to us when used in the physical world, but
their use on the Web continues to be elusive.</p>
<p>Currently it is difficult to express education qualifications, healthcare
data, financial account details, and other sorts of third-party verified
machine-readable personal information on the Web.</p>
<p>The difficulty of expressing digital credentials on the Web makes it
challenging to receive the same benefits through the Web that physical
credentials provide us in the physical world.</p>
<p>The <a href="https://www.w3.org/TR/vc-data-model/">Verifiable Credentials Data Model 1.0 (VCDM)</a>
specification provides a standard way to express credentials on the Web in a
way that is cryptographically secure, privacy respecting, and
machine-verifiable.</p>
<h2 id="participants-and-workflow"><a class="header" href="#participants-and-workflow">Participants and workflow</a></h2>
<ul>
<li>Credentials are issued by an entity called the <strong>issuer</strong>.</li>
<li><strong>Issuer</strong> issues the credential about a <strong>subject</strong> by signing the credential with his key. If the credential is revocable,
the issuer must specify how and from where revocation status must be checked. It is not necessary that revocation is managed by
the issuer, the issuer might designate a different authority for revocation.</li>
<li><strong>Issuer</strong> gives the credential to the <strong>holder</strong>. The <strong>holder</strong> might be the same as the <strong>subject</strong>.</li>
<li>A service provider or anyone willing to check if the <strong>holder</strong> possesses certain credentials requests a <strong>presentation</strong> about those
credentials. This entity requesting the <strong>presentation</strong> is called the <strong>verifier</strong>. To protect against replay attacks, (a
verifier receiving the presentation and replaying the same presentation at some other verifier), a verifier must supply a
challenge that must be embedded in the presentation.</li>
<li><strong>Holder</strong> creates a <strong>presentation</strong> for the required credentials. The <strong>presentation</strong> must indicate which
credentials it is about and must be signed by the <strong>holder</strong> of the credentials.</li>
<li><strong>Verifier</strong> on receiving the presentation verifies the validity of each credential in the <strong>presentation</strong>. This includes
checking correctness of the data model of the credential, the authenticity by verifying the issuer's signature and revocation
status if the credential is revocable. It then checks whether the presentation contains the signature from the
<strong>holder</strong> on the presentation which also includes his given challenge.</li>
</ul>
<h2 id="issuing"><a class="header" href="#issuing">Issuing</a></h2>
<p>To issue a verifiable credential, the issuer needs to have a public key that is accessible by the holder and verifier to verify the
signature (in <code>proof</code>) in the credential. Though the VCDM spec does not mandate it, an issuer in Dock must have a DID on chain.
This DID is present in the credential in the <code>issuer</code> field. An example credential where both the issuer and holder have Dock DIDs</p>
<pre><code class="language-json">{
    '@context': [
      'https://www.w3.org/2018/credentials/v1',
      'https://www.w3.org/2018/credentials/examples/v1'
    ],
    id: '0x9b561796d3450eb2673fed26dd9c07192390177ad93e0835bc7a5fbb705d52bc',
    type: [ 'VerifiableCredential', 'AlumniCredential' ],
    issuanceDate: '2020-03-18T19:23:24Z',
    credentialSubject: {
      id: 'did:dock:5GL3xbkr3vfs4qJ94YUHwpVVsPSSAyvJcafHz1wNb5zrSPGi',
      alumniOf: 'Example University'
    },
    issuer: 'did:dock:5GUBvwnV6UyRWZ7wjsBptSquiSHGr9dXAy8dZYUR9WdjmLUr',
    proof: {
      type: 'Ed25519Signature2018',
      created: '2020-04-22T07:50:13Z',
      jws: 'eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..GBqyaiTMhVt4R5P2bMGcLNJPWEUq7WmGHG7Wc6mKBo9k3vSo7v7sRKwqS8-m0og_ANKcb5m-_YdXC2KMnZwLBg',
      proofPurpose: 'assertionMethod',
      verificationMethod: 'did:dock:5GUBvwnV6UyRWZ7wjsBptSquiSHGr9dXAy8dZYUR9WdjmLUr#keys-1'
    }
}
</code></pre>
<h2 id="presentation"><a class="header" href="#presentation">Presentation</a></h2>
<p>The holder while creating the presentation signs it with his private key. For the verifier to verify the presentation, in
addition to verifying the issuer's signature, he needs to verify this signature as well, and for that he must know the
holder's public key. One way to achieve this is to make the holder have a DID too so that the verifier can look up the DID
on chain and learn the public key. An example presentation signed by the holder</p>
<pre><code class="language-json">{
    '@context': [ 'https://www.w3.org/2018/credentials/v1' ],
    type: [ 'VerifiablePresentation' ],
    verifiableCredential: [
      {
          '@context': [
            'https://www.w3.org/2018/credentials/v1',
            'https://www.w3.org/2018/credentials/examples/v1'
          ],
          id: 'A large credential id with size &gt; 32 bytes',
          type: [ 'VerifiableCredential', 'AlumniCredential' ],
          issuanceDate: '2020-03-18T19:23:24Z',
          credentialSubject: {
            id: 'did:dock:5GnE6u2dt9nC7tgf5vSdKy4gYX3jwqthbrBnjiay2LWETdrV',
            alumniOf: 'Example University'
          },
          credentialStatus: {
            id: 'rev-reg:dock:0x0194db371bab472a9cc920b5dfb1447aad5a6db906c46ff378cf0fc337a0c8c0',
            type: 'CredentialStatusList2017'
          },
          issuer: 'did:dock:5CwAuM8cPetXWbZN2JhMFWtLjxZ6DokiDdHViGw2FfxC1Cya',
          proof: {
            type: 'Ed25519Signature2018',
            created: '2020-04-22T07:58:43Z',
            jws: 'eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..bENDgnK29BHRhP05ehbQkOPfqweppGyI7NeH02YT1hzSDEHseOzCDx-g9dS4lY-m_bElwbOptOlRnQ2g9MW7Ag',
            proofPurpose: 'assertionMethod',
            verificationMethod: 'did:dock:5CwAuM8cPetXWbZN2JhMFWtLjxZ6DokiDdHViGw2FfxC1Cya#keys-1'
          }
      }
    ],
    id: '0x4bd107aee17744dcec10208d7551620664dcba7e88ce11c2312c02df562754f1',
    proof: {
      type: 'Ed25519Signature2018',
      created: '2020-04-22T07:58:49Z',
      challenge: '0x6a5a5d58a99705c4d499fa7cdcdc62eeb2f742eb878456babf49b9a6669d0b76',
      domain: 'test domain',
      jws: 'eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..HW7bDjvsRETeM25a3BtMgER53FtzK6rUBX_46cFo-i6O1y7p_TM-ED2iSTrFBUrDc7vH8QqoeUTY8e5ir5RvCg',
      proofPurpose: 'authentication',
      verificationMethod: 'did:dock:5GnE6u2dt9nC7tgf5vSdKy4gYX3jwqthbrBnjiay2LWETdrV#keys-1'
    }
}
</code></pre>
<h2 id="revocation"><a class="header" href="#revocation">Revocation</a></h2>
<p>If the credential is revocable, the issuer must specify how the revocation check must be done in the <code>credentialStatus</code> field.
On Dock, credential revocation is managed with a revocation registry. There can be multiple registries on chain and each
registry has a unique id. It is recommended that the revocation authority creates a new registry for each credential type.
While issuing the credential, issuer embeds the revocation registry's id in the credential in the <code>credentialStatus</code> field.
An example credential with Dock revocation registry</p>
<pre><code class="language-json">{
    '@context': [
      'https://www.w3.org/2018/credentials/v1',
      'https://www.w3.org/2018/credentials/examples/v1'
    ],
    id: 'A large credential id with size &gt; 32 bytes',
    type: [ 'VerifiableCredential', 'AlumniCredential' ],
    issuanceDate: '2020-03-18T19:23:24Z',
    credentialSubject: {
      id: 'did:dock:5GnE6u2dt9nC7tgf5vSdKy4gYX3jwqthbrBnjiay2LWETdrV',
      alumniOf: 'Example University'
    },
    credentialStatus: {
      id: 'rev-reg:dock:0x0194db371bab472a9cc920b5dfb1447aad5a6db906c46ff378cf0fc337a0c8c0',
      type: 'CredentialStatusList2017'
    },
    issuer: 'did:dock:5CwAuM8cPetXWbZN2JhMFWtLjxZ6DokiDdHViGw2FfxC1Cya',
    proof: {
      type: 'Ed25519Signature2018',
      created: '2020-04-22T07:58:43Z',
      jws: 'eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..bENDgnK29BHRhP05ehbQkOPfqweppGyI7NeH02YT1hzSDEHseOzCDx-g9dS4lY-m_bElwbOptOlRnQ2g9MW7Ag',
      proofPurpose: 'assertionMethod',
      verificationMethod: 'did:dock:5CwAuM8cPetXWbZN2JhMFWtLjxZ6DokiDdHViGw2FfxC1Cya#keys-1'
    }
}
</code></pre>
<p>To revoke a credential, the revocation authority (might be same as the issuer), puts a hash of the credential id in the revocation registry.
To check the revocation status of a credential, hash the credential id and query the registry id specified in the credential.
The revocation of a credential can be undone if the revocation registry supports undoing. Moreover, currently, each registry is
owned by a single DID so that DID can revoke a credential or undo the revocation. In future, Dock will support ownership of
the registry with mulitple DIDs and in different fashions, like any one of the owner DIDs could revoke or a threshold is needed,
etc. To learn more about revocation registries, refer the <a href="./tutorial_revocation.html">revocation section</a> of the documentation.</p>
<h1 id="schemas"><a class="header" href="#schemas">Schemas</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="concepts_blobs_schemas.html#intro-to-schemas">Intro</a></li>
<li><a href="concepts_blobs_schemas.html#blobs">Blobs</a></li>
<li><a href="concepts_blobs_schemas.html#json-schemas">JSON Schemas</a></li>
<li><a href="concepts_blobs_schemas.html#schemas-in-verifiable-credentials">Schemas in Verifiable Credentials</a></li>
</ol>
<h2 id="intro-to-schemas"><a class="header" href="#intro-to-schemas">Intro to Schemas</a></h2>
<p>Data Schemas are useful when enforcing a specific structure on a collection of data like a Verifiable Credential.
Data Verification schemas, for example, are used to verify that the structure and contents of a Verifiable Credential
conform to a published schema. Data Encoding schemas, on the other hand, are used to map the contents of a Verifiable
Credential to an alternative representation format, such as a binary format used in a zero-knowledge proof.
Data schemas serve a different purpose than that of the <code>@context</code> property in a Verifiable Credential, the latter
neither enforces data structure or data syntax, nor enables the definition of arbitrary encodings to alternate
representation formats.</p>
<h2 id="blobs"><a class="header" href="#blobs">Blobs</a></h2>
<p>Before diving further into Schemas in it is important to understand the way these are stored in the Dock chain.
Schemas are stored on chain as a <code>Blob</code> in the Blob Storage module. They are identified and retrieved by their unique
blob id, a 32 byte long hex string. They are authored by a DID and have a max size of 1024 bytes.
The chain is agnostic to the contents of blobs and thus to schemas. Blobs may be used to store types of data other than
schemas.</p>
<h2 id="json-schemas"><a class="header" href="#json-schemas">JSON Schemas</a></h2>
<p>JSON Schema can be used to require that a given JSON document (an instance) satisfies a certain number of criteria.
JSON Schema validation asserts constraints on the structure of instance data. An instance location that satisfies all
asserted constraints is then annotated with any keywords that contain non-assertion information, such as descriptive
metadata and usage hints. If all locations within the instance satisfy all asserted constraints, then the instance is
said to be valid against the schema.
Each schema object is independently evaluated against each instance location to which it applies.
This greatly simplifies the implementation requirements for validators by ensuring that they do not need to maintain
state across the document-wide validation process.
More about JSON schemas can be found <a href="http://json-schema.org/draft/2019-09/json-schema-validation.html">here</a> and
<a href="https://json-schema.org/understanding-json-schema/index.html">here</a>.</p>
<p>Let's see an example JSON schema definition:</p>
<pre><code class="language-json">{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;description&quot;: &quot;Alumni&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;properties&quot;: {
    &quot;emailAddress&quot;: {
      &quot;type&quot;: &quot;string&quot;,
      &quot;format&quot;: &quot;email&quot;
    },
    &quot;alumniOf&quot;: {
      &quot;type&quot;: &quot;string&quot;
    }
  },
  &quot;required&quot;: [&quot;emailAddress&quot;, &quot;alumniOf&quot;],
  &quot;additionalProperties&quot;: false
}
</code></pre>
<p>In our context, these schemas are stored on-chain as a blob, which means they have a Blob Id as id and a DID as author:</p>
<pre><code class="language-json">{
   &quot;id&quot;: &quot;blob:dock:1DFdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW&quot;,
   &quot;author&quot;: &quot;did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW&quot;,
   &quot;schema&quot;: {
      &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
      &quot;description&quot;: &quot;Alumni&quot;,
      &quot;type&quot;: &quot;object&quot;,
      &quot;properties&quot;: {
        &quot;emailAddress&quot;: {
          &quot;type&quot;: &quot;string&quot;,
          &quot;format&quot;: &quot;email&quot;
        },
        &quot;alumniOf&quot;: {
          &quot;type&quot;: &quot;string&quot;
        }
      },
      &quot;required&quot;: [&quot;emailAddress&quot;, &quot;alumniOf&quot;],
      &quot;additionalProperties&quot;: false
    }
}
</code></pre>
<p>Had we referenced this JSON schema from within a Verifiable Credential, validation would fail if the <code>credentialSubject</code>
doesn't contain an <code>emailAddress</code> field, or it isn't a string formatted as an email; or if it doesn't contain a
property <code>alumniOf</code> with type string. It'd also fail if a subject contains other properties not listed here (except for
the <code>id</code> property which is popped out before validation).</p>
<h2 id="schemas-in-verifiable-credentials"><a class="header" href="#schemas-in-verifiable-credentials">Schemas in Verifiable Credentials</a></h2>
<p>In pursuit of <a href="https://w3c.github.io/vc-data-model/#extensibility">extensibility</a>, VCDM makes an Open World Assumption;
a credential can state anything. Schemas allow issuers to &quot;opt-out&quot; of some of the freedom VCDM allows. Issuers can
concretely limit what a given credential will claim. In a closed world, a verifier can rely on the structure of a
credential to enable new types of credential processing e.g. generating a complete and human-friendly graphical
representation of a credential.</p>
<p>The <a href="https://www.w3.org/TR/vc-data-model/">Verifiable Credentials Data Model</a> specifies the models used for Verifiable
Credentials and Verifiable Presentations, and explains the relationships between three parties: issuer, holder, and
verifier. A critical piece of infrastructure out of the scope of those specifications is the Credential Schema.
<a href="https://w3c-ccg.github.io/vc-json-schemas/">This specification</a> provides a mechanism to express a Credential Schema
and the protocols for evolving the schema.</p>
<p>Following our example above, we could use the current SDK to store the Email schema above as a Blob in the Dock chain.
Assuming we did that and our schema was stored as <code>blob:dock:1DFdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW</code>, we
can use it in a Verifiable Credential as follows:</p>
<pre><code class="language-json">&quot;credentialSchema&quot;: {
  &quot;id&quot;: &quot;blob:dock:1DFdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW&quot;,
  &quot;type&quot;: &quot;JsonSchemaValidator2018&quot;
}
</code></pre>
<p>The following is an example of a valid Verifiable Credential using the above schema:</p>
<pre><code class="language-json">{
   &quot;@context&quot;: [
      &quot;https://www.w3.org/2018/credentials/v1&quot;,
      &quot;https://www.w3.org/2018/credentials/examples/v1&quot;
   ],
   &quot;id&quot;: &quot;uuid:0x9b561796d3450eb2673fed26dd9c07192390177ad93e0835bc7a5fbb705d52bc&quot;,
   &quot;type&quot;: [
      &quot;VerifiableCredential&quot;,
      &quot;AlumniCredential&quot;
   ],
   &quot;issuanceDate&quot;: &quot;2020-03-18T19:23:24Z&quot;,
   &quot;credentialSchema&quot;: {
      &quot;id&quot;: &quot;blob:dock:1DFdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW&quot;,
      &quot;type&quot;: &quot;JsonSchemaValidator2018&quot;
   },
   &quot;credentialSubject&quot;: {
      &quot;id&quot;: &quot;did:dock:5GL3xbkr3vfs4qJ94YUHwpVVsPSSAyvJcafHz1wNb5zrSPGi&quot;,
      &quot;emailAddress&quot;: &quot;john.smith@example.com&quot;,
      &quot;alumniOf&quot;: &quot;Example University&quot;
   },
   &quot;issuer&quot;: &quot;did:dock:5GUBvwnV6UyRWZ7wjsBptSquiSHGr9dXAy8dZYUR9WdjmLUr&quot;,
   &quot;proof&quot;: {
      &quot;type&quot;: &quot;Ed25519Signature2018&quot;,
      &quot;created&quot;: &quot;2020-04-22T07:50:13Z&quot;,
      &quot;jws&quot;: &quot;eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..GBqyaiTMhVt4R5P2bMGcLNJPWEUq7WmGHG7Wc6mKBo9k3vSo7v7sRKwqS8-m0og_ANKcb5m-_YdXC2KMnZwLBg&quot;,
      &quot;proofPurpose&quot;: &quot;assertionMethod&quot;,
      &quot;verificationMethod&quot;: &quot;did:dock:5GUBvwnV6UyRWZ7wjsBptSquiSHGr9dXAy8dZYUR9WdjmLUr#keys-1&quot;
   }
}
</code></pre>
<p>In contrast, the following is an example of an invalid Verifiable Credential:</p>
<pre><code class="language-json">{
   &quot;@context&quot;: [
      &quot;https://www.w3.org/2018/credentials/v1&quot;,
      &quot;https://www.w3.org/2018/credentials/examples/v1&quot;
   ],
   &quot;id&quot;: &quot;uuid:0x9b561796d3450eb2673fed26dd9c07192390177ad93e0835bc7a5fbb705d52bc&quot;,
   &quot;type&quot;: [
      &quot;VerifiableCredential&quot;,
      &quot;AlumniCredential&quot;
   ],
   &quot;issuanceDate&quot;: &quot;2020-03-18T19:23:24Z&quot;,
   &quot;credentialSchema&quot;: {
      &quot;id&quot;: &quot;blob:dock:1DFdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW&quot;,
      &quot;type&quot;: &quot;JsonSchemaValidator2018&quot;
   },
   &quot;credentialSubject&quot;: [
      {
        &quot;id&quot;: &quot;did:dock:5GL3xbkr3vfs4qJ94YUHwpVVsPSSAyvJcafHz1wNb5zrSPGi&quot;,
        &quot;emailAddress&quot;: &quot;john.smith@example.com&quot;,
        &quot;alumniOf&quot;: &quot;Example University&quot;
      },
      {
        &quot;id&quot;: &quot;did:dock:6DF3xbkr3vfs4qJ94YUHwpVVsPSSAyvJcafHz1wNb5zrSPGi&quot;,
      }

   ],
   &quot;issuer&quot;: &quot;did:dock:5GUBvwnV6UyRWZ7wjsBptSquiSHGr9dXAy8dZYUR9WdjmLUr&quot;,
   &quot;proof&quot;: {
      &quot;type&quot;: &quot;Ed25519Signature2018&quot;,
      &quot;created&quot;: &quot;2020-04-22T07:50:13Z&quot;,
      &quot;jws&quot;: &quot;eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..GBqyaiTMhVt4R5P2bMGcLNJPWEUq7WmGHG7Wc6mKBo9k3vSo7v7sRKwqS8-m0og_ANKcb5m-_YdXC2KMnZwLBg&quot;,
      &quot;proofPurpose&quot;: &quot;assertionMethod&quot;,
      &quot;verificationMethod&quot;: &quot;did:dock:5GUBvwnV6UyRWZ7wjsBptSquiSHGr9dXAy8dZYUR9WdjmLUr#keys-1&quot;
   }
}
</code></pre>
<p>the reason this last Credential is invalid is that only one of the subjects properly follow the Schema, the second
subject does not specify the fields <code>emailAddress</code> and <code>alumniOf</code> which were specified as required.</p>
<h1 id="claim-deduction"><a class="header" href="#claim-deduction">Claim Deduction</a></h1>
<p>The <a href="https://www.w3.org/TR/vc-data-model/">verifiable credentials data model</a> is based on a machine comprehensible language called <a href="https://www.w3.org/TR/rdf-primer/">RDF</a>. RDF represents arbitrary semantic knowledge as <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">graph</a>s. Computers can perform automatic deductive reasoning over RDF, given assumptions (represented as an RDF graph) and axioms (represented as logical rules), a computer can infer new conclusions and even prove them to other computers using deductive derivations (proofs).</p>
<p>So what does that have to do with verifiable credentials? Every VCDM credential is an RDF claim graph. Computers can reason about them, deriving new conclusions that weren't explicitly stated by the issuer.</p>
<p>The Dock SDK exposes utilities for primitive deductive reasoning over verified credentials. The Verifier has a choice to perform deduction themself (expensive), or offload that responsibility to the Presenter of the credential[s] by accepting deductive proofs of composite claims.</p>
<p>In RDF, if graph A is true and graph B is true, then the <a href="https://en.wikipedia.org/wiki/Union_(set_theory)">union</a> of those graphs, is also true <code>A∧B-&gt;A∪B</code> <sup class="footnote-reference"><a href="#1">1</a></sup>. Using this property we can combine multiple credentials and reason over their union.</p>
<h2 id="explicit-ethos-using-a-hrefhttpsenwikipediaorgwikimodes_of_persuasionethosrdf-reificationa"><a class="header" href="#explicit-ethos-using-a-hrefhttpsenwikipediaorgwikimodes_of_persuasionethosrdf-reificationa">Explicit Ethos using <a href="https://en.wikipedia.org/wiki/Modes_of_persuasion#Ethos">RDF Reification</a></a></h2>
<p>Imagine a signed credential issued by <strong>Alice</strong> claiming that <strong>Joe</strong> is a <strong>Member</strong>.</p>
<pre><code class="language-json">{
  ...
  &quot;issuer&quot;: &quot;Alice&quot;,
  &quot;credentialSubject&quot;: {
    &quot;id&quot;: &quot;Joe&quot;,
    &quot;@type&quot;: &quot;Member&quot;
  },
  ...
}
</code></pre>
<p>The credential does not directly prove that <strong>Joe</strong> is a <strong>Member</strong>. Rather, it proves <strong>Alice</strong> <strong>Claims</strong> <strong>Joe</strong> to be a <strong>Member</strong>.</p>
<p>Not proven:<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<pre><code class="language-turtle">&lt;Joe&gt; a &lt;Member&gt; .
</code></pre>
<p>Proven:</p>
<pre><code class="language-turtle">&lt;Alice&gt; &lt;Claims&gt; [
  rdf:subject &lt;Joe&gt; ;
  rdf:predicate a ;
  def:object &lt;Member&gt; ] .
</code></pre>
<p>Writing RDF triples about other RDF triples is called <a href="https://www.w3.org/wiki/RdfReification">reification</a>. Signed credentials are <a href="https://en.wikipedia.org/wiki/Modes_of_persuasion#Ethos">ethos</a> arguments so we call this reified representation of credentials &quot;Explicit Ethos&quot; form. If a credential is <em>verified</em>, then it's explicit ethos form is <em>true</em>.</p>
<h2 id="rule-format"><a class="header" href="#rule-format">Rule Format</a></h2>
<p>To perform reasoning and to accept proofs, the Verifier must select the list of logical rules which they will allow. Rules (or axioms if you prefer), are modeled as if-then relationships.</p>
<pre><code class="language-js">const rules = [
  {
    if_all: [],
    then: [],
  },
];
</code></pre>
<p>During reasoning, when an <code>if_all</code> pattern is matched, its corresponding <code>then</code> pattern will be implied. In logic terms, each &quot;rule&quot; is the conditional premise of a <a href="https://en.wikipedia.org/wiki/Modus_ponens">modus ponens</a>.</p>
<pre><code class="language-js">{ if_all: [A, B, C], then: [C, D, E] }
</code></pre>
<p>means <code>if (A and B and C) then (C and D and E)</code>.</p>
<p>Rules can contain Bound or Unbound entities. Unbound entities are named variables. Each rule has it's own unique scope, so Unbound entities introduced in the <code>if_all</code> pattern can be used in the <code>then</code> pattern.</p>
<pre><code class="language-js">{
  if_all: [
    [{ Bound: alice }, { Bound: likes }, { Unbound: 'thing' }],
  ],
  then: [
    [{ Bound: bob }, { Bound: likes }, { Unbound: 'thing' }]
  ],
}
</code></pre>
<p>means</p>
<pre><code>For any ?thing:
  if [alice likes ?thing]
  then [bob likes ?thing]
</code></pre>
<p>in other words: <code>∀ thing: [alice likes thing] -&gt; [bob likes thing]</code></p>
<p>Bound entities are constants of type RdfNode. RDF nodes may be one of three things, an IRI, a blank node, or a literal. For those familiar with algebraic datatypes:</p>
<pre><code class="language-rust ignore">enum RdfNode {
  Iri(Url),
  Blank(String),
  Literal {
    value: String,
    datatype: Url,
  },
}
</code></pre>
<p>The SDK represents RDF nodes like so:</p>
<pre><code class="language-js">const alice = { Iri: 'did:sample:alice' };
const literal = {
  Literal: {
    value: '{}',
    datatype: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#JSON',
  }
};
// blank nodes are generally not useful in rule definitions
const blank = { Blank: '_:b0' };
</code></pre>
<p>Example of a complete rule definition:</p>
<pre><code class="language-js">{
  if_all: [
    [
      { Unbound: 'food' },
      { Bound { Iri: 'https://example.com/contains' } },
      { Bound: { Iri: 'https://example.com/butter' } }
    ],
    [
      { Unbound: 'person' },
      { Bound: 'http://xmlns.com/foaf/0.1/name' },
      { Literal: {
        value: 'Bob',
        datatype: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral',
      } }
    ],
  ],
  then: [
    [
      { Unbound: 'person' },
      { Bound: { Iri: 'https://example.com/likes' } },
      { Unbound: 'food' },
    ]
  ],
}
// all things named &quot;Bob&quot; like all things containing butter
</code></pre>
<p>See the <a href="tutorial_claim_deduction.html">claim deduction tutorial</a> for more another example.</p>
<h2 id="limited-expresiveness"><a class="header" href="#limited-expresiveness">Limited Expresiveness</a></h2>
<p>The astute among you may notice the SDK's model for rules does not allow logical negation. This is by design. For one, it keeps the the rule description language from being turing complete so inference time is always bounded. Secondly, RDF choses the <a href="https://en.wikipedia.org/wiki/Open-world_assumption">Open World Assumption</a> so absence of any particular statement in a credential/claimgraph is not meaningful within RDF semantics.</p>
<p>The rule language is expected to be expressive enough to implement <a href="https://www.w3.org/TR/owl2-profiles/#OWL_2_EL">OWL 2 EL</a> but not <a href="https://www.w3.org/TR/owl-ref/">OWL 1 DL</a>.</p>
<h2 id="terms"><a class="header" href="#terms">Terms</a></h2>
<ul>
<li><a href="https://www.w3.org/TR/vc-data-model/#dfn-verifier">Verifier</a>: The party that accepts and checks VCDM credential[s].</li>
<li><a href="https://www.w3.org/TR/vc-data-model/#dfn-issuer">Issuer</a>: The party that signed a VCDM credential.</li>
<li><a href="https://www.w3.org/TR/vc-data-model/">VCDM</a>: Verifiable Credentials Data Model</li>
<li><a href="https://en.wikipedia.org/wiki/Resource_Description_Framework">RDF</a>: A model for representing general knowledge in a machine friendly way.</li>
<li>RDF triple: A single sentence consisting of subject, predicate and object. Each element of the triple is an RDF node.</li>
<li><a href="https://www.w3.org/TR/rdf-primer/#rdfmodel">RDF graph</a>: A directed, labeled <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">graph</a> with RDF triples as edges.</li>
<li><a href="https://www.w3.org/TR/rdf-primer/#rdfmodel">RDF node</a></li>
<li>Composite Claim: An rdf triple which was infered, rather than stated explicitly in a credential.</li>
<li>Explicit <a href="https://en.wikipedia.org/wiki/Modes_of_persuasion#Ethos">Ethos</a> statement: A statement of the form &quot;A claims X.&quot; where X is also a statement. Explicit Ethos is encodable in natural human languages as well as in RDF.</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>If you ever decide to implement your own algorithm to merge RDF graphs, remember that <a href="https://www.w3.org/TR/rdf11-concepts/#section-blank-nodes">blank nodes</a> exists and may need to be renamed depending on the type of graph representation in use.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>This syntax is an RDF representation called <a href="https://www.w3.org/TR/turtle/">turtle</a>. In turtle, &quot;a&quot; is shorthand for &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; which means &quot;is member of set&quot;.</p>
</div>
<p>The Dock Blockchain includes a module explicitly intended for proof of existence. Aside from being explicitly supported by the on-chain runtime, it works the same way you would expect. You post the hash of a document on-chain at a specific block. Later you can use that hash to prove the document existed at or before that block.</p>
<p>The PoE module accepts arbitrary bytes as an anchor but in order to keep anchor size constant the chain stores only the blake2b256 hash of those bytes.</p>
<p>Developers are free to use the anchoring module however they want, taloring their software to their own use case. An anchoring example can be found in the sdk examples directory. Dock provides a <a href="https://fe.dock.io/#/anchor/batch">fully functioning reference client</a> for anchoring. The client even implements batching anchors into a merkle tree so you can anchor multiple documents in a single transaction.</p>
<h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<ol>
<li><a href="./tutorial_did.html">DID</a></li>
<li><a href="./tutorial_revocation.html">Revocation</a></li>
<li><a href="./tutorial_ipv.html">Verifiable credentials</a></li>
<li><a href="./tutorial_blobs_schemas.html">Blobs and Schemas</a></li>
</ol>
<h1 id="did"><a class="header" href="#did">DID</a></h1>
<p>If you are not familiar with DIDs, you can get a conceptual overview <a href="./concepts_did.html">here</a>.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>DIDs in Dock are created by choosing a 32 byte unique (on Dock chain) identifier along with a public key. The public key
can be changed by providing a signature with the currently active key.</p>
<p>The DID can also be removed by providing a signature with the currently active key. As of now, a DID can have only one key
at a time.</p>
<p>The chain-state stores a few things for a DID, the current public key, the controller and the block number when the DID was
last updated, so in the beginning the block number would be the one where the DID was created, when a DID's key is updated,
that block number is changed to the one in which the key got updated.</p>
<p>This is done for replay protection as every update (or removal) to the DID must include the last block number where the DID
was updated and after each update the block number changes, thus giving replay protection. This detail however is hidden in
the API so the caller should not have to worry about this.</p>
<h2 id="did-creation"><a class="header" href="#did-creation">DID creation</a></h2>
<p>Create a new random DID.</p>
<pre><code class="language-js">import {createNewDockDID} from '@docknetwork/sdk/utils/did';

const did = createNewDockDID();
</code></pre>
<p>The DID is not yet registered on the chain. Before the DID can be registered, a public key needs to created as well.</p>
<h2 id="public-key-creation"><a class="header" href="#public-key-creation">Public key creation</a></h2>
<p>Dock supports 3 kinds of public keys, Sr25519, Ed25519 and EcdsaSecp256k1. These public keys are supported
through 3 classes, <code>PublicKeySr25519</code>, <code>PublicKeyEd25519</code> and <code>PublicKeySecp256k1</code> respectively.</p>
<p>These 3 classes extend from the same class called <code>PublicKey</code>. These can be instantiated directly by passing them as hex
encoded bytes.</p>
<pre><code class="language-js">import {PublicKeySr25519, PublicKeyEd25519, PublicKeySecp256k1} from '@docknetwork/sdk/api';

const pk1 = new PublicKeySr25519(bytesAsHex);
const pk2 = new PublicKeyEd25519(bytesAsHex);
const pk3 = new PublicKeySecp256k1(bytesAsHex);
</code></pre>
<p>Or they can be created by first creating a keyring</p>
<pre><code class="language-js">import {PublicKeySr25519, PublicKeyEd25519} from '@docknetwork/sdk/api';

// Assuming you had a keyring, you can create keypairs or used already created keypairs
const pair1 = keyring.addFromUri(secretUri, someMetadata, 'ed25519');
const pk1 = PublicKeyEd25519.fromKeyringPair(pair1);

const pair2 = keyring.addFromUri(secretUri2, someMetadata, 'sr25519');
const pk2 = PublicKeySr25519.fromKeyringPair(pair2);

</code></pre>
<p>Polkadot-js keyring does not support ECDSA with secp256k1 so there is a function <code>generateEcdsaSecp256k1Keypair</code> that
takes some entropy and generate a keypair.</p>
<pre><code class="language-js">import { generateEcdsaSecp256k1Keypair } from '@docknetwork/sdk/utils/misc';
import {PublicKeySecp256k1} from '@docknetwork/sdk/api';
// The pers and entropy are optional but must be used when keys need to be deterministic
const pair3 = generateEcdsaSecp256k1Keypair(pers, entropy);
const pk3 = PublicKeySecp256k1.fromKeyringPair(pair3);
</code></pre>
<p>Or you can directly pass any of the above keypairs in the function <code>getPublicKeyFromKeyringPair</code> and it will return an
object of the proper child class of <code>PublicKey</code></p>
<pre><code class="language-js">import { getPublicKeyFromKeyringPair } from '@docknetwork/sdk/utils/misc';
const publicKey = getPublicKeyFromKeyringPair(pair);
</code></pre>
<h2 id="registering-a-new-did-on-chain"><a class="header" href="#registering-a-new-did-on-chain">Registering a new DID on chain</a></h2>
<p>Now that you have a DID and a public key, the DID can be registered on the Dock chain. Note that this public key associated
with DID is independent of the key used for sending the transaction and paying the fees.</p>
<ol>
<li>
<p>First create a key detail object. The first argument of this function is a <code>PublicKey</code> and the second argument is
the controller.</p>
<p>The controller is the DID that controls the public key and this can be the same as the DID being
registered.</p>
<pre><code class="language-js">import {createKeyDetail} from '@docknetwork/sdk/utils/did';
const keyDetail = createKeyDetail(publicKey, did);
</code></pre>
</li>
<li>
<p>Now submit the transaction using a <code>DockAPI</code> object and the newly created DID <code>did</code> and <code>keyDetail</code>.</p>
<pre><code class="language-js">await dock.did.new(did, keyDetail);
</code></pre>
</li>
</ol>
<h2 id="fetching-a-did-from-chain"><a class="header" href="#fetching-a-did-from-chain">Fetching a DID from chain</a></h2>
<p>To get a DID document, use <code>getDocument</code>
<code>js const result = await dock.did.getDocument(did); </code></p>
<h2 id="updating-an-existing-did-on-chain"><a class="header" href="#updating-an-existing-did-on-chain">Updating an existing DID on chain</a></h2>
<p>The public key or the controller of an on-chain DID can be updated by preparing a signed key update.</p>
<ol>
<li>Create a new public key and fetch the current keypair to sign the key update message
<pre><code class="language-js">// the current pair, its a sr25519 in this example
const currentPair = dock.keyring.addFromUri(secretUri, null, 'sr25519');
const newPk = // Using any of the above methods
</code></pre>
</li>
<li>The caller might directly create a signed key update
<pre><code class="language-js">import {createSignedKeyUpdate} from '@docknetwork/sdk/utils/did';
// If you do not wish to update the controller, don't pass `newController`
const [keyUpdate, signature] = await createSignedKeyUpdate(dock.did, did, newPk, currentPair, newController);
</code></pre>
</li>
<li>In some cases the caller might not have the keypair like a hardware wallet or a remote signer, in that case, the caller
creates the key update message bytes with <code>createKeyUpdate</code> to pass to the signer and get the signature
<pre><code class="language-js">import {createKeyUpdate} from '@docknetwork/sdk/utils/did';
const keyUpdate = await createKeyUpdate(dock.did, did, newPk, newController);
const signature = // Get the signature on `keyUpdate`
</code></pre>
</li>
<li>Now send the key update message with the signature to the chain in a transaction
<pre><code class="language-js">await dock.did.updateKey(keyUpdate, signature);
</code></pre>
</li>
</ol>
<h2 id="removing-an-existing-did-from-chain"><a class="header" href="#removing-an-existing-did-from-chain">Removing an existing DID from chain</a></h2>
<p>A DID can be removed from the chain by sending the corresponding message signed with the current key.</p>
<ol>
<li>Fetch the current keypair to sign the DID removal message
<pre><code class="language-js">// the current pair, its a sr25519 in this example
const currentPair = dock.keyring.addFromUri(secretUri, null, 'sr25519');
</code></pre>
</li>
<li>The caller might directly create a signed message
<pre><code class="language-js">import {createSignedDidRemoval} from '@docknetwork/sdk/utils/did';
const [didRemoval, signature] = await createSignedDidRemoval(dock.did, dockDID, currentPair);
</code></pre>
</li>
<li>As mentioned above, in some cases the caller might not have the keypair, then he creates the removal message bytes
with <code>createDidRemoval</code> to pass to the signer and get the signature
<pre><code class="language-js">import {createDidRemoval} from '@docknetwork/sdk/utils/did';
const didRemoval = await createDidRemoval(dock.did, did);
const signature = // Get the signature on `didRemoval`
</code></pre>
</li>
<li>Now send the message with the signature to the chain in a transaction
<pre><code class="language-js">await dock.did.remove(didRemoval, signature);
</code></pre>
</li>
</ol>
<p>Note that they accounts used to send the transactions are independent of the keys associated with the DID.</p>
<p>So the DID could have been created with one account, updated with another account and removed with another account.</p>
<p>The accounts are not relevant in the data model and not associated with the DID in the chain-state.</p>
<h1 id="did-resolver"><a class="header" href="#did-resolver">DID resolver</a></h1>
<p>The process of learning the DID Document of a DID is called DID resolution and tool that does the resolution is called the
resolver.</p>
<p>Resolution involves looking at the DID method and then fetching the DID Document from the registry, the registry
might be a centralized database or a blockchain.</p>
<p>The SDK supports resolving Dock DIDs natively. For other DIDs, resolving the DID through the
<a href="https://uniresolver.io">Universal Resolver</a> is supported.</p>
<p>Each resolver should extend the class <code>DIDResolver</code> and implement the <code>resolve</code> method that accepts a DID and returns the
DID document.</p>
<p>There is another class called <code>MultiResolver</code> that can accept several types of resolvers (objects of subclasses
of <code>DIDResolver</code>) and once the <code>MultiResolver</code> is initialized with the resolvers of different DID methods, it can resolve
DIDs of those methods.</p>
<h2 id="dock-resolver"><a class="header" href="#dock-resolver">Dock resolver</a></h2>
<p>The resolver for Dock DIDs <code>DockResolver</code> connects to the Dock blockchain to get the DID details.</p>
<p>The resolver is constructed by passing it a Dock API object so that it can connect to a Dock node.
This is how you resolve a Dock DID:</p>
<pre><code class="language-js">import { DockResolver } from '@docknetwork/sdk/resolver';

// Assuming the presence of Dock API object `dock`
const dockResolver = new DockResolver(dock);
// Say you had a DID `dock:did:5D.....`
const didDocument = dockResolver.resolve('dock:did:5D.....');
</code></pre>
<h2 id="creating-a-resolver-class-for-a-different-method"><a class="header" href="#creating-a-resolver-class-for-a-different-method">Creating a resolver class for a different method</a></h2>
<p>If you want to resolve DIDs other than Dock and do not have/want access to the universal resolver, you can extend the
<code>DIDResolver</code> class to create a custom resolver.</p>
<p>Following is an example to build a custom Ethereum resolver. It uses the library
<a href="https://github.com/decentralized-identity/ethr-did-resolver">ethr-did-resolver</a> and accepts a provider information
as configuration. The example below uses Infura to get access to an Ethereum node and read the DID off Ethereum.</p>
<pre><code class="language-js">import { DIDResolver } from '@docknetwork/sdk/resolver';
import ethr from 'ethr-did-resolver';

// Infura's Ethereum provider for the main net.
const ethereumProviderConfig = {
  networks: [
    {
      name: 'mainnet',
      rpcUrl: 'https://mainnet.infura.io/v3/blahblahtoken',
    },
  ],
};

// Custom ethereum resolver class
class EtherResolver extends DIDResolver {
  constructor(config) {
    super();
    this.ethres = ethr.getResolver(config).ethr;
  }

  async resolve(did) {
    const parsed = this.parseDid(did);
    try {
      return await this.ethres(did, parsed);
    } catch (e) {
      throw new NoDIDError(did);
    }
  }
}

// Construct the resolver
const ethResolver = new EtherResolver(ethereumProviderConfig);

// Say you had a DID `did:ethr:0x6f....`
const didDocument = ethResolver.resolve('did:ethr:0x6f....');
</code></pre>
<h2 id="universal-resolver"><a class="header" href="#universal-resolver">Universal resolver</a></h2>
<p>To resolve DIDs using the <a href="https://uniresolver.io">Universal Resolver</a>, use the <code>UniversalResolver</code>. It needs the URL
of the universal resolver and assumes the universal resolver from this <a href="https://github.com/decentralized-identity/universal-resolver">codebase</a>
is running at the URL.</p>
<pre><code class="language-js">import { UniversalResolver } from '@docknetwork/sdk/resolver';

// Change the resolver URL to something else in case you cannot use the resolver at https://uniresolver.io
const universalResolverUrl = 'https://uniresolver.io';
const universalResolver = new UniversalResolver(universalResolverUrl);

// Say you had a DID `did:btcr:xk....`
const didDocument = universalResolver.resolve('did:btcr:xk....');
</code></pre>
<h2 id="resolving-dids-of-several-did-methods-with-a-single-resolver"><a class="header" href="#resolving-dids-of-several-did-methods-with-a-single-resolver">Resolving DIDs of several DID methods with a single resolver</a></h2>
<p>In case you need to resolve DIDs from more than one method, a <code>MultiResolver</code> object can be created by passing
resolvers of various DID methods.</p>
<p>The <code>MultiResolver</code> also accepts a <code>UniversalResolver</code> as an optional parameter which
is used when a DID for an unknown method needs to be resolved. The <code>resolvers</code> object below has resolvers for DID methods
<code>dock</code> and <code>ethr</code>.</p>
<p>For resolving DID of any other method, the given <code>UniversalResolver</code> object will be used.</p>
<pre><code class="language-js">import { MultiResolver } from '@docknetwork/sdk/resolver';


const resolvers = {
    dock: new DockResolver(dock), // Prebuilt resolver
    ethr: new EtherResolver(ethereumProviderConfig), // Custom resolver
  };

const multiResolver = new MultiResolver(resolvers, new UniversalResolver(universalResolverUrl));

// Say you had a DID `did:dock:5D....`, then the `DockResolver` will be used as there a resolver for Dock DID.
const didDocumentDock = multiResolver.resolve('did:dock:5D....');

// Say you had a DID `did:btcr:xk....`, then the `UniversalResolver` will be used as there is no resolver for BTC DID.
const didDocumentBtc = multiResolver.resolve('did:btcr:xk....');
</code></pre>
<h1 id="verifiable-credentials-and-verifiable-presentations-issuing-signing-and-verification"><a class="header" href="#verifiable-credentials-and-verifiable-presentations-issuing-signing-and-verification">Verifiable Credentials and Verifiable Presentations: issuing, signing and verification</a></h1>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of contents</a></h2>
<ul>
<li><a href="tutorial_ipv.html#incremental-creation-and-verification-of-verifiable-credentials">Incremental creation and verification of VC</a>
<ul>
<li><a href="tutorial_ipv.html#building-a-verifiable-credential">Building a Verifiable Credential</a>
<ul>
<li><a href="tutorial_ipv.html#adding-a-context">Adding a Context</a></li>
<li><a href="tutorial_ipv.html#adding-a-type">Adding a Type</a></li>
<li><a href="tutorial_ipv.html#adding-a-subject">Adding a Subject</a></li>
<li><a href="tutorial_ipv.html#setting-a-status">Setting a Status</a></li>
<li><a href="tutorial_ipv.html#setting-the-issuance-date">Setting the Issuance Date</a></li>
<li><a href="tutorial_ipv.html#setting-an-expiration-date">Setting an Expiration Date</a></li>
</ul>
</li>
<li><a href="tutorial_ipv.html#signing-a-verifiable-credential">Signing a Verifiable Credential</a></li>
<li><a href="tutorial_ipv.html#verifying-a-verifiable-credential">Verifying a Verifiable Credential</a></li>
</ul>
</li>
<li><a href="tutorial_ipv.html#incremental-creation-and-verification-of-verifiable-presentations">Incremental creation and verification of VP</a>
<ul>
<li><a href="tutorial_ipv.html#building-a-verifiable-presentation">Building a Verifiable Presentation</a>
<ul>
<li><a href="tutorial_ipv.html#adding-a-context">Adding a Context</a></li>
<li><a href="tutorial_ipv.html#adding-a-type">Adding a Type</a></li>
<li><a href="tutorial_ipv.html#setting-a-holder">Setting a Holder</a></li>
<li><a href="tutorial_ipv.html#adding-a-verifiable-credential">Adding a Verifiable Credential</a></li>
</ul>
</li>
<li><a href="tutorial_ipv.html#signing-a-verifiable-presentation">Signing a Verifiable Presentation</a></li>
<li><a href="tutorial_ipv.html#verifying-a-verifiable-presentation">Verifying a Verifiable Presentation</a></li>
</ul>
</li>
<li><a href="tutorial_ipv.html#using-dids">Using DIDs</a></li>
<li><a href="tutorial_ipv.html#creating-a-keydoc">Creating a keyDoc</a></li>
</ul>
<hr />
<h2 id="incremental-creation-and-verification-of-verifiable-credentials"><a class="header" href="#incremental-creation-and-verification-of-verifiable-credentials">Incremental creation and verification of Verifiable Credentials</a></h2>
<p>The <code>client-sdk</code> exposes a <code>VerifiableCredential</code> class that is useful to incrementally create valid Verifiable Credentials of any type, sign them and verify them.
Once the credential is initialized, you can sequentially call the different methods provided by the class to add contexts, types, issuance dates and everything else.</p>
<h3 id="building-a-verifiable-credential"><a class="header" href="#building-a-verifiable-credential">Building a Verifiable Credential</a></h3>
<p>The first step to build a Verifiable Credential is to initialize it, we can do that using the <code>VerifiableCredential</code> class constructor which takes a <code>credentialId</code> as sole argument:</p>
<pre><code class="language-javascript">let vc = new VerifiableCredential('http://example.edu/credentials/2803');
</code></pre>
<p>You now have an unsigned Verifiable Credential in the <code>vc</code> variable!
This Credential isn't signed since we only just initialized it. It brings however some useful defaults to make your life easier.</p>
<pre><code class="language-javascript">&gt;    vc.context
&lt;-   [&quot;https://www.w3.org/2018/credentials/v1&quot;]
&gt;    vc.issuanceDate
&lt;-   &quot;2020-04-14T14:48:48.486Z&quot;
&gt;    vc.type
&lt;-   [&quot;VerifiableCredential&quot;]
&gt;    vc.credentialSubject
&lt;-   []
</code></pre>
<p>The default <code>context</code> is an array with
<code>&quot;https://www.w3.org/2018/credentials/v1&quot;</code> as first element. This is required
by the VCDMv1 specs so having it as default helps ensure your Verifiable
Credentials will be valid in the end.</p>
<p>A similar approach was taken on the <code>type</code> property, where the default is an
array with <code>&quot;VerifiableCredential&quot;</code> already populated. This is also required
by the specs. The <code>subject</code> property is required to exist, so this is already
initialized for you as well although it is empty for now. Finally the
<code>issuanceDate</code> is also set to the moment you initialized the
<code>VerifiableCredential</code> object. You can change this later if desired but it
helps having it in the right format from the get go.</p>
<p>We could also have checked those defaults more easily by checking the
Verifiable Credential's JSON representation.</p>
<p>This can be achieved by calling the <code>toJSON()</code> method on it:</p>
<pre><code class="language-javascript">&gt;    vc.toJSON()
&lt;-   {
       &quot;@context&quot;: [ &quot;https://www.w3.org/2018/credentials/v1&quot; ],
       &quot;credentialSubject&quot;: [],
       &quot;id&quot;: &quot;http://example.edu/credentials/2803&quot;,
       &quot;type&quot;: [
         &quot;VerifiableCredential&quot;
       ],
       &quot;issuanceDate&quot;: &quot;2020-04-14T14:48:48.486Z&quot;
     }
</code></pre>
<p>An interesting thing to note here is the transformation happening to some of
the root level keys in the JSON representation of a <code>VerifiableCredential</code>
object.</p>
<p>For example <code>context</code> gets transformed into <code>@context</code> and <code>subject</code>
into <code>credentialSubject</code>.</p>
<p>This is to ensure compliance with the Verifiable Credential Data Model specs
while at the same time providing you with a clean interface to the
<code>VerifiableCredential</code> class in your code.</p>
<p>Once your Verifiable Credential has been initialized, you can proceed to use
the rest of the building functions to define it completely before finally
signing it.</p>
<h4 id="adding-a-context"><a class="header" href="#adding-a-context">Adding a Context</a></h4>
<p>A context can be added with the <code>addContext</code> method. It accepts a single argument <code>context</code> which can either be a string (in which case it needs to be a valid URI), or an object:</p>
<pre><code class="language-javascript">&gt;   vc.addContext('https://www.w3.org/2018/credentials/examples/v1')
&gt;   vc.context
&lt;-  [
      'https://www.w3.org/2018/credentials/v1',
      'https://www.w3.org/2018/credentials/examples/v1'
    ])
</code></pre>
<h4 id="adding-a-type"><a class="header" href="#adding-a-type">Adding a Type</a></h4>
<p>A type can be added with the <code>addType</code> function. It accepts a single argument <code>type</code> that needs to be a string:</p>
<pre><code class="language-javascript">&gt;   vc.addType('AlumniCredential')
&gt;   vc.type
&lt;-  [
      'VerifiableCredential',
      'AlumniCredential'
    ]
</code></pre>
<h4 id="adding-a-subject"><a class="header" href="#adding-a-subject">Adding a Subject</a></h4>
<p>A subject can be added with the <code>addSubject</code> function. It accepts a single argument <code>subject</code> that needs to be an object with an <code>id</code> property:</p>
<pre><code class="language-javascript">&gt;   vc.addSubject({ id: 'did:dock:123qwe123qwe123qwe', alumniOf: 'Example University' })
&gt;   vc.credentialSubject
&lt;-  {id: 'did:dock:123qwe123qwe123qwe', alumniOf: 'Example University'}
</code></pre>
<h4 id="setting-a-status"><a class="header" href="#setting-a-status">Setting a Status</a></h4>
<p>A status can be set with the <code>setStatus</code> function. It accepts a single argument <code>status</code> that needs to be an object with an <code>id</code> property:</p>
<pre><code class="language-javascript">&gt;   vc.setStatus({ id: &quot;https://example.edu/status/24&quot;, type: &quot;CredentialStatusList2017&quot; })
&gt;   vc.status
&lt;-  {
        &quot;id&quot;: &quot;https://example.edu/status/24&quot;,
        &quot;type&quot;: &quot;CredentialStatusList2017&quot;
    }
</code></pre>
<h4 id="setting-the-issuance-date"><a class="header" href="#setting-the-issuance-date">Setting the Issuance Date</a></h4>
<p>The issuance date is set by default to the datetime you first initialize your
<code>VerifiableCredential</code> object.</p>
<p>This means that you don't necessarily need to
call this method to achieve a valid Verifiable Credential (which are required
to have an issuanceDate property).</p>
<p>However, if you need to change this date you can use the <code>setIssuanceDate</code>
method. It takes a single argument <code>issuanceDate</code> that needs to be a string
with a valid ISO formatted datetime:</p>
<pre><code class="language-javascript">&gt;   vc.issuanceDate
&lt;-  &quot;2020-04-14T14:48:48.486Z&quot;
&gt;   vc.setIssuanceDate(&quot;2019-01-01T14:48:48.486Z&quot;)
&gt;   vc.issuanceDate
&lt;-  &quot;2019-01-01T14:48:48.486Z&quot;
</code></pre>
<h4 id="setting-an-expiration-date"><a class="header" href="#setting-an-expiration-date">Setting an Expiration Date</a></h4>
<p>An expiration date is not set by default as it isn't required by the specs.
If you wish to set one, you can use the <code>setExpirationDate</code> method.</p>
<p>It takes a single argument <code>expirationDate</code> that needs to be a string with a
valid ISO formatted datetime:</p>
<pre><code class="language-javascript">&gt;   vc.setExpirationDate(&quot;2029-01-01T14:48:48.486Z&quot;)
&gt;   vc.expirationDate
&lt;-  &quot;2029-01-01T14:48:48.486Z&quot;
</code></pre>
<h3 id="signing-a-verifiable-credential"><a class="header" href="#signing-a-verifiable-credential">Signing a Verifiable Credential</a></h3>
<p>Once you've crafted your Verifiable Credential it is time to sign it. This
can be achieved with the <code>sign</code> method.</p>
<p>It requires a <code>keyDoc</code> parameter (an object with the params and keys you'll
use for signing) and it also accepts a boolean <code>compactProof</code> that determines
whether you want to compact the JSON-LD or not:</p>
<pre><code class="language-javascript">&gt;   await vc.sign(keyDoc)
</code></pre>
<p>Please note that signing is an async process.
Once done, your <code>vc</code> object will have a new <code>proof</code> field:</p>
<pre><code class="language-javascript">&gt;   vc.proof
&lt;-  {
        type: &quot;EcdsaSecp256k1Signature2019&quot;,
        created: &quot;2020-04-14T14:48:48.486Z&quot;,
        jws: &quot;eyJhbGciOiJFUzI1NksiLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ..MEQCIAS8ZNVYIni3oShb0TFz4SMAybJcz3HkQPaTdz9OSszoAiA01w9ZkS4Zx5HEZk45QzxbqOr8eRlgMdhgFsFs1FnyMQ&quot;,
        proofPurpose: &quot;assertionMethod&quot;,
        verificationMethod: &quot;https://gist.githubusercontent.com/faustow/13f43164c571cf839044b60661173935/raw&quot;
    }
</code></pre>
<h3 id="verifying-a-verifiable-credential"><a class="header" href="#verifying-a-verifiable-credential">Verifying a Verifiable Credential</a></h3>
<p>Once your Verifiable Credential has been signed you can proceed to verify it
with the <code>verify</code> method. The <code>verify</code> method takes an object of arguments,
and is optional.</p>
<p>If you've used DIDs you need to pass a <code>resolver</code> for them.
You can also use the booleans <code>compactProof</code> (to compact the JSON-LD) and
<code>forceRevocationCheck</code> (to force revocation check). Please beware that
setting <code>forceRevocationCheck</code> to false can allow false positives when
verifying revocable credentials.</p>
<p>If your credential has uses the <code>status</code> field, you can pass a
<code>revocationApi</code> param that accepts an object describing the API to use for
the revocation check. No params are required for the simplest cases:</p>
<p>If your credential uses schema and requires blob resolution, you can pass a
<code>schemaApi</code> param that accepts an object describing the API to pull the
schema from chain. No params are required for the simplest cases:</p>
<pre><code class="language-javascript">&gt;   const result = await vc.verify({ ... })
&gt;   result
&lt;-  {
      verified: true,
      results: [
        {
          proof: [
            {
                '@context': 'https://w3id.org/security/v2',
                type: &quot;EcdsaSecp256k1Signature2019&quot;,
                created: &quot;2020-04-14T14:48:48.486Z&quot;,
                jws: &quot;eyJhbGciOiJFUzI1NksiLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ..MEQCIAS8ZNVYIni3oShb0TFz4SMAybJcz3HkQPaTdz9OSszoAiA01w9ZkS4Zx5HEZk45QzxbqOr8eRlgMdhgFsFs1FnyMQ&quot;,
                proofPurpose: &quot;assertionMethod&quot;,
                verificationMethod: &quot;https://gist.githubusercontent.com/faustow/13f43164c571cf839044b60661173935/raw&quot;
            }
          ],
          verified: true
        }
      ]
    }
</code></pre>
<p>Please note that the verification is an async process that returns an object
when the promise resolves. A boolean value for the entire verification
process can be checked at the root level <code>verified</code> property.</p>
<hr />
<h2 id="incremental-creation-and-verification-of-verifiable-presentations"><a class="header" href="#incremental-creation-and-verification-of-verifiable-presentations">Incremental creation and verification of Verifiable Presentations</a></h2>
<p>The <code>client-sdk</code> exposes a <code>VerifiablePresentation</code> class that is useful to
incrementally create valid Verifiable Presentations of any type, sign them
and verify them.</p>
<p>Once the presentation is initialized, you can sequentially call the different
methods provided by the class to add <code>contexts</code>, <code>types</code>, <code>holders</code> and
<code>credentials</code>.</p>
<h3 id="building-a-verifiable-presentation"><a class="header" href="#building-a-verifiable-presentation">Building a Verifiable Presentation</a></h3>
<p>The first step to build a Verifiable Presentation is to initialize it, we can
do that using the <code>VerifiablePresentation</code> class constructor which takes an
<code>id</code> as sole argument:</p>
<pre><code class="language-javascript">let vp = new VerifiablePresentation('http://example.edu/credentials/1986');
</code></pre>
<p>You now have an unsigned Verifiable Presentation in the <code>vp</code> variable!</p>
<p>This Presentation isn't signed since we only just initialized it. It brings
however some useful defaults to make your life easier.</p>
<pre><code class="language-javascript">&gt;    vp.context
&lt;-   [&quot;https://www.w3.org/2018/credentials/v1&quot;]
&gt;    vp.type
&lt;-   [&quot;VerifiablePresentation&quot;]
&gt;    vp.credentials
&lt;-   []
</code></pre>
<p>The default <code>context</code> is an array with
<code>&quot;https://www.w3.org/2018/credentials/v1&quot;</code> as first element. This is required
by the VCDMv1 specs so having it as default helps ensure your Verifiable
Presentations will be valid in the end.</p>
<p>A similar approach was taken on the <code>type</code> property, where the default is an
array with <code>&quot;VerifiablePresentation&quot;</code> already populated. This is also
required by the specs.</p>
<p>The <code>credentials</code> property is required to exist, so this is already
initialized for you as well although it is empty for now.</p>
<p>We could also have checked those defaults more easily by checking the
Verifiable Presentation's JSON representation.</p>
<p>This can be achieved by calling the <code>toJSON()</code> method on it:</p>
<pre><code class="language-javascript">&gt;    vp.toJSON()
&lt;-   {
       &quot;@context&quot;: [ &quot;https://www.w3.org/2018/credentials/v1&quot; ],
       &quot;id&quot;: &quot;http://example.edu/credentials/1986&quot;,
       &quot;type&quot;: [
         &quot;VerifiablePresentation&quot;
       ],
       &quot;verifiableCredential&quot;: [],
     }
</code></pre>
<p>An interesting thing to note here is the transformation happening to some of
the root level keys in the JSON representation of a <code>VerifiablePresentation</code>
object.</p>
<p>For example <code>context</code> gets transformed into <code>@context</code> and <code>credentials</code> into
<code>verifiableCredential</code>. This is to ensure compliance with the Verifiable
Credentials Data Model specs while at the same time providing you with a
clean interface to the <code>VerifiablePresentation</code> class in your code.</p>
<p>Once your Verifiable Presentation has been initialized, you can proceed to
use the rest of the building functions to define it completely before finally
signing it.</p>
<h4 id="adding-a-context-1"><a class="header" href="#adding-a-context-1">Adding a Context</a></h4>
<p>A context can be added with the <code>addContext</code> method. It accepts a single
argument <code>context</code> which can either be a string (in which case it needs to be
a valid URI), or an object</p>
<pre><code class="language-javascript">&gt;   vp.addContext('https://www.w3.org/2018/credentials/examples/v1')
&gt;   vp.context
&lt;-  [
      'https://www.w3.org/2018/credentials/v1',
      'https://www.w3.org/2018/credentials/examples/v1'
    ])
</code></pre>
<h4 id="adding-a-type-1"><a class="header" href="#adding-a-type-1">Adding a Type</a></h4>
<p>A type can be added with the <code>addType</code> function. It accepts a single argument <code>type</code> that needs to be a string:</p>
<pre><code class="language-javascript">&gt;   vp.addType('CredentialManagerPresentation')
&gt;   vp.type
&lt;-  [
      'VerifiablePresentation',
      'CredentialManagerPresentation'
    ]
</code></pre>
<h4 id="setting-a-holder"><a class="header" href="#setting-a-holder">Setting a Holder</a></h4>
<p>Setting a Holder is optional and it can be achieved using the <code>setHolder</code>
method. It accepts a single argument <code>type</code> that needs to be a string (a URI
for the entity that is generating the presentation):</p>
<pre><code class="language-javascript">&gt;   vp.setHolder('https://example.com/credentials/1234567890');
&gt;   vp.holder
&lt;-  'https://example.com/credentials/1234567890'
</code></pre>
<h4 id="adding-a-verifiable-credential"><a class="header" href="#adding-a-verifiable-credential">Adding a Verifiable Credential</a></h4>
<p>Your Verifiable Presentations can contain one or more Verifiable Credentials inside.</p>
<p>Adding a Verifiable Credential can be achieved using the <code>addCredential</code>
method. It accepts a single argument <code>credential</code> that needs to be an object
(a valid, signed Verifiable Credential):</p>
<pre><code class="language-javascript">&gt;   vp.addCredential(vc);
&gt;   vp.credentials
&lt;-  [
      {...}
    ]
</code></pre>
<p>Please note that the example was truncated to enhance readability.</p>
<h3 id="signing-a-verifiable-presentation"><a class="header" href="#signing-a-verifiable-presentation">Signing a Verifiable Presentation</a></h3>
<p>Once you've crafted your Verifiable Presentation and added your Verifiable
Credentials to it, it is time to sign it.</p>
<p>This can be achieved with the <code>sign</code> method. It requires a <code>keyDoc</code> parameter
(an object with the params and keys you'll use for signing), and a
<code>challenge</code> string for the proof.</p>
<p>It also accepts a <code>domain</code> string for the proof, a <code>resolver</code> in case you're
using DIDs and a boolean <code>compactProof</code> that determines whether you want to
compact the JSON-LD or not:</p>
<pre><code class="language-javascript">&gt;   await vp.sign(
          keyDoc,
          'some_challenge',
          'some_domain',
        );
</code></pre>
<p>Please note that signing is an async process.
Once done, your <code>vp</code> object will have a new <code>proof</code> field:</p>
<pre><code class="language-javascript">&gt;   vp.proof
&lt;-  {
      &quot;type&quot;: &quot;EcdsaSecp256k1Signature2019&quot;,
      &quot;created&quot;: &quot;2020-04-14T20:57:01Z&quot;,
      &quot;challenge&quot;: &quot;some_challenge&quot;,
      &quot;domain&quot;: &quot;some_domain&quot;,
      &quot;jws&quot;: &quot;eyJhbGciOiJFUzI1NksiLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ..MEUCIQCTTpivdcTKFDNdmzqe3l0nV6UjXgv0XvzCge--CTAV6wIgWfLqn_62U8jHkNSujrHFRmJ_ULj19b5rsNtjum09vbg&quot;,
      &quot;proofPurpose&quot;: &quot;authentication&quot;,
      &quot;verificationMethod&quot;: &quot;https://gist.githubusercontent.com/faustow/13f43164c571cf839044b60661173935/raw&quot;
    }
</code></pre>
<h3 id="verifying-a-verifiable-presentation"><a class="header" href="#verifying-a-verifiable-presentation">Verifying a Verifiable Presentation</a></h3>
<p>Once your Verifiable Presentation has been signed you can proceed to verify
it with the <code>verify</code> method.</p>
<p>If you've used DIDs you need to pass a <code>resolver</code> for them. You can also use
the booleans <code>compactProof</code> (to compact the JSON-LD) and
<code>forceRevocationCheck</code> (to force revocation check). Please beware that
setting <code>forceRevocationCheck</code> to false can allow false positives when
verifying revocable credentials.</p>
<p>If your credential has uses the <code>status</code> field, you can pass a
<code>revocationApi</code> param that accepts an object describing the API to use for
the revocation check.
For the simplest cases you only need a <code>challenge</code> string and possibly a
<code>domain</code> string:</p>
<pre><code class="language-javascript">&gt;   const results = await vp.verify({ challenge: 'some_challenge', domain: 'some_domain' });
&gt;   results
&lt;-  {
      &quot;presentationResult&quot;: {
        &quot;verified&quot;: true,
        &quot;results&quot;: [
          {
            &quot;proof&quot;: {
              &quot;@context&quot;: &quot;https://w3id.org/security/v2&quot;,
              &quot;type&quot;: &quot;EcdsaSecp256k1Signature2019&quot;,
              &quot;created&quot;: &quot;2020-04-14T20:57:01Z&quot;,
              &quot;challenge&quot;: &quot;some_challenge&quot;,
              &quot;domain&quot;: &quot;some_domain&quot;,
              &quot;jws&quot;: &quot;eyJhbGciOiJFUzI1NksiLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ..MEUCIQCTTpivdcTKFDNdmzqe3l0nV6UjXgv0XvzCge--CTAV6wIgWfLqn_62U8jHkNSujrHFRmJ_ULj19b5rsNtjum09vbg&quot;,
              &quot;proofPurpose&quot;: &quot;authentication&quot;,
              &quot;verificationMethod&quot;: &quot;https://gist.githubusercontent.com/faustow/13f43164c571cf839044b60661173935/raw&quot;
            },
            &quot;verified&quot;: true
          }
        ]
      },
      &quot;verified&quot;: true,
      &quot;credentialResults&quot;: [
        {
          &quot;verified&quot;: true,
          &quot;results&quot;: [
            {
              &quot;proof&quot;: {
                &quot;@context&quot;: &quot;https://w3id.org/security/v2&quot;,
                &quot;type&quot;: &quot;EcdsaSecp256k1Signature2019&quot;,
                &quot;created&quot;: &quot;2020-04-14T20:49:00Z&quot;,
                &quot;jws&quot;: &quot;eyJhbGciOiJFUzI1NksiLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ..MEUCIQCCCRuJbSUPePpOfkxsMJeQAqpydOFYWsA4cGiQRAR_QQIgehRZh8XE24hV0TPl5bMS6sNeKtC5rwZGfmflfY0eS-Y&quot;,
                &quot;proofPurpose&quot;: &quot;assertionMethod&quot;,
                &quot;verificationMethod&quot;: &quot;https://gist.githubusercontent.com/faustow/13f43164c571cf839044b60661173935/raw&quot;
              },
              &quot;verified&quot;: true
            }
          ]
        }
      ]
    }
</code></pre>
<p>Please note that the verification is an async process that returns an object
when the promise resolves.</p>
<p>This object contains separate results for the verification processes of the
included Verifiable Credentials and the overall Verifiable Presentation.</p>
<p>A boolean value for the entire verification process can be checked at the
root level <code>verified</code> property.</p>
<h2 id="using-dids"><a class="header" href="#using-dids">Using DIDs</a></h2>
<p>The examples shown above use different kinds of URIs as <code>id</code> property of
different sections. It is worth mentioning that the use of DIDs is not only
supported but also encouraged.</p>
<p>Their usage is very simple: create as many DIDs as you need and then use them instead of the URIs shown above.</p>
<p>For example when adding a subject to a Verifiable Credential here we're using a DID instead of a regular URI in the <code>id</code> property of the object:<code>vc.addSubject({ id: 'did:dock:123qwe123qwe123qwe', alumniOf: 'Example University' })</code>.</p>
<p>If you don't know how to create a DID there's a specific <a href="tutorial_did.html">tutorial on DIDs</a> you can read.</p>
<p>Bear in mind that you will need to provide a <code>resolver</code> method if you decide to use DIDs in your Verifiable Credentials or Verifiable Presentations. More on resolvers can be found in the <a href="tutorial_resolver.html">tutorial on Resolvers</a>.</p>
<p>Here's an example of issuing a Verifiable Credential using DIDs, provided that you've created and a DID that you store in <code>issuerDID</code>:</p>
<pre><code class="language-javascript">const issuerKey = getKeyDoc(issuerDID, dock.keyring.addFromUri(issuerSeed, null, 'ed25519'), 'Ed25519VerificationKey2018');
await vc.sign(issuerKey);
const verificationResult = await signedCredential.verify({ resolver, compactProof: true, forceRevocationCheck: true, revocationApi: { dock } });
console.log(verificationResult.verified); // Should print `true`
</code></pre>
<h2 id="creating-a-keydoc"><a class="header" href="#creating-a-keydoc">Creating a keyDoc</a></h2>
<p>It can be seen from the above examples that signing of credentials and
presentations require keypairs to be formatted into a <code>keyDoc</code> object.</p>
<p>There is a helper function to help with this formatting, it's called
<code>getKeyDoc</code> and it is located in the <code>vc</code> helpers.</p>
<p>Its usage is very simple, it accepts a <code>did</code> string which is a DID in fully
qualified form, a <code>keypair</code> object (generated by either using polkadot-js's
keyring for Sr25519 and Ed25519 or keypair generated with
<code>generateEcdsaSecp256k1Keypair</code> for curve secp256k1)
and a <code>type</code> string containing the type of the provided key (one of the
supported 'Sr25519VerificationKey2020', 'Ed25519VerificationKey2018' or
'EcdsaSecp256k1VerificationKey2019'):</p>
<pre><code class="language-javascript">  const keyDoc = getKeyDoc(did, keypair, type)
</code></pre>
<p>Please check the example on the <a href="tutorial_ipv.html#using-dids">previous section</a> or refer to the <a href="../../tests/integration/presenting.test.js">presenting integration tests</a> for a live example.</p>
<h1 id="revocation-1"><a class="header" href="#revocation-1">Revocation</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Credential revocation is managed with on-chain revocation registries. To revoke a credential, its id (or hash of its id) must be
added to the credential. It is advised to have one revocation registry per credential type. Each registry has a unique id and
an associated policy. The policy determines who can update the revocation registry. The registry also has an &quot;add-only&quot; flag specifying
whether an id once added to the registry can be removed (leading to undoing the revocation) or not.
Similar to the replay protection mechanism for DIDs, for each registry, the last modified block number is kept which is updated
each time a credential is revoked or unrevoked.
For now, only one policy is supported which is that each registry is owned by a single DID. Also, neither the policy
nor the &quot;add-only&quot; flag can be updated post the creation of the registry for now.</p>
<h2 id="registry-creation"><a class="header" href="#registry-creation">Registry creation</a></h2>
<p>To create a registry, first a <code>Policy</code> object needs to be created for which a DID is needed. It is advised that the DID
is registered on chain first (else someone can look at the registry a register the DID, thus controlling the registry).</p>
<pre><code class="language-js">import {OneOfPolicy} from '@docknetwork/sdk/utils/revocation';
const policy = new OneOfPolicy();
policy.addOwner(ownerDID);

// Or in a single step
const policy = new OneOfPolicy([ownerDID]);
</code></pre>
<p>Now create a random registry id. The registry id supposed to be unique among all registries on chain.</p>
<pre><code class="language-js">import {createRandomRegistryId} from '@docknetwork/sdk/utils/revocation';
const registryId = createRandomRegistryId();
</code></pre>
<p>Now send the transaction to create a registry on-chain using <code>dock.revocation.newRegistry</code>. This method accepts the registry id,
the policy object and a boolean that specifies whether the registry is add-only or not meaning that whether undoing revocations
is allowed or not. Ifs <code>true</code>, it makes the registry add-only meaning that undoing revocations is not allowed, if <code>false</code>,
undoing is allowed.</p>
<pre><code class="language-js">// Setting the last argument to false to allow unrevoking the credential (undoing revocation)
await dock.revocation.newRegistry(registryId, policy, false);
</code></pre>
<h2 id="revoking-a-credential"><a class="header" href="#revoking-a-credential">Revoking a credential</a></h2>
<p>Revoking a credential requires a signature from the owner of the registry. For that, fetch the owner's DID and pair and
create a map</p>
<pre><code class="language-js">const didKeys = new KeyringPairDidKeys();
didKeys.set(ownerDID, ownerKeypair);
</code></pre>
<p>Now get the registry id, <code>registryId</code> and the revocation id (the hash of credential id), <code>revokeId</code> and send the transaction on chain.
Revoking an already revoked credential has no effect.</p>
<pre><code class="language-js">await dock.revocation.revokeCredential(didKeys, registryId, revokeId);
</code></pre>
<p>Revoking multiple ids in a single transaction is possible but with a lower level method <code>dock.revocation.revoke</code>.</p>
<h2 id="undoing-a-revocation"><a class="header" href="#undoing-a-revocation">Undoing a revocation</a></h2>
<p>Similar to revocation, undoing the revocation also requires a signature from the owner of the registry. As before, fetch
the owner's DID and pair and create a map</p>
<pre><code class="language-js">const didKeys = new KeyringPairDidKeys();
didKeys.set(ownerDID, ownerKeypair);
</code></pre>
<p>Now get the registry id, <code>registryId</code> and the revocation id to undo, <code>revokeId</code> and send the transaction on chain.
Unrevoking an unrevoked credential has no effect.</p>
<pre><code class="language-js">await dock.revocation.unrevokeCredential(didKeys, registryId, revokeId);
</code></pre>
<p>Undoing revocation for multiple ids in a single transaction is possible but with a lower level method <code>dock.revocation.unrevoke</code>.</p>
<h2 id="checking-the-revocation-status"><a class="header" href="#checking-the-revocation-status">Checking the revocation status</a></h2>
<p>To check an id is revoked or not, call <code>dock.revocation.getIsRevoked</code> with the registry id and revocation id. Returns <code>true</code>
if revoked else <code>false</code>.</p>
<pre><code class="language-js">const isRevoked = await dock.revocation.getIsRevoked(registryId, revokeId);
</code></pre>
<h2 id="fetching-the-registry-details"><a class="header" href="#fetching-the-registry-details">Fetching the registry details</a></h2>
<p>To get the details of the registry like policy, add-only status and block number when it was last updated, use <code>dock.revocation.getRegistryDetail</code></p>
<h2 id="removing-the-registry"><a class="header" href="#removing-the-registry">Removing the registry</a></h2>
<p>A registry can be deleted leading to all the corresponding revocation ids being deleted as well. This requires the signature
from owner like other updates. Use the <code>dock.revocation.removeRegistry</code> method to remove a registry.</p>
<pre><code class="language-js">const lastModified = await dock.revocation.getBlockNoForLastChangeToRegistry(registryId);
await dock.revocation.removeRegistry(registryId, lastModified, didKeys);
</code></pre>
<h1 id="schemas-1"><a class="header" href="#schemas-1">Schemas</a></h1>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of contents</a></h2>
<ol>
<li><a href="tutorial_blobs_schemas.html#intro">Intro</a></li>
<li><a href="tutorial_blobs_schemas.html#blobs">Blobs</a>
<ol>
<li><a href="tutorial_blobs_schemas.html#writing-a-blob">Writing a Blob</a></li>
<li><a href="tutorial_blobs_schemas.html#reading-a-blob">Reading a Blob</a></li>
</ol>
</li>
<li><a href="tutorial_blobs_schemas.html#blobs">Schemas</a>
<ol>
<li><a href="tutorial_blobs_schemas.html#creating-a-schema">Creating a Schema</a></li>
<li><a href="tutorial_blobs_schemas.html#writing-a-schema-to-the-dock-chain">Writing a Schema</a></li>
<li><a href="tutorial_blobs_schemas.html#reading-a-schema-from-the-dock-chain">Reading a Schema</a></li>
<li><a href="tutorial_blobs_schemas.html#schemas-in-verifiable-credentials">Schemas in Verifiable Credentials</a></li>
<li><a href="tutorial_blobs_schemas.html#schemas-in-verifiable-presentations">Schemas in Verifiable Presentations</a></li>
</ol>
</li>
</ol>
<h2 id="intro-1"><a class="header" href="#intro-1">Intro</a></h2>
<p>Data Schemas are useful way of enforcing a specific structure on a collection of data like a Verifiable Credential.
Data schemas serve a different purpose than that of the <code>@context</code> property in a Verifiable Credential, the latter
neither enforces data structure or data syntax, nor enables the definition of arbitrary encodings to alternate
representation formats.</p>
<h2 id="blobs-1"><a class="header" href="#blobs-1">Blobs</a></h2>
<p>Schemas are stored on chain as a <code>Blob</code> in the Blob Storage module of the Dock chain, so understanding blobs is
important before diving into Schemas.</p>
<h3 id="writing-a-blob"><a class="header" href="#writing-a-blob">Writing a Blob</a></h3>
<p>A new Blob can be registered on the Dock Chain by using the method <code>writeToChain</code> in the BlobModule class.
It accepts a <code>blob</code> object with the struct to store on chain (it can either be a hex string or a byte array), and one of <code>keyPair</code> (a
keyPair to sign the extrinsic with) or a <code>signature</code> (if you prefer to sign the extrinsic offline). In return you'll get
a signed extrinsic that you can send to the Dock chain:</p>
<pre><code class="language-javascript">const blobId = randomAsHex(DockBlobIdByteSize); // 32-bytes long hex string to use as the blob's id
const blobStruct = {
  id: blobId,
  blob: blobHexOrArray,  // Contents of your blob as a hex string or byte array
  author: '0x...',       // hex part of a dock DID
}
const result = await dock.blob.writeToChain( blobStruct, keyPair);
</code></pre>
<p>If everything worked properly <code>result</code> will indicate a successful transaction.
We'll see how to retrieve the blob next.</p>
<h3 id="reading-a-blob"><a class="header" href="#reading-a-blob">Reading a Blob</a></h3>
<p>A Blob can be retrieved by using the method <code>get</code> in the BlobModule class.
It accepts a <code>blobId</code> string param which can either be a fully-qualified blob id like <code>blob:dock:0x...</code>
or just its hex identifier. In response you will receive a two-element array:</p>
<pre><code class="language-javascript">const chainBlob = await dock.blob.get(blobId);
</code></pre>
<p><code>chainBlob</code>'s first element will be the blob's author (a DID). It's second element will be the contents of your
blob (<code>blobHexOrArray</code> in our previous example).</p>
<h2 id="schemas-2"><a class="header" href="#schemas-2">Schemas</a></h2>
<p>Since Schemas are stored on chain as a <code>Blob</code> in the Blob Storage module, the <code>Schema</code> class uses the <code>BlobModule</code>
class internally. Schemas are identified and retrieved by their unique <code>blobId</code>, a 32 byte long hex string. As
mentioned, the chain is agnostic to the contents of blobs and thus to schemas.</p>
<h3 id="creating-a-schema"><a class="header" href="#creating-a-schema">Creating a Schema</a></h3>
<p>The first step to creating a Schema is to initialize it, we can do that using the <code>Schema</code> class constructor which
accepts an (optional) <code>id</code> string as sole argument:</p>
<pre><code class="language-javascript">const myNewSchema = new Schema();
</code></pre>
<p>When an <code>id</code> isn't passed, a random <code>blobId</code> will be assigned as the schema's id.</p>
<pre><code class="language-javascript">&gt; myNewSchema.id
&lt;- &quot;blob:dock:5Ek98pDX61Dwo4EDmsogUkYMBqfFHtiS5hVS7xHuVvMByh3N&quot;
</code></pre>
<p>Also worth noticing is the JSON representation of the schema as is right now, which can be achieved by calling
the <code>toJSON</code> method on your new schema:</p>
<pre><code class="language-javascript">&gt;  myNewSchema.toJSON()
&lt;- {&quot;id&quot;:&quot;0x768c21de02890dad5dbf6f108b6822b865e4ea495bb7f43f8947714e90fcc060&quot;}
</code></pre>
<p>where you can see that the schema's <code>id</code> gets modified with <code>getHexIdentifierFromBlobID</code>.</p>
<h4 id="setting-a-json-schema"><a class="header" href="#setting-a-json-schema">Setting a JSON Schema</a></h4>
<p>A JSON schema can be added with the <code>setJSONSchema</code> method. It accepts a single argument <code>json</code> (an object that is
checked to be a valid JSON schema before being added):</p>
<pre><code class="language-javascript">&gt;   const someNewJSONSchema = {
         $schema: 'http://json-schema.org/draft-07/schema#',
         description: 'Dock Schema Example',
         type: 'object',
         properties: {
           id: {
             type: 'string',
           },
           emailAddress: {
             type: 'string',
             format: 'email',
           },
           alumniOf: {
             type: 'string',
           },
         },
         required: ['emailAddress', 'alumniOf'],
         additionalProperties: false,
       }
&gt;   myNewSchema.setJSONSchema(someNewJSONSchema)
&gt;   myNewSchema.schema === someNewJSONSchema
&lt;-  true
</code></pre>
<h4 id="setting-an-author"><a class="header" href="#setting-an-author">Setting an author</a></h4>
<p>An author can be added with the <code>setAuthor</code> method. It accepts a single string argument <code>did</code> (which can be a DID's hex
identifier or a fully-quailified DID):</p>
<pre><code class="language-javascript">&gt;   const exampleAuthor = 'did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW';
&gt;   myNewSchema.setAuthor(exampleAuthor)
&gt;   myNewSchema.author === exampleAuthor
&lt;-  true
</code></pre>
<h4 id="signing-a-schema"><a class="header" href="#signing-a-schema">Signing a schema</a></h4>
<p>Signing a schema can be achieved by calling the <code>sign</code> method. It accepts a <code>keypair</code> param (a keyPair to sign with)
and a <code>blobModule</code> object:</p>
<pre><code class="language-javascript">&gt;   const keyring = new Keyring();
&gt;   const keypair = keyring.addFromUri(randomAsHex(32), null, 'sr25519');
&gt;   myNewSchema.sign(keypair, dockApi.blob)
&gt;   !!myNewSchema.signature
&lt;-  true
</code></pre>
<h4 id="setting-a-signature-manually"><a class="header" href="#setting-a-signature-manually">Setting a signature manually</a></h4>
<p>A signature can also be manually added with the <code>setSignature</code> method. It accepts a single argument <code>signature</code> (an instance
of <code>Signature</code>):</p>
<pre><code class="language-javascript">&gt;   const keyring = new Keyring();
&gt;   const keypair = keyring.addFromUri(randomAsHex(32), null, 'sr25519');
&gt;   const sig = new SignatureSr25519(msg, keypair);
&gt;   myNewSchema.setSignature(sig)
&gt;   myNewSchema.signature === sig
&lt;-  true
</code></pre>
<h4 id="formatting-for-storage"><a class="header" href="#formatting-for-storage">Formatting for storage</a></h4>
<p>Your new schema is now ready to be written to the Dock chain, the last step is to format it properly for the BlobModule
to be able to use it. That's where the <code>toBlob</code> method comes in handy:</p>
<pre><code class="language-javascript">&gt;   myNewSchema.toBlob()
&lt;-  {
      id: ...,
      blob: ...,
      author: ...,
    }
</code></pre>
<h3 id="writing-a-schema-to-the-dock-chain"><a class="header" href="#writing-a-schema-to-the-dock-chain">Writing a Schema to the Dock chain</a></h3>
<p>Writing a Schema to the Dock chain is similar to writing any other Blob. Once you've created your new schema following
the steps above you can use the <code>BlobModule</code> methods to interact with the chain:</p>
<pre><code class="language-javascript">&gt;  const formattedBlob = myNewSchema.toBlob(dockDID);
&gt;  await dock.blob.writeToChain(formattedBlob, keyPair);
</code></pre>
<h3 id="reading-a-schema-from-the-dock-chain"><a class="header" href="#reading-a-schema-from-the-dock-chain">Reading a Schema from the Dock chain</a></h3>
<p>Reading a Schema from the Dock chain can easily be achieved by using the <code>get</code> method from the <code>Schema</code> class.
It accepts a string <code>id</code> param (a fully-qualified blob id like &quot;blob:dock:0x...&quot; or just its hex identifier) and a
<code>dockAPI</code> instance:</p>
<pre><code class="language-javascript">&gt;  const result = await Schema.get(blob.id, dock);
</code></pre>
<p><code>result[0]</code> will be the author of the Schema, and <code>result[1]</code> will be the contents of the schema itself.</p>
<h3 id="schemas-in-verifiable-credentials-1"><a class="header" href="#schemas-in-verifiable-credentials-1">Schemas in Verifiable Credentials</a></h3>
<p>The <a href="https://www.w3.org/TR/vc-data-model/#data-schemas">VCDM spec</a> specify how the <code>credentialSchema</code> property should be
used when present. Basically, once you've created and stored your Schema on chain, you can reference to it by its
<code>blobId</code> when issuing a Verifiable Credential. Let's see an example:</p>
<pre><code class="language-javascript">&gt;    const dockApi = new DockAPI();
&gt;    const dockResolver = new DockResolver(dockApi);
&gt;    let validCredential = new VerifiableCredential('https://example.com/credentials/123');
&gt;    validCredential.addContext('https://www.w3.org/2018/credentials/examples/v1');
&gt;    const ctx1 = {
      '@context': {
        emailAddress: 'https://schema.org/email',
      },
    };
&gt;    validCredential.addContext(ctx1);
&gt;    validCredential.addType('AlumniCredential');
&gt;    validCredential.addSubject({
      id: dockDID,
      alumniOf: 'Example University',
      emailAddress: 'john@gmail.com',
    });
&gt;    validCredential.setSchema(blobHexIdToQualified(blobId), 'JsonSchemaValidator2018');
&gt;    await validCredential.sign(keyDoc);
&gt;    await validCredential.verify({
       resolver: dockResolver,
       compactProof: true,
       forceRevocationCheck: false,
       schemaApi: { dock: dockApi }
     });
</code></pre>
<p>Assuming that the <code>blobId</code> points to a schema taken from the previous examples, the verification above would fail if I
the <code>credentialSubject</code> in the Verifiable Credential didn't have one of the <code>alumniOf</code> or <code>emailAddress</code> properties.</p>
<h3 id="schemas-in-verifiable-presentations"><a class="header" href="#schemas-in-verifiable-presentations">Schemas in Verifiable Presentations</a></h3>
<p>The current implementation does not specify a way to specify a schema for a Verifiable Presentation itself.
However, a Verifiable Presentation may contain any number of Verifiable Credentials, each of which may or may not use a
Schema themselves. The <code>verify</code> method for Verifiable Presentations will enforce a schema validation in each of the
Verifiable Credentials contained in a presentation that are using the <code>credentialSchema</code> and <code>credentialSubject</code>
properties simultaneously.
This means that the verification of an otherwise valid Verifiable Presentation will fail if one of the Verifiable
Credentials contained within it uses a Schema and fails to pass schema validation.</p>
<h1 id="claim-deduction-1"><a class="header" href="#claim-deduction-1">Claim Deduction</a></h1>
<h2 id="specifying-axioms"><a class="header" href="#specifying-axioms">Specifying Axioms</a></h2>
<p>A Verifier has complete and low level control over the logical rules they deem valid. Rules may vary from use-case to use-case and from verifier to verifier.</p>
<p>Unwrapping of Explicit Ethos statements is expected to be a common first step when writing a ruleset. This tutorial will give some examples of that.</p>
<h3 id="simple-unwrapping-of-explicit-ethos"><a class="header" href="#simple-unwrapping-of-explicit-ethos">Simple Unwrapping of Explicit Ethos</a></h3>
<p>This ruleset names a specific issuer and states that any claims that issuer makes are true.</p>
<pre><code class="language-js">const rules = [
  {
    if_all: [
      [
        { Bound: { Iri: 'did:example:issuer' } },
        { Bound: { Iri: 'https://www.dock.io/rdf2020#claimsV1' } },
        { Unbound: 'claim' },
      ],
      [
        { Unbound: 'claim' },
        { Bound: { Iri: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#subject' } },
        { Unbound: 'subject' },
      ],
      [
        { Unbound: 'claim' },
        { Bound: { Iri: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate' } },
        { Unbound: 'predicate' },
      ],
      [
        { Unbound: 'claim' },
        { Bound: { Iri: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#object' } },
        { Unbound: 'object' },
      ],
    ],
    then: [
      [ { Unbound: 'subject' }, { Unbound: 'predicate' }, { Unbound: 'object' } ],
    ],
  }
];
</code></pre>
<p>That single rule is enough for some use-cases but it's not scalable. What if we want to allow more than one issuer? Instead of copying the same rule for each issuer we trust, let's define &quot;trustworthiness&quot;:</p>
<h3 id="unwrapping-explicit-ethos-by-defining-trustworthiness"><a class="header" href="#unwrapping-explicit-ethos-by-defining-trustworthiness">Unwrapping Explicit Ethos by Defining Trustworthiness</a></h3>
<pre><code class="language-js">const trustworthy =
  { Bound: { Iri: 'https://www.dock.io/rdf2020#Trustworthy' } };
const type =
  { Bound: { Iri: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type' } };
const claims =
  { Bound: { Iri: 'https://www.dock.io/rdf2020#claimsV1' } };
const subject =
  { Bound: { Iri: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#subject' } };
const predicate =
  { Bound: { Iri: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate' } };
const object =
  { Bound: { Iri: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#object' } };

const rules = [
  {
    if_all: [
      [
        { Unbound: 'issuer' },
        type,
        trustworthy,
      ],
      [
        { Unbound: 'issuer' },
        claims,
        { Unbound: 'claim' },
      ],
      [
        { Unbound: 'claim' },
        subject,
        { Unbound: 'subject' },
      ],
      [
        { Unbound: 'claim' },
        predicate,
        { Unbound: 'predicate' },
      ],
      [
        { Unbound: 'claim' },
        object,
        { Unbound: 'object' },
      ],
    ],
    then: [
      [ { Unbound: 'subject' }, { Unbound: 'predicate' }, { Unbound: 'object' } ],
    ],
  },
  {
    if_all: [],
    then: [
      [ { Bound: { Iri: 'did:example:issuer' } }, type, trustworthy ]
    ],
  }
];
</code></pre>
<p>You may ask &quot;So what's the difference? There is still only one issuer.&quot;</p>
<p>By the primitive definition of &quot;trustworthiness&quot; written above, any claim made by a trustworthy issuer is true. did:example:issuer can claim whatever they want by issuing verifiable credentials. They can even claim that some other issuer is trustworthy. Together, the two rules defined in the above example implement a system analogous to TLS certificate chains with did:example:issuer as the single root authority.</p>
<h2 id="proving-composite-claims"><a class="header" href="#proving-composite-claims">Proving Composite Claims</a></h2>
<p>As a Holder of verifiable credentials, you'll want to prove specific claims to a Verifier. If those claims are composite, you'll need to provide a deductive proof in your verifiable credentials presentation. This should be done after the presentation has been assembled. If the presentation is going to be signed, sign it <em>after</em> including the deductive proof.</p>
<pre><code class="language-js">import { proveCompositeClaims } from '@docknetwork/sdk/utils/cd';
import jsonld from 'jsonld';

// Check out the Issuance, Presentation, Verification tutorial for info on creating
// VCDM presentations.
const presentation = { ... };

// the claim we wish to prove
const compositeClaim = [
  { Iri: 'uuid:19e91192-210b-4b03-8e9c-8ded0a48d5bf' },
  { Iri: 'http://dbpedia.org/ontology/owner' },
  { Iri: 'did:example:bob' }
];

// SDK reasoning utilities take presentations in expanded form
// https://www.w3.org/TR/json-ld/#expanded-document-form
const expPres = await jsonld.expand(presentation);

let proof;
try {
  proof = await proveCompositeClaims(expPres, [compositeClaim], rules);
} catch (e) {
  console.error('couldn\'t prove bob is an owner');
  throw e;
}

// this is that standard property name of a Dock deductive proof in VCDM presentation
const logic = 'https://www.dock.io/rdf2020#logicV1';

presentation[logic] = proof;

// Now JSON.stringify(presentation) is ready to send to a verifier.
</code></pre>
<h2 id="verifying-composite-claims"><a class="header" href="#verifying-composite-claims">Verifying Composite Claims</a></h2>
<pre><code class="language-js">import { acceptCompositeClaims } from '../src/utils/cd';
import jsonld from 'jsonld';
import deepEqual from 'deep-equal';

/// received from the presenter
const presentation = ...;

// Check out the Issuance, Presentation, Verification tutorial for info on verifying
// VCDM presentations.
let ver = await verify(presentation);
if (!ver.verified) {
  throw ver;
}

const expPres = await jsonld.expand(presentation);

// acceptCompositeClaims will verify and take into account any deductive proof provided
// via the logic property
const claims = await acceptCompositeClaims(expPres, rules);

if (claims.some(claim =&gt; deepEqual(claim, compositeClaim))) {
  console.log('the composite claim was shown to be true');
} else {
  console.error('veracity of the composite claim is unknown');
}
</code></pre>
<h2 id="verifier-side-reasoning"><a class="header" href="#verifier-side-reasoning">Verifier-Side Reasoning</a></h2>
<p>Some use-cases may require the verifier to perform inference in place of the presenter.</p>
<pre><code class="language-js">import { proveCompositeClaims } from '../src/utils/cd';
import jsonld from 'jsonld';

/// received from the presenter
const presentation = ...;

// Check out the Issuance, Presentation, Verification tutorial for info on verifying
// VCDM presentations.
let ver = await verify(presentation);
if (!ver.verified) {
  throw ver;
}

const expPres = await jsonld.expand(presentation);

try {
  await proveCompositeClaims(expPres, [compositeClaim], rules);
  console.log('the composite claim was shown to be true');
} except (e) {
  console.error('veracity of the composite claim is unknown');
}
</code></pre>
<h2 id="we-need-to-go-deeper"><a class="header" href="#we-need-to-go-deeper">We Need to Go Deeper</a></h2>
<p>The SDK claim deduction module exposes lower level functionality for those who need it. <code>getImplications</code>, <code>proveh</code> and <code>validateh</code>, for example, operate on raw claimgraphs represented as adjacency lists. For even lower level access, check out our <a href="https://github.com/docknetwork/rify">inference engine</a> which is written in Rust and exposed to javascript via wasm.</p>
<h2 id="graphical-anchoring-utility"><a class="header" href="#graphical-anchoring-utility">Graphical Anchoring Utility</a></h2>
<p>You can also anchor without touching any code. Visit https://fe.dock.io/#/anchor/batch for creation of anchors and https://fe.dock.io/#/anchor/check for anchor verification.</p>
<h3 id="to-batch-or-not-to-batch"><a class="header" href="#to-batch-or-not-to-batch">To Batch, or not to Batch</a></h3>
<p>Batching (combining multiple anchors into one) can be used to save on transaction costs by anchoring multiple documents in a single transaction as a merkle tree root.</p>
<p>Batching does have a drawback. In order to verify a document that was anchored as part of the batch, you must provde the merkle proof that was generated when batching said file. Merkle proofs are expressed as <code>.proof.json</code> files and can be downloaded before posting the anchor. No merkle proof is required for batches containing only one document.</p>
<h2 id="programatic-usage"><a class="header" href="#programatic-usage">Programatic Usage</a></h2>
<p>The on-chain anchoring module allows to developers the flexibility talor anchors to their own use-case, but the sdk does provide a reference example for batching and anchoring documents.</p>
<p>The anchoring module is hashing algorithm and hash length agnostic. You can post a <a href="https://github.com/multiformats/multihash">multihash</a>, or even use the identity hash; the chain doesn't care.</p>
<p>One thing to note is that rather than storing your anchor directly, the anchoring module will store the blake2b256 hash of the anchor. This means as a developer you'll need to perform an additional hashing step when looking up anchors:</p>
<pre><code>// pseudocode

function postAnchor(file) {
  anchor = myHash(file)
  deploy(anchor)
}

fuction checkAnchor(file) {
  anchor = myHash(file)
  anchorblake = blake2b256(anchor)
  return lookup(anchorblake)
}
</code></pre>
<p>See the <code>example/anchor.js</code> in the sdk repository for more info.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
